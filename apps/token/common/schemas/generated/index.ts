import { z } from 'zod';
import { Prisma } from '@prisma/client';
import Decimal from 'decimal.js';

/////////////////////////////////////////
// HELPER FUNCTIONS
/////////////////////////////////////////

// DECIMAL
//------------------------------------------------------

export const DecimalJsLikeSchema: z.ZodType<Prisma.DecimalJsLike> = z.object({
  d: z.array(z.number()),
  e: z.number(),
  s: z.number(),
  toFixed: z.function(z.tuple([]), z.string()),
})

export const DECIMAL_STRING_REGEX = /^(?:-?Infinity|NaN|-?(?:0[bB][01]+(?:\.[01]+)?(?:[pP][-+]?\d+)?|0[oO][0-7]+(?:\.[0-7]+)?(?:[pP][-+]?\d+)?|0[xX][\da-fA-F]+(?:\.[\da-fA-F]+)?(?:[pP][-+]?\d+)?|(?:\d+|\d*\.\d+)(?:[eE][-+]?\d+)?))$/;

export const isValidDecimalInput =
  (v?: null | string | number | Prisma.DecimalJsLike): v is string | number | Prisma.DecimalJsLike => {
    if (v === undefined || v === null) return false;
    return (
      (typeof v === 'object' && 'd' in v && 'e' in v && 's' in v && 'toFixed' in v) ||
      (typeof v === 'string' && DECIMAL_STRING_REGEX.test(v)) ||
      typeof v === 'number'
    )
  };

/////////////////////////////////////////
// ENUMS
/////////////////////////////////////////

export const TransactionIsolationLevelSchema = z.enum(['ReadUncommitted','ReadCommitted','RepeatableRead','Serializable']);

export const UserScalarFieldEnumSchema = z.enum(['id','externalId','createdAt','updatedAt','deletedAt','name','walletAddress','email','emailVerified','image','isSiwe']);

export const WalletAddressScalarFieldEnumSchema = z.enum(['createdAt','updatedAt','deletedAt','walletAddress','chainId']);

export const SessionScalarFieldEnumSchema = z.enum(['id','createdAt','updatedAt','expiresAt','token','ipAddress','userAgent','userId']);

export const VerificationScalarFieldEnumSchema = z.enum(['id','createdAt','updatedAt','expiresAt','identifier','value']);

export const ProfileScalarFieldEnumSchema = z.enum(['id','createdAt','updatedAt','deletedAt','firstName','lastName','userId','email','phoneNumber','dateOfBirth']);

export const AddressScalarFieldEnumSchema = z.enum(['id','createdAt','updatedAt','deletedAt','userId','city','zipCode','country','state','street','formattedAddress','latitude','longitude']);

export const SaleScalarFieldEnumSchema = z.enum(['id','createdAt','updatedAt','deletedAt','name','status','saleCurrency','initialTokenQuantity','availableTokenQuantity','maximumTokenBuyPerUser','minimumTokenBuyPerUser','saleStartDate','tokenContractAddress','tokenContractChainId','tokenName','tokenTotalSupply','tokenPricePerUnit','tokenSymbol','toWalletsAddress','saleClosingDate','createdBy','saftCheckbox','saftContract','tokenId']);

export const DocumentScalarFieldEnumSchema = z.enum(['id','createdAt','updatedAt','deletedAt','name','fileName','url','type','saleId','userId']);

export const VestingScheduleScalarFieldEnumSchema = z.enum(['id','createdAt','updatedAt','deletedAt','saleId','name','cliffPeriod','vestingPeriod','releaseFrequency','initialRelease','isEnabled']);

export const TokenDistributionScalarFieldEnumSchema = z.enum(['id','createdAt','updatedAt','deletedAt','transactionId','amount','distributionDate','txHash','status']);

export const SaleInformationScalarFieldEnumSchema = z.enum(['id','createdAt','updatedAt','deletedAt','summary','tokenUtility','tokenDistribution','otherInformation','tokenLifecycle','liquidityPool','futurePlans','useOfProceeds','imageSale','imageToken','contactEmail','saleId']);

export const SaleTransactionsScalarFieldEnumSchema = z.enum(['id','createdAt','updatedAt','deletedAt','tokenSymbol','quantity','rawPrice','price','totalAmount','formOfPayment','confirmationId','receivingWallet','status','userId','saleId','comment','amountPaid','amountPaidCurrency','txHash','blockchainId','agreementId','approvedBy','rejectionReason','paymentEvidence','paymentDate']);

export const BlockchainScalarFieldEnumSchema = z.enum(['id','createdAt','updatedAt','deletedAt','name','chainId','rpcUrl','explorerUrl','isTestnet','isEnabled']);

export const ContractStatusScalarFieldEnumSchema = z.enum(['id','createdAt','updatedAt','deletedAt','userId','saleId','contractId','status']);

export const TransactionAuditScalarFieldEnumSchema = z.enum(['id','createdAt','updatedAt','deletedAt','transactionId','actionType','fromStatus','toStatus','performedBy','comment']);

export const KycVerificationScalarFieldEnumSchema = z.enum(['id','createdAt','updatedAt','deletedAt','userId','status','documentType','documentNumber','verifiedAt','rejectionReason']);

export const RoleScalarFieldEnumSchema = z.enum(['id','createdAt','updatedAt','deletedAt','name','description']);

export const UserRoleScalarFieldEnumSchema = z.enum(['createdAt','updatedAt','deletedAt','userId','roleId']);

export const TokenScalarFieldEnumSchema = z.enum(['id','createdAt','updatedAt','deletedAt','symbol','totalSupply','image']);

export const TokensOnBlockchainsScalarFieldEnumSchema = z.enum(['id','tokenId','tokenSymbol','blockchainId','name','isNative','decimals','contractAddress']);

export const SortOrderSchema = z.enum(['asc','desc']);

export const QueryModeSchema = z.enum(['default','insensitive']);

export const NullsOrderSchema = z.enum(['first','last']);

export const RegistrationStepSchema = z.enum(['REGISTRATION_NEW_ACCOUNT','REGISTRATION_PERSONAL_DETAIL','REGISTRATION_DOCUMENT_DETAIL','REGISTRATION_COMPLETED']);

export type RegistrationStepType = `${z.infer<typeof RegistrationStepSchema>}`

export const FOPSchema = z.enum(['CRYPTO','TRANSFER','CARD']);

export type FOPType = `${z.infer<typeof FOPSchema>}`

export const SaleStatusSchema = z.enum(['CREATED','OPEN','CLOSED','FINISHED']);

export type SaleStatusType = `${z.infer<typeof SaleStatusSchema>}`

export const CurrencySchema = z.enum(['CHF','GBP','USD','EUR','ETH','USDC','MATIC','LINK']);

export type CurrencyType = `${z.infer<typeof CurrencySchema>}`

export const TransactionStatusSchema = z.enum(['PENDING','AWAITING_PAYMENT','PAYMENT_SUBMITTED','PAYMENT_VERIFIED','REJECTED','CANCELLED','TOKENS_ALLOCATED','TOKENS_DISTRIBUTED','COMPLETED','REFUNDED']);

export type TransactionStatusType = `${z.infer<typeof TransactionStatusSchema>}`

export const ContractSignatureStatusSchema = z.enum(['PENDING','SIGNED']);

export type ContractSignatureStatusType = `${z.infer<typeof ContractSignatureStatusSchema>}`

export const EmailVerificationStatusSchema = z.enum(['VERIFIED','PENDING','NOTVERIFIED']);

export type EmailVerificationStatusType = `${z.infer<typeof EmailVerificationStatusSchema>}`

export const KycStatusSchema = z.enum(['NOT_STARTED','SUBMITTED','VERIFIED','REJECTED']);

export type KycStatusType = `${z.infer<typeof KycStatusSchema>}`

/////////////////////////////////////////
// MODELS
/////////////////////////////////////////

/////////////////////////////////////////
// USER SCHEMA
/////////////////////////////////////////

export const UserSchema = z.object({
  id: z.string().cuid(),
  /**
   * externalId is used to link the user to an external system
   */
  externalId: z.string().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
  name: z.string(),
  walletAddress: z.string(),
  email: z.string(),
  emailVerified: z.boolean(),
  image: z.string().nullable(),
  isSiwe: z.boolean().nullable(),
})

export type User = z.infer<typeof UserSchema>

/////////////////////////////////////////
// WALLET ADDRESS SCHEMA
/////////////////////////////////////////

export const WalletAddressSchema = z.object({
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
  walletAddress: z.string(),
  chainId: z.number().int(),
})

export type WalletAddress = z.infer<typeof WalletAddressSchema>

/////////////////////////////////////////
// SESSION SCHEMA
/////////////////////////////////////////

export const SessionSchema = z.object({
  id: z.string().cuid(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  expiresAt: z.coerce.date(),
  token: z.string(),
  ipAddress: z.string().nullable(),
  userAgent: z.string().nullable(),
  userId: z.string(),
})

export type Session = z.infer<typeof SessionSchema>

/////////////////////////////////////////
// VERIFICATION SCHEMA
/////////////////////////////////////////

export const VerificationSchema = z.object({
  id: z.string().cuid(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  expiresAt: z.coerce.date(),
  identifier: z.string(),
  value: z.string(),
})

export type Verification = z.infer<typeof VerificationSchema>

/////////////////////////////////////////
// PROFILE SCHEMA
/////////////////////////////////////////

export const ProfileSchema = z.object({
  id: z.string().cuid(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
  firstName: z.string().nullable(),
  lastName: z.string().nullable(),
  userId: z.string(),
  email: z.string().nullable(),
  phoneNumber: z.string().nullable(),
  dateOfBirth: z.coerce.date().nullable(),
})

export type Profile = z.infer<typeof ProfileSchema>

/////////////////////////////////////////
// ADDRESS SCHEMA
/////////////////////////////////////////

export const AddressSchema = z.object({
  id: z.string().cuid(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
  userId: z.string(),
  city: z.string().nullable(),
  zipCode: z.string().nullable(),
  country: z.string().nullable(),
  state: z.string().nullable(),
  street: z.string().nullable(),
  formattedAddress: z.string().nullable(),
  latitude: z.number().nullable(),
  longitude: z.number().nullable(),
})

export type Address = z.infer<typeof AddressSchema>

/////////////////////////////////////////
// SALE SCHEMA
/////////////////////////////////////////

export const SaleSchema = z.object({
  status: SaleStatusSchema,
  saleCurrency: CurrencySchema,
  id: z.string().cuid(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
  name: z.string(),
  initialTokenQuantity: z.number().int(),
  availableTokenQuantity: z.number().int(),
  maximumTokenBuyPerUser: z.number().int().nullable(),
  minimumTokenBuyPerUser: z.number().int(),
  saleStartDate: z.coerce.date(),
  tokenContractAddress: z.string().nullable(),
  tokenContractChainId: z.number().int().nullable(),
  tokenName: z.string(),
  tokenTotalSupply: z.string().nullable(),
  tokenPricePerUnit: z.instanceof(Prisma.Decimal, { message: "Field 'tokenPricePerUnit' must be a Decimal. Location: ['Models', 'Sale']"}),
  tokenSymbol: z.string(),
  toWalletsAddress: z.string(),
  saleClosingDate: z.coerce.date(),
  createdBy: z.string(),
  saftCheckbox: z.boolean(),
  saftContract: z.string().nullable(),
  tokenId: z.string(),
})

export type Sale = z.infer<typeof SaleSchema>

/////////////////////////////////////////
// DOCUMENT SCHEMA
/////////////////////////////////////////

export const DocumentSchema = z.object({
  id: z.string().cuid(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
  name: z.string(),
  fileName: z.string(),
  url: z.string(),
  type: z.string(),
  saleId: z.string().nullable(),
  userId: z.string().nullable(),
})

export type Document = z.infer<typeof DocumentSchema>

/////////////////////////////////////////
// VESTING SCHEDULE SCHEMA
/////////////////////////////////////////

export const VestingScheduleSchema = z.object({
  id: z.string().cuid(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
  saleId: z.string(),
  name: z.string(),
  cliffPeriod: z.number().int(),
  vestingPeriod: z.number().int(),
  releaseFrequency: z.number().int(),
  initialRelease: z.number(),
  isEnabled: z.boolean(),
})

export type VestingSchedule = z.infer<typeof VestingScheduleSchema>

/////////////////////////////////////////
// TOKEN DISTRIBUTION SCHEMA
/////////////////////////////////////////

export const TokenDistributionSchema = z.object({
  id: z.string().cuid(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
  transactionId: z.string(),
  amount: z.string(),
  distributionDate: z.coerce.date(),
  txHash: z.string().nullable(),
  status: z.string(),
})

export type TokenDistribution = z.infer<typeof TokenDistributionSchema>

/////////////////////////////////////////
// SALE INFORMATION SCHEMA
/////////////////////////////////////////

export const SaleInformationSchema = z.object({
  id: z.string().cuid(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
  summary: z.string().nullable(),
  tokenUtility: z.string().nullable(),
  tokenDistribution: z.string().nullable(),
  otherInformation: z.string().nullable(),
  tokenLifecycle: z.string().nullable(),
  liquidityPool: z.string().nullable(),
  futurePlans: z.string().nullable(),
  useOfProceeds: z.string().nullable(),
  imageSale: z.string().nullable(),
  imageToken: z.string().nullable(),
  contactEmail: z.string().nullable(),
  saleId: z.string(),
})

export type SaleInformation = z.infer<typeof SaleInformationSchema>

/////////////////////////////////////////
// SALE TRANSACTIONS SCHEMA
/////////////////////////////////////////

export const SaleTransactionsSchema = z.object({
  formOfPayment: FOPSchema,
  status: TransactionStatusSchema,
  amountPaidCurrency: CurrencySchema,
  id: z.string().cuid(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
  tokenSymbol: z.string(),
  quantity: z.instanceof(Prisma.Decimal, { message: "Field 'quantity' must be a Decimal. Location: ['Models', 'SaleTransactions']"}),
  rawPrice: z.string(),
  price: z.instanceof(Prisma.Decimal, { message: "Field 'price' must be a Decimal. Location: ['Models', 'SaleTransactions']"}),
  totalAmount: z.instanceof(Prisma.Decimal, { message: "Field 'totalAmount' must be a Decimal. Location: ['Models', 'SaleTransactions']"}),
  confirmationId: z.string().nullable(),
  receivingWallet: z.string().nullable(),
  userId: z.string(),
  saleId: z.string(),
  comment: z.string().nullable(),
  amountPaid: z.string(),
  txHash: z.string().nullable(),
  blockchainId: z.string().nullable(),
  agreementId: z.string().nullable(),
  approvedBy: z.string().nullable(),
  rejectionReason: z.string().nullable(),
  paymentEvidence: z.string().nullable(),
  paymentDate: z.coerce.date().nullable(),
})

export type SaleTransactions = z.infer<typeof SaleTransactionsSchema>

/////////////////////////////////////////
// BLOCKCHAIN SCHEMA
/////////////////////////////////////////

export const BlockchainSchema = z.object({
  id: z.string().cuid(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
  name: z.string(),
  chainId: z.number().int(),
  rpcUrl: z.string(),
  explorerUrl: z.string().nullable(),
  isTestnet: z.boolean(),
  isEnabled: z.boolean(),
})

export type Blockchain = z.infer<typeof BlockchainSchema>

/////////////////////////////////////////
// CONTRACT STATUS SCHEMA
/////////////////////////////////////////

export const ContractStatusSchema = z.object({
  status: ContractSignatureStatusSchema,
  id: z.string().cuid(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
  userId: z.string(),
  saleId: z.string(),
  contractId: z.string(),
})

export type ContractStatus = z.infer<typeof ContractStatusSchema>

/////////////////////////////////////////
// TRANSACTION AUDIT SCHEMA
/////////////////////////////////////////

export const TransactionAuditSchema = z.object({
  fromStatus: TransactionStatusSchema,
  toStatus: TransactionStatusSchema,
  id: z.string().cuid(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
  transactionId: z.string(),
  actionType: z.string(),
  performedBy: z.string(),
  comment: z.string().nullable(),
})

export type TransactionAudit = z.infer<typeof TransactionAuditSchema>

/////////////////////////////////////////
// KYC VERIFICATION SCHEMA
/////////////////////////////////////////

export const KycVerificationSchema = z.object({
  status: KycStatusSchema,
  id: z.string().cuid(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
  userId: z.string(),
  documentType: z.string().nullable(),
  documentNumber: z.string().nullable(),
  verifiedAt: z.coerce.date().nullable(),
  rejectionReason: z.string().nullable(),
})

export type KycVerification = z.infer<typeof KycVerificationSchema>

/////////////////////////////////////////
// ROLE SCHEMA
/////////////////////////////////////////

export const RoleSchema = z.object({
  id: z.string().cuid(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
  name: z.string(),
  description: z.string().nullable(),
})

export type Role = z.infer<typeof RoleSchema>

/////////////////////////////////////////
// USER ROLE SCHEMA
/////////////////////////////////////////

export const UserRoleSchema = z.object({
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
  userId: z.string(),
  roleId: z.string(),
})

export type UserRole = z.infer<typeof UserRoleSchema>

/////////////////////////////////////////
// TOKEN SCHEMA
/////////////////////////////////////////

export const TokenSchema = z.object({
  id: z.string().cuid(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  deletedAt: z.coerce.date().nullable(),
  symbol: z.string(),
  totalSupply: z.string().nullable(),
  image: z.string().nullable(),
})

export type Token = z.infer<typeof TokenSchema>

/////////////////////////////////////////
// TOKENS ON BLOCKCHAINS SCHEMA
/////////////////////////////////////////

export const TokensOnBlockchainsSchema = z.object({
  id: z.string().cuid(),
  tokenId: z.string(),
  tokenSymbol: z.string(),
  blockchainId: z.string(),
  name: z.string(),
  isNative: z.boolean(),
  decimals: z.number().int(),
  contractAddress: z.string().nullable(),
})

export type TokensOnBlockchains = z.infer<typeof TokensOnBlockchainsSchema>

/////////////////////////////////////////
// SELECT & INCLUDE
/////////////////////////////////////////

// USER
//------------------------------------------------------

export const UserIncludeSchema: z.ZodType<Prisma.UserInclude> = z.object({
  profile: z.union([z.boolean(),z.lazy(() => ProfileArgsSchema)]).optional(),
  sales: z.union([z.boolean(),z.lazy(() => SaleFindManyArgsSchema)]).optional(),
  userRole: z.union([z.boolean(),z.lazy(() => UserRoleFindManyArgsSchema)]).optional(),
  transactionAudit: z.union([z.boolean(),z.lazy(() => TransactionAuditFindManyArgsSchema)]).optional(),
  kycVerification: z.union([z.boolean(),z.lazy(() => KycVerificationArgsSchema)]).optional(),
  sessions: z.union([z.boolean(),z.lazy(() => SessionFindManyArgsSchema)]).optional(),
  transactions: z.union([z.boolean(),z.lazy(() => SaleTransactionsFindManyArgsSchema)]).optional(),
  transactionApprovals: z.union([z.boolean(),z.lazy(() => SaleTransactionsFindManyArgsSchema)]).optional(),
  Document: z.union([z.boolean(),z.lazy(() => DocumentFindManyArgsSchema)]).optional(),
  WalletAddress: z.union([z.boolean(),z.lazy(() => WalletAddressFindManyArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => UserCountOutputTypeArgsSchema)]).optional(),
}).strict()

export const UserArgsSchema: z.ZodType<Prisma.UserDefaultArgs> = z.object({
  select: z.lazy(() => UserSelectSchema).optional(),
  include: z.lazy(() => UserIncludeSchema).optional(),
}).strict();

export const UserCountOutputTypeArgsSchema: z.ZodType<Prisma.UserCountOutputTypeDefaultArgs> = z.object({
  select: z.lazy(() => UserCountOutputTypeSelectSchema).nullish(),
}).strict();

export const UserCountOutputTypeSelectSchema: z.ZodType<Prisma.UserCountOutputTypeSelect> = z.object({
  sales: z.boolean().optional(),
  userRole: z.boolean().optional(),
  transactionAudit: z.boolean().optional(),
  sessions: z.boolean().optional(),
  transactions: z.boolean().optional(),
  transactionApprovals: z.boolean().optional(),
  Document: z.boolean().optional(),
  WalletAddress: z.boolean().optional(),
}).strict();

export const UserSelectSchema: z.ZodType<Prisma.UserSelect> = z.object({
  id: z.boolean().optional(),
  externalId: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  updatedAt: z.boolean().optional(),
  deletedAt: z.boolean().optional(),
  name: z.boolean().optional(),
  walletAddress: z.boolean().optional(),
  email: z.boolean().optional(),
  emailVerified: z.boolean().optional(),
  image: z.boolean().optional(),
  isSiwe: z.boolean().optional(),
  profile: z.union([z.boolean(),z.lazy(() => ProfileArgsSchema)]).optional(),
  sales: z.union([z.boolean(),z.lazy(() => SaleFindManyArgsSchema)]).optional(),
  userRole: z.union([z.boolean(),z.lazy(() => UserRoleFindManyArgsSchema)]).optional(),
  transactionAudit: z.union([z.boolean(),z.lazy(() => TransactionAuditFindManyArgsSchema)]).optional(),
  kycVerification: z.union([z.boolean(),z.lazy(() => KycVerificationArgsSchema)]).optional(),
  sessions: z.union([z.boolean(),z.lazy(() => SessionFindManyArgsSchema)]).optional(),
  transactions: z.union([z.boolean(),z.lazy(() => SaleTransactionsFindManyArgsSchema)]).optional(),
  transactionApprovals: z.union([z.boolean(),z.lazy(() => SaleTransactionsFindManyArgsSchema)]).optional(),
  Document: z.union([z.boolean(),z.lazy(() => DocumentFindManyArgsSchema)]).optional(),
  WalletAddress: z.union([z.boolean(),z.lazy(() => WalletAddressFindManyArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => UserCountOutputTypeArgsSchema)]).optional(),
}).strict()

// WALLET ADDRESS
//------------------------------------------------------

export const WalletAddressIncludeSchema: z.ZodType<Prisma.WalletAddressInclude> = z.object({
  address: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
}).strict()

export const WalletAddressArgsSchema: z.ZodType<Prisma.WalletAddressDefaultArgs> = z.object({
  select: z.lazy(() => WalletAddressSelectSchema).optional(),
  include: z.lazy(() => WalletAddressIncludeSchema).optional(),
}).strict();

export const WalletAddressSelectSchema: z.ZodType<Prisma.WalletAddressSelect> = z.object({
  createdAt: z.boolean().optional(),
  updatedAt: z.boolean().optional(),
  deletedAt: z.boolean().optional(),
  walletAddress: z.boolean().optional(),
  chainId: z.boolean().optional(),
  address: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
}).strict()

// SESSION
//------------------------------------------------------

export const SessionIncludeSchema: z.ZodType<Prisma.SessionInclude> = z.object({
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
}).strict()

export const SessionArgsSchema: z.ZodType<Prisma.SessionDefaultArgs> = z.object({
  select: z.lazy(() => SessionSelectSchema).optional(),
  include: z.lazy(() => SessionIncludeSchema).optional(),
}).strict();

export const SessionSelectSchema: z.ZodType<Prisma.SessionSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  updatedAt: z.boolean().optional(),
  expiresAt: z.boolean().optional(),
  token: z.boolean().optional(),
  ipAddress: z.boolean().optional(),
  userAgent: z.boolean().optional(),
  userId: z.boolean().optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
}).strict()

// VERIFICATION
//------------------------------------------------------

export const VerificationSelectSchema: z.ZodType<Prisma.VerificationSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  updatedAt: z.boolean().optional(),
  expiresAt: z.boolean().optional(),
  identifier: z.boolean().optional(),
  value: z.boolean().optional(),
}).strict()

// PROFILE
//------------------------------------------------------

export const ProfileIncludeSchema: z.ZodType<Prisma.ProfileInclude> = z.object({
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  address: z.union([z.boolean(),z.lazy(() => AddressArgsSchema)]).optional(),
}).strict()

export const ProfileArgsSchema: z.ZodType<Prisma.ProfileDefaultArgs> = z.object({
  select: z.lazy(() => ProfileSelectSchema).optional(),
  include: z.lazy(() => ProfileIncludeSchema).optional(),
}).strict();

export const ProfileSelectSchema: z.ZodType<Prisma.ProfileSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  updatedAt: z.boolean().optional(),
  deletedAt: z.boolean().optional(),
  firstName: z.boolean().optional(),
  lastName: z.boolean().optional(),
  userId: z.boolean().optional(),
  email: z.boolean().optional(),
  phoneNumber: z.boolean().optional(),
  dateOfBirth: z.boolean().optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  address: z.union([z.boolean(),z.lazy(() => AddressArgsSchema)]).optional(),
}).strict()

// ADDRESS
//------------------------------------------------------

export const AddressIncludeSchema: z.ZodType<Prisma.AddressInclude> = z.object({
  profile: z.union([z.boolean(),z.lazy(() => ProfileArgsSchema)]).optional(),
}).strict()

export const AddressArgsSchema: z.ZodType<Prisma.AddressDefaultArgs> = z.object({
  select: z.lazy(() => AddressSelectSchema).optional(),
  include: z.lazy(() => AddressIncludeSchema).optional(),
}).strict();

export const AddressSelectSchema: z.ZodType<Prisma.AddressSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  updatedAt: z.boolean().optional(),
  deletedAt: z.boolean().optional(),
  userId: z.boolean().optional(),
  city: z.boolean().optional(),
  zipCode: z.boolean().optional(),
  country: z.boolean().optional(),
  state: z.boolean().optional(),
  street: z.boolean().optional(),
  formattedAddress: z.boolean().optional(),
  latitude: z.boolean().optional(),
  longitude: z.boolean().optional(),
  profile: z.union([z.boolean(),z.lazy(() => ProfileArgsSchema)]).optional(),
}).strict()

// SALE
//------------------------------------------------------

export const SaleIncludeSchema: z.ZodType<Prisma.SaleInclude> = z.object({
  blockchain: z.union([z.boolean(),z.lazy(() => BlockchainArgsSchema)]).optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  transactions: z.union([z.boolean(),z.lazy(() => SaleTransactionsFindManyArgsSchema)]).optional(),
  saleInformation: z.union([z.boolean(),z.lazy(() => SaleInformationArgsSchema)]).optional(),
  documents: z.union([z.boolean(),z.lazy(() => DocumentFindManyArgsSchema)]).optional(),
  token: z.union([z.boolean(),z.lazy(() => TokenArgsSchema)]).optional(),
  vestingSchedules: z.union([z.boolean(),z.lazy(() => VestingScheduleFindManyArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => SaleCountOutputTypeArgsSchema)]).optional(),
}).strict()

export const SaleArgsSchema: z.ZodType<Prisma.SaleDefaultArgs> = z.object({
  select: z.lazy(() => SaleSelectSchema).optional(),
  include: z.lazy(() => SaleIncludeSchema).optional(),
}).strict();

export const SaleCountOutputTypeArgsSchema: z.ZodType<Prisma.SaleCountOutputTypeDefaultArgs> = z.object({
  select: z.lazy(() => SaleCountOutputTypeSelectSchema).nullish(),
}).strict();

export const SaleCountOutputTypeSelectSchema: z.ZodType<Prisma.SaleCountOutputTypeSelect> = z.object({
  transactions: z.boolean().optional(),
  documents: z.boolean().optional(),
  vestingSchedules: z.boolean().optional(),
}).strict();

export const SaleSelectSchema: z.ZodType<Prisma.SaleSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  updatedAt: z.boolean().optional(),
  deletedAt: z.boolean().optional(),
  name: z.boolean().optional(),
  status: z.boolean().optional(),
  saleCurrency: z.boolean().optional(),
  initialTokenQuantity: z.boolean().optional(),
  availableTokenQuantity: z.boolean().optional(),
  maximumTokenBuyPerUser: z.boolean().optional(),
  minimumTokenBuyPerUser: z.boolean().optional(),
  saleStartDate: z.boolean().optional(),
  tokenContractAddress: z.boolean().optional(),
  tokenContractChainId: z.boolean().optional(),
  tokenName: z.boolean().optional(),
  tokenTotalSupply: z.boolean().optional(),
  tokenPricePerUnit: z.boolean().optional(),
  tokenSymbol: z.boolean().optional(),
  toWalletsAddress: z.boolean().optional(),
  saleClosingDate: z.boolean().optional(),
  createdBy: z.boolean().optional(),
  saftCheckbox: z.boolean().optional(),
  saftContract: z.boolean().optional(),
  tokenId: z.boolean().optional(),
  blockchain: z.union([z.boolean(),z.lazy(() => BlockchainArgsSchema)]).optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  transactions: z.union([z.boolean(),z.lazy(() => SaleTransactionsFindManyArgsSchema)]).optional(),
  saleInformation: z.union([z.boolean(),z.lazy(() => SaleInformationArgsSchema)]).optional(),
  documents: z.union([z.boolean(),z.lazy(() => DocumentFindManyArgsSchema)]).optional(),
  token: z.union([z.boolean(),z.lazy(() => TokenArgsSchema)]).optional(),
  vestingSchedules: z.union([z.boolean(),z.lazy(() => VestingScheduleFindManyArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => SaleCountOutputTypeArgsSchema)]).optional(),
}).strict()

// DOCUMENT
//------------------------------------------------------

export const DocumentIncludeSchema: z.ZodType<Prisma.DocumentInclude> = z.object({
  sale: z.union([z.boolean(),z.lazy(() => SaleArgsSchema)]).optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
}).strict()

export const DocumentArgsSchema: z.ZodType<Prisma.DocumentDefaultArgs> = z.object({
  select: z.lazy(() => DocumentSelectSchema).optional(),
  include: z.lazy(() => DocumentIncludeSchema).optional(),
}).strict();

export const DocumentSelectSchema: z.ZodType<Prisma.DocumentSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  updatedAt: z.boolean().optional(),
  deletedAt: z.boolean().optional(),
  name: z.boolean().optional(),
  fileName: z.boolean().optional(),
  url: z.boolean().optional(),
  type: z.boolean().optional(),
  saleId: z.boolean().optional(),
  userId: z.boolean().optional(),
  sale: z.union([z.boolean(),z.lazy(() => SaleArgsSchema)]).optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
}).strict()

// VESTING SCHEDULE
//------------------------------------------------------

export const VestingScheduleIncludeSchema: z.ZodType<Prisma.VestingScheduleInclude> = z.object({
  sale: z.union([z.boolean(),z.lazy(() => SaleArgsSchema)]).optional(),
}).strict()

export const VestingScheduleArgsSchema: z.ZodType<Prisma.VestingScheduleDefaultArgs> = z.object({
  select: z.lazy(() => VestingScheduleSelectSchema).optional(),
  include: z.lazy(() => VestingScheduleIncludeSchema).optional(),
}).strict();

export const VestingScheduleSelectSchema: z.ZodType<Prisma.VestingScheduleSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  updatedAt: z.boolean().optional(),
  deletedAt: z.boolean().optional(),
  saleId: z.boolean().optional(),
  name: z.boolean().optional(),
  cliffPeriod: z.boolean().optional(),
  vestingPeriod: z.boolean().optional(),
  releaseFrequency: z.boolean().optional(),
  initialRelease: z.boolean().optional(),
  isEnabled: z.boolean().optional(),
  sale: z.union([z.boolean(),z.lazy(() => SaleArgsSchema)]).optional(),
}).strict()

// TOKEN DISTRIBUTION
//------------------------------------------------------

export const TokenDistributionIncludeSchema: z.ZodType<Prisma.TokenDistributionInclude> = z.object({
  transaction: z.union([z.boolean(),z.lazy(() => SaleTransactionsArgsSchema)]).optional(),
}).strict()

export const TokenDistributionArgsSchema: z.ZodType<Prisma.TokenDistributionDefaultArgs> = z.object({
  select: z.lazy(() => TokenDistributionSelectSchema).optional(),
  include: z.lazy(() => TokenDistributionIncludeSchema).optional(),
}).strict();

export const TokenDistributionSelectSchema: z.ZodType<Prisma.TokenDistributionSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  updatedAt: z.boolean().optional(),
  deletedAt: z.boolean().optional(),
  transactionId: z.boolean().optional(),
  amount: z.boolean().optional(),
  distributionDate: z.boolean().optional(),
  txHash: z.boolean().optional(),
  status: z.boolean().optional(),
  transaction: z.union([z.boolean(),z.lazy(() => SaleTransactionsArgsSchema)]).optional(),
}).strict()

// SALE INFORMATION
//------------------------------------------------------

export const SaleInformationIncludeSchema: z.ZodType<Prisma.SaleInformationInclude> = z.object({
  sale: z.union([z.boolean(),z.lazy(() => SaleArgsSchema)]).optional(),
}).strict()

export const SaleInformationArgsSchema: z.ZodType<Prisma.SaleInformationDefaultArgs> = z.object({
  select: z.lazy(() => SaleInformationSelectSchema).optional(),
  include: z.lazy(() => SaleInformationIncludeSchema).optional(),
}).strict();

export const SaleInformationSelectSchema: z.ZodType<Prisma.SaleInformationSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  updatedAt: z.boolean().optional(),
  deletedAt: z.boolean().optional(),
  summary: z.boolean().optional(),
  tokenUtility: z.boolean().optional(),
  tokenDistribution: z.boolean().optional(),
  otherInformation: z.boolean().optional(),
  tokenLifecycle: z.boolean().optional(),
  liquidityPool: z.boolean().optional(),
  futurePlans: z.boolean().optional(),
  useOfProceeds: z.boolean().optional(),
  imageSale: z.boolean().optional(),
  imageToken: z.boolean().optional(),
  contactEmail: z.boolean().optional(),
  saleId: z.boolean().optional(),
  sale: z.union([z.boolean(),z.lazy(() => SaleArgsSchema)]).optional(),
}).strict()

// SALE TRANSACTIONS
//------------------------------------------------------

export const SaleTransactionsIncludeSchema: z.ZodType<Prisma.SaleTransactionsInclude> = z.object({
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  sale: z.union([z.boolean(),z.lazy(() => SaleArgsSchema)]).optional(),
  blockchain: z.union([z.boolean(),z.lazy(() => BlockchainArgsSchema)]).optional(),
  approver: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  auditTrail: z.union([z.boolean(),z.lazy(() => TransactionAuditFindManyArgsSchema)]).optional(),
  tokenDistributions: z.union([z.boolean(),z.lazy(() => TokenDistributionFindManyArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => SaleTransactionsCountOutputTypeArgsSchema)]).optional(),
}).strict()

export const SaleTransactionsArgsSchema: z.ZodType<Prisma.SaleTransactionsDefaultArgs> = z.object({
  select: z.lazy(() => SaleTransactionsSelectSchema).optional(),
  include: z.lazy(() => SaleTransactionsIncludeSchema).optional(),
}).strict();

export const SaleTransactionsCountOutputTypeArgsSchema: z.ZodType<Prisma.SaleTransactionsCountOutputTypeDefaultArgs> = z.object({
  select: z.lazy(() => SaleTransactionsCountOutputTypeSelectSchema).nullish(),
}).strict();

export const SaleTransactionsCountOutputTypeSelectSchema: z.ZodType<Prisma.SaleTransactionsCountOutputTypeSelect> = z.object({
  auditTrail: z.boolean().optional(),
  tokenDistributions: z.boolean().optional(),
}).strict();

export const SaleTransactionsSelectSchema: z.ZodType<Prisma.SaleTransactionsSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  updatedAt: z.boolean().optional(),
  deletedAt: z.boolean().optional(),
  tokenSymbol: z.boolean().optional(),
  quantity: z.boolean().optional(),
  rawPrice: z.boolean().optional(),
  price: z.boolean().optional(),
  totalAmount: z.boolean().optional(),
  formOfPayment: z.boolean().optional(),
  confirmationId: z.boolean().optional(),
  receivingWallet: z.boolean().optional(),
  status: z.boolean().optional(),
  userId: z.boolean().optional(),
  saleId: z.boolean().optional(),
  comment: z.boolean().optional(),
  amountPaid: z.boolean().optional(),
  amountPaidCurrency: z.boolean().optional(),
  txHash: z.boolean().optional(),
  blockchainId: z.boolean().optional(),
  agreementId: z.boolean().optional(),
  approvedBy: z.boolean().optional(),
  rejectionReason: z.boolean().optional(),
  paymentEvidence: z.boolean().optional(),
  paymentDate: z.boolean().optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  sale: z.union([z.boolean(),z.lazy(() => SaleArgsSchema)]).optional(),
  blockchain: z.union([z.boolean(),z.lazy(() => BlockchainArgsSchema)]).optional(),
  approver: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  auditTrail: z.union([z.boolean(),z.lazy(() => TransactionAuditFindManyArgsSchema)]).optional(),
  tokenDistributions: z.union([z.boolean(),z.lazy(() => TokenDistributionFindManyArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => SaleTransactionsCountOutputTypeArgsSchema)]).optional(),
}).strict()

// BLOCKCHAIN
//------------------------------------------------------

export const BlockchainIncludeSchema: z.ZodType<Prisma.BlockchainInclude> = z.object({
  transactions: z.union([z.boolean(),z.lazy(() => SaleTransactionsFindManyArgsSchema)]).optional(),
  TokensOnBlockchains: z.union([z.boolean(),z.lazy(() => TokensOnBlockchainsFindManyArgsSchema)]).optional(),
  Sale: z.union([z.boolean(),z.lazy(() => SaleFindManyArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => BlockchainCountOutputTypeArgsSchema)]).optional(),
}).strict()

export const BlockchainArgsSchema: z.ZodType<Prisma.BlockchainDefaultArgs> = z.object({
  select: z.lazy(() => BlockchainSelectSchema).optional(),
  include: z.lazy(() => BlockchainIncludeSchema).optional(),
}).strict();

export const BlockchainCountOutputTypeArgsSchema: z.ZodType<Prisma.BlockchainCountOutputTypeDefaultArgs> = z.object({
  select: z.lazy(() => BlockchainCountOutputTypeSelectSchema).nullish(),
}).strict();

export const BlockchainCountOutputTypeSelectSchema: z.ZodType<Prisma.BlockchainCountOutputTypeSelect> = z.object({
  transactions: z.boolean().optional(),
  TokensOnBlockchains: z.boolean().optional(),
  Sale: z.boolean().optional(),
}).strict();

export const BlockchainSelectSchema: z.ZodType<Prisma.BlockchainSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  updatedAt: z.boolean().optional(),
  deletedAt: z.boolean().optional(),
  name: z.boolean().optional(),
  chainId: z.boolean().optional(),
  rpcUrl: z.boolean().optional(),
  explorerUrl: z.boolean().optional(),
  isTestnet: z.boolean().optional(),
  isEnabled: z.boolean().optional(),
  transactions: z.union([z.boolean(),z.lazy(() => SaleTransactionsFindManyArgsSchema)]).optional(),
  TokensOnBlockchains: z.union([z.boolean(),z.lazy(() => TokensOnBlockchainsFindManyArgsSchema)]).optional(),
  Sale: z.union([z.boolean(),z.lazy(() => SaleFindManyArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => BlockchainCountOutputTypeArgsSchema)]).optional(),
}).strict()

// CONTRACT STATUS
//------------------------------------------------------

export const ContractStatusSelectSchema: z.ZodType<Prisma.ContractStatusSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  updatedAt: z.boolean().optional(),
  deletedAt: z.boolean().optional(),
  userId: z.boolean().optional(),
  saleId: z.boolean().optional(),
  contractId: z.boolean().optional(),
  status: z.boolean().optional(),
}).strict()

// TRANSACTION AUDIT
//------------------------------------------------------

export const TransactionAuditIncludeSchema: z.ZodType<Prisma.TransactionAuditInclude> = z.object({
  transaction: z.union([z.boolean(),z.lazy(() => SaleTransactionsArgsSchema)]).optional(),
  admin: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
}).strict()

export const TransactionAuditArgsSchema: z.ZodType<Prisma.TransactionAuditDefaultArgs> = z.object({
  select: z.lazy(() => TransactionAuditSelectSchema).optional(),
  include: z.lazy(() => TransactionAuditIncludeSchema).optional(),
}).strict();

export const TransactionAuditSelectSchema: z.ZodType<Prisma.TransactionAuditSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  updatedAt: z.boolean().optional(),
  deletedAt: z.boolean().optional(),
  transactionId: z.boolean().optional(),
  actionType: z.boolean().optional(),
  fromStatus: z.boolean().optional(),
  toStatus: z.boolean().optional(),
  performedBy: z.boolean().optional(),
  comment: z.boolean().optional(),
  transaction: z.union([z.boolean(),z.lazy(() => SaleTransactionsArgsSchema)]).optional(),
  admin: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
}).strict()

// KYC VERIFICATION
//------------------------------------------------------

export const KycVerificationIncludeSchema: z.ZodType<Prisma.KycVerificationInclude> = z.object({
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
}).strict()

export const KycVerificationArgsSchema: z.ZodType<Prisma.KycVerificationDefaultArgs> = z.object({
  select: z.lazy(() => KycVerificationSelectSchema).optional(),
  include: z.lazy(() => KycVerificationIncludeSchema).optional(),
}).strict();

export const KycVerificationSelectSchema: z.ZodType<Prisma.KycVerificationSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  updatedAt: z.boolean().optional(),
  deletedAt: z.boolean().optional(),
  userId: z.boolean().optional(),
  status: z.boolean().optional(),
  documentType: z.boolean().optional(),
  documentNumber: z.boolean().optional(),
  verifiedAt: z.boolean().optional(),
  rejectionReason: z.boolean().optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
}).strict()

// ROLE
//------------------------------------------------------

export const RoleIncludeSchema: z.ZodType<Prisma.RoleInclude> = z.object({
  users: z.union([z.boolean(),z.lazy(() => UserRoleFindManyArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => RoleCountOutputTypeArgsSchema)]).optional(),
}).strict()

export const RoleArgsSchema: z.ZodType<Prisma.RoleDefaultArgs> = z.object({
  select: z.lazy(() => RoleSelectSchema).optional(),
  include: z.lazy(() => RoleIncludeSchema).optional(),
}).strict();

export const RoleCountOutputTypeArgsSchema: z.ZodType<Prisma.RoleCountOutputTypeDefaultArgs> = z.object({
  select: z.lazy(() => RoleCountOutputTypeSelectSchema).nullish(),
}).strict();

export const RoleCountOutputTypeSelectSchema: z.ZodType<Prisma.RoleCountOutputTypeSelect> = z.object({
  users: z.boolean().optional(),
}).strict();

export const RoleSelectSchema: z.ZodType<Prisma.RoleSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  updatedAt: z.boolean().optional(),
  deletedAt: z.boolean().optional(),
  name: z.boolean().optional(),
  description: z.boolean().optional(),
  users: z.union([z.boolean(),z.lazy(() => UserRoleFindManyArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => RoleCountOutputTypeArgsSchema)]).optional(),
}).strict()

// USER ROLE
//------------------------------------------------------

export const UserRoleIncludeSchema: z.ZodType<Prisma.UserRoleInclude> = z.object({
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  role: z.union([z.boolean(),z.lazy(() => RoleArgsSchema)]).optional(),
}).strict()

export const UserRoleArgsSchema: z.ZodType<Prisma.UserRoleDefaultArgs> = z.object({
  select: z.lazy(() => UserRoleSelectSchema).optional(),
  include: z.lazy(() => UserRoleIncludeSchema).optional(),
}).strict();

export const UserRoleSelectSchema: z.ZodType<Prisma.UserRoleSelect> = z.object({
  createdAt: z.boolean().optional(),
  updatedAt: z.boolean().optional(),
  deletedAt: z.boolean().optional(),
  userId: z.boolean().optional(),
  roleId: z.boolean().optional(),
  user: z.union([z.boolean(),z.lazy(() => UserArgsSchema)]).optional(),
  role: z.union([z.boolean(),z.lazy(() => RoleArgsSchema)]).optional(),
}).strict()

// TOKEN
//------------------------------------------------------

export const TokenIncludeSchema: z.ZodType<Prisma.TokenInclude> = z.object({
  sales: z.union([z.boolean(),z.lazy(() => SaleFindManyArgsSchema)]).optional(),
  TokensOnBlockchains: z.union([z.boolean(),z.lazy(() => TokensOnBlockchainsFindManyArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => TokenCountOutputTypeArgsSchema)]).optional(),
}).strict()

export const TokenArgsSchema: z.ZodType<Prisma.TokenDefaultArgs> = z.object({
  select: z.lazy(() => TokenSelectSchema).optional(),
  include: z.lazy(() => TokenIncludeSchema).optional(),
}).strict();

export const TokenCountOutputTypeArgsSchema: z.ZodType<Prisma.TokenCountOutputTypeDefaultArgs> = z.object({
  select: z.lazy(() => TokenCountOutputTypeSelectSchema).nullish(),
}).strict();

export const TokenCountOutputTypeSelectSchema: z.ZodType<Prisma.TokenCountOutputTypeSelect> = z.object({
  sales: z.boolean().optional(),
  TokensOnBlockchains: z.boolean().optional(),
}).strict();

export const TokenSelectSchema: z.ZodType<Prisma.TokenSelect> = z.object({
  id: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  updatedAt: z.boolean().optional(),
  deletedAt: z.boolean().optional(),
  symbol: z.boolean().optional(),
  totalSupply: z.boolean().optional(),
  image: z.boolean().optional(),
  sales: z.union([z.boolean(),z.lazy(() => SaleFindManyArgsSchema)]).optional(),
  TokensOnBlockchains: z.union([z.boolean(),z.lazy(() => TokensOnBlockchainsFindManyArgsSchema)]).optional(),
  _count: z.union([z.boolean(),z.lazy(() => TokenCountOutputTypeArgsSchema)]).optional(),
}).strict()

// TOKENS ON BLOCKCHAINS
//------------------------------------------------------

export const TokensOnBlockchainsIncludeSchema: z.ZodType<Prisma.TokensOnBlockchainsInclude> = z.object({
  token: z.union([z.boolean(),z.lazy(() => TokenArgsSchema)]).optional(),
  blockchain: z.union([z.boolean(),z.lazy(() => BlockchainArgsSchema)]).optional(),
}).strict()

export const TokensOnBlockchainsArgsSchema: z.ZodType<Prisma.TokensOnBlockchainsDefaultArgs> = z.object({
  select: z.lazy(() => TokensOnBlockchainsSelectSchema).optional(),
  include: z.lazy(() => TokensOnBlockchainsIncludeSchema).optional(),
}).strict();

export const TokensOnBlockchainsSelectSchema: z.ZodType<Prisma.TokensOnBlockchainsSelect> = z.object({
  id: z.boolean().optional(),
  tokenId: z.boolean().optional(),
  tokenSymbol: z.boolean().optional(),
  blockchainId: z.boolean().optional(),
  name: z.boolean().optional(),
  isNative: z.boolean().optional(),
  decimals: z.boolean().optional(),
  contractAddress: z.boolean().optional(),
  token: z.union([z.boolean(),z.lazy(() => TokenArgsSchema)]).optional(),
  blockchain: z.union([z.boolean(),z.lazy(() => BlockchainArgsSchema)]).optional(),
}).strict()


/////////////////////////////////////////
// INPUT TYPES
/////////////////////////////////////////

export const UserWhereInputSchema: z.ZodType<Prisma.UserWhereInput> = z.object({
  AND: z.union([ z.lazy(() => UserWhereInputSchema),z.lazy(() => UserWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => UserWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => UserWhereInputSchema),z.lazy(() => UserWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  externalId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  walletAddress: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  email: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  emailVerified: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  image: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  isSiwe: z.union([ z.lazy(() => BoolNullableFilterSchema),z.boolean() ]).optional().nullable(),
  profile: z.union([ z.lazy(() => ProfileNullableScalarRelationFilterSchema),z.lazy(() => ProfileWhereInputSchema) ]).optional().nullable(),
  sales: z.lazy(() => SaleListRelationFilterSchema).optional(),
  userRole: z.lazy(() => UserRoleListRelationFilterSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditListRelationFilterSchema).optional(),
  kycVerification: z.union([ z.lazy(() => KycVerificationNullableScalarRelationFilterSchema),z.lazy(() => KycVerificationWhereInputSchema) ]).optional().nullable(),
  sessions: z.lazy(() => SessionListRelationFilterSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsListRelationFilterSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsListRelationFilterSchema).optional(),
  Document: z.lazy(() => DocumentListRelationFilterSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressListRelationFilterSchema).optional()
}).strict();

export const UserOrderByWithRelationInputSchema: z.ZodType<Prisma.UserOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  externalId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  walletAddress: z.lazy(() => SortOrderSchema).optional(),
  email: z.lazy(() => SortOrderSchema).optional(),
  emailVerified: z.lazy(() => SortOrderSchema).optional(),
  image: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  isSiwe: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  profile: z.lazy(() => ProfileOrderByWithRelationInputSchema).optional(),
  sales: z.lazy(() => SaleOrderByRelationAggregateInputSchema).optional(),
  userRole: z.lazy(() => UserRoleOrderByRelationAggregateInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditOrderByRelationAggregateInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationOrderByWithRelationInputSchema).optional(),
  sessions: z.lazy(() => SessionOrderByRelationAggregateInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsOrderByRelationAggregateInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsOrderByRelationAggregateInputSchema).optional(),
  Document: z.lazy(() => DocumentOrderByRelationAggregateInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressOrderByRelationAggregateInputSchema).optional()
}).strict();

export const UserWhereUniqueInputSchema: z.ZodType<Prisma.UserWhereUniqueInput> = z.union([
  z.object({
    id: z.string().cuid(),
    walletAddress: z.string()
  }),
  z.object({
    id: z.string().cuid(),
  }),
  z.object({
    walletAddress: z.string(),
  }),
])
.and(z.object({
  id: z.string().cuid().optional(),
  walletAddress: z.string().optional(),
  AND: z.union([ z.lazy(() => UserWhereInputSchema),z.lazy(() => UserWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => UserWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => UserWhereInputSchema),z.lazy(() => UserWhereInputSchema).array() ]).optional(),
  externalId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  email: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  emailVerified: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  image: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  isSiwe: z.union([ z.lazy(() => BoolNullableFilterSchema),z.boolean() ]).optional().nullable(),
  profile: z.union([ z.lazy(() => ProfileNullableScalarRelationFilterSchema),z.lazy(() => ProfileWhereInputSchema) ]).optional().nullable(),
  sales: z.lazy(() => SaleListRelationFilterSchema).optional(),
  userRole: z.lazy(() => UserRoleListRelationFilterSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditListRelationFilterSchema).optional(),
  kycVerification: z.union([ z.lazy(() => KycVerificationNullableScalarRelationFilterSchema),z.lazy(() => KycVerificationWhereInputSchema) ]).optional().nullable(),
  sessions: z.lazy(() => SessionListRelationFilterSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsListRelationFilterSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsListRelationFilterSchema).optional(),
  Document: z.lazy(() => DocumentListRelationFilterSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressListRelationFilterSchema).optional()
}).strict());

export const UserOrderByWithAggregationInputSchema: z.ZodType<Prisma.UserOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  externalId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  walletAddress: z.lazy(() => SortOrderSchema).optional(),
  email: z.lazy(() => SortOrderSchema).optional(),
  emailVerified: z.lazy(() => SortOrderSchema).optional(),
  image: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  isSiwe: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  _count: z.lazy(() => UserCountOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => UserMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => UserMinOrderByAggregateInputSchema).optional()
}).strict();

export const UserScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.UserScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => UserScalarWhereWithAggregatesInputSchema),z.lazy(() => UserScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => UserScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => UserScalarWhereWithAggregatesInputSchema),z.lazy(() => UserScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  externalId: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
  name: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  walletAddress: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  email: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  emailVerified: z.union([ z.lazy(() => BoolWithAggregatesFilterSchema),z.boolean() ]).optional(),
  image: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  isSiwe: z.union([ z.lazy(() => BoolNullableWithAggregatesFilterSchema),z.boolean() ]).optional().nullable(),
}).strict();

export const WalletAddressWhereInputSchema: z.ZodType<Prisma.WalletAddressWhereInput> = z.object({
  AND: z.union([ z.lazy(() => WalletAddressWhereInputSchema),z.lazy(() => WalletAddressWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => WalletAddressWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => WalletAddressWhereInputSchema),z.lazy(() => WalletAddressWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  walletAddress: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  chainId: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  address: z.union([ z.lazy(() => UserScalarRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
}).strict();

export const WalletAddressOrderByWithRelationInputSchema: z.ZodType<Prisma.WalletAddressOrderByWithRelationInput> = z.object({
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  walletAddress: z.lazy(() => SortOrderSchema).optional(),
  chainId: z.lazy(() => SortOrderSchema).optional(),
  address: z.lazy(() => UserOrderByWithRelationInputSchema).optional()
}).strict();

export const WalletAddressWhereUniqueInputSchema: z.ZodType<Prisma.WalletAddressWhereUniqueInput> = z.object({
  walletAddress_chainId: z.lazy(() => WalletAddressWalletAddressChainIdCompoundUniqueInputSchema)
})
.and(z.object({
  walletAddress_chainId: z.lazy(() => WalletAddressWalletAddressChainIdCompoundUniqueInputSchema).optional(),
  AND: z.union([ z.lazy(() => WalletAddressWhereInputSchema),z.lazy(() => WalletAddressWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => WalletAddressWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => WalletAddressWhereInputSchema),z.lazy(() => WalletAddressWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  walletAddress: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  chainId: z.union([ z.lazy(() => IntFilterSchema),z.number().int() ]).optional(),
  address: z.union([ z.lazy(() => UserScalarRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
}).strict());

export const WalletAddressOrderByWithAggregationInputSchema: z.ZodType<Prisma.WalletAddressOrderByWithAggregationInput> = z.object({
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  walletAddress: z.lazy(() => SortOrderSchema).optional(),
  chainId: z.lazy(() => SortOrderSchema).optional(),
  _count: z.lazy(() => WalletAddressCountOrderByAggregateInputSchema).optional(),
  _avg: z.lazy(() => WalletAddressAvgOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => WalletAddressMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => WalletAddressMinOrderByAggregateInputSchema).optional(),
  _sum: z.lazy(() => WalletAddressSumOrderByAggregateInputSchema).optional()
}).strict();

export const WalletAddressScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.WalletAddressScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => WalletAddressScalarWhereWithAggregatesInputSchema),z.lazy(() => WalletAddressScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => WalletAddressScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => WalletAddressScalarWhereWithAggregatesInputSchema),z.lazy(() => WalletAddressScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
  walletAddress: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  chainId: z.union([ z.lazy(() => IntWithAggregatesFilterSchema),z.number() ]).optional(),
}).strict();

export const SessionWhereInputSchema: z.ZodType<Prisma.SessionWhereInput> = z.object({
  AND: z.union([ z.lazy(() => SessionWhereInputSchema),z.lazy(() => SessionWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => SessionWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => SessionWhereInputSchema),z.lazy(() => SessionWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  expiresAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  token: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  ipAddress: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  userAgent: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  user: z.union([ z.lazy(() => UserScalarRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
}).strict();

export const SessionOrderByWithRelationInputSchema: z.ZodType<Prisma.SessionOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  expiresAt: z.lazy(() => SortOrderSchema).optional(),
  token: z.lazy(() => SortOrderSchema).optional(),
  ipAddress: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  userAgent: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  user: z.lazy(() => UserOrderByWithRelationInputSchema).optional()
}).strict();

export const SessionWhereUniqueInputSchema: z.ZodType<Prisma.SessionWhereUniqueInput> = z.union([
  z.object({
    id: z.string().cuid(),
    token: z.string(),
    token_userId: z.lazy(() => SessionTokenUserIdCompoundUniqueInputSchema)
  }),
  z.object({
    id: z.string().cuid(),
    token: z.string(),
  }),
  z.object({
    id: z.string().cuid(),
    token_userId: z.lazy(() => SessionTokenUserIdCompoundUniqueInputSchema),
  }),
  z.object({
    id: z.string().cuid(),
  }),
  z.object({
    token: z.string(),
    token_userId: z.lazy(() => SessionTokenUserIdCompoundUniqueInputSchema),
  }),
  z.object({
    token: z.string(),
  }),
  z.object({
    token_userId: z.lazy(() => SessionTokenUserIdCompoundUniqueInputSchema),
  }),
])
.and(z.object({
  id: z.string().cuid().optional(),
  token: z.string().optional(),
  token_userId: z.lazy(() => SessionTokenUserIdCompoundUniqueInputSchema).optional(),
  AND: z.union([ z.lazy(() => SessionWhereInputSchema),z.lazy(() => SessionWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => SessionWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => SessionWhereInputSchema),z.lazy(() => SessionWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  expiresAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  ipAddress: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  userAgent: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  user: z.union([ z.lazy(() => UserScalarRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
}).strict());

export const SessionOrderByWithAggregationInputSchema: z.ZodType<Prisma.SessionOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  expiresAt: z.lazy(() => SortOrderSchema).optional(),
  token: z.lazy(() => SortOrderSchema).optional(),
  ipAddress: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  userAgent: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  _count: z.lazy(() => SessionCountOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => SessionMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => SessionMinOrderByAggregateInputSchema).optional()
}).strict();

export const SessionScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.SessionScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => SessionScalarWhereWithAggregatesInputSchema),z.lazy(() => SessionScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => SessionScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => SessionScalarWhereWithAggregatesInputSchema),z.lazy(() => SessionScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  expiresAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  token: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  ipAddress: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  userAgent: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
}).strict();

export const VerificationWhereInputSchema: z.ZodType<Prisma.VerificationWhereInput> = z.object({
  AND: z.union([ z.lazy(() => VerificationWhereInputSchema),z.lazy(() => VerificationWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => VerificationWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => VerificationWhereInputSchema),z.lazy(() => VerificationWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  expiresAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  identifier: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  value: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
}).strict();

export const VerificationOrderByWithRelationInputSchema: z.ZodType<Prisma.VerificationOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  expiresAt: z.lazy(() => SortOrderSchema).optional(),
  identifier: z.lazy(() => SortOrderSchema).optional(),
  value: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const VerificationWhereUniqueInputSchema: z.ZodType<Prisma.VerificationWhereUniqueInput> = z.object({
  id: z.string().cuid()
})
.and(z.object({
  id: z.string().cuid().optional(),
  AND: z.union([ z.lazy(() => VerificationWhereInputSchema),z.lazy(() => VerificationWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => VerificationWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => VerificationWhereInputSchema),z.lazy(() => VerificationWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  expiresAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  identifier: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  value: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
}).strict());

export const VerificationOrderByWithAggregationInputSchema: z.ZodType<Prisma.VerificationOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  expiresAt: z.lazy(() => SortOrderSchema).optional(),
  identifier: z.lazy(() => SortOrderSchema).optional(),
  value: z.lazy(() => SortOrderSchema).optional(),
  _count: z.lazy(() => VerificationCountOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => VerificationMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => VerificationMinOrderByAggregateInputSchema).optional()
}).strict();

export const VerificationScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.VerificationScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => VerificationScalarWhereWithAggregatesInputSchema),z.lazy(() => VerificationScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => VerificationScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => VerificationScalarWhereWithAggregatesInputSchema),z.lazy(() => VerificationScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  expiresAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  identifier: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  value: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
}).strict();

export const ProfileWhereInputSchema: z.ZodType<Prisma.ProfileWhereInput> = z.object({
  AND: z.union([ z.lazy(() => ProfileWhereInputSchema),z.lazy(() => ProfileWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => ProfileWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => ProfileWhereInputSchema),z.lazy(() => ProfileWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  firstName: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  lastName: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  email: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  phoneNumber: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  dateOfBirth: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  user: z.union([ z.lazy(() => UserScalarRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  address: z.union([ z.lazy(() => AddressNullableScalarRelationFilterSchema),z.lazy(() => AddressWhereInputSchema) ]).optional().nullable(),
}).strict();

export const ProfileOrderByWithRelationInputSchema: z.ZodType<Prisma.ProfileOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  firstName: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  lastName: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  email: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  phoneNumber: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  dateOfBirth: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
  address: z.lazy(() => AddressOrderByWithRelationInputSchema).optional()
}).strict();

export const ProfileWhereUniqueInputSchema: z.ZodType<Prisma.ProfileWhereUniqueInput> = z.union([
  z.object({
    id: z.string().cuid(),
    userId: z.string()
  }),
  z.object({
    id: z.string().cuid(),
  }),
  z.object({
    userId: z.string(),
  }),
])
.and(z.object({
  id: z.string().cuid().optional(),
  userId: z.string().optional(),
  AND: z.union([ z.lazy(() => ProfileWhereInputSchema),z.lazy(() => ProfileWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => ProfileWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => ProfileWhereInputSchema),z.lazy(() => ProfileWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  firstName: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  lastName: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  email: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  phoneNumber: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  dateOfBirth: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  user: z.union([ z.lazy(() => UserScalarRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  address: z.union([ z.lazy(() => AddressNullableScalarRelationFilterSchema),z.lazy(() => AddressWhereInputSchema) ]).optional().nullable(),
}).strict());

export const ProfileOrderByWithAggregationInputSchema: z.ZodType<Prisma.ProfileOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  firstName: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  lastName: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  email: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  phoneNumber: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  dateOfBirth: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  _count: z.lazy(() => ProfileCountOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => ProfileMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => ProfileMinOrderByAggregateInputSchema).optional()
}).strict();

export const ProfileScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.ProfileScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => ProfileScalarWhereWithAggregatesInputSchema),z.lazy(() => ProfileScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => ProfileScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => ProfileScalarWhereWithAggregatesInputSchema),z.lazy(() => ProfileScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
  firstName: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  lastName: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  email: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  phoneNumber: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  dateOfBirth: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
}).strict();

export const AddressWhereInputSchema: z.ZodType<Prisma.AddressWhereInput> = z.object({
  AND: z.union([ z.lazy(() => AddressWhereInputSchema),z.lazy(() => AddressWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => AddressWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => AddressWhereInputSchema),z.lazy(() => AddressWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  city: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  zipCode: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  country: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  state: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  street: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  formattedAddress: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  latitude: z.union([ z.lazy(() => FloatNullableFilterSchema),z.number() ]).optional().nullable(),
  longitude: z.union([ z.lazy(() => FloatNullableFilterSchema),z.number() ]).optional().nullable(),
  profile: z.union([ z.lazy(() => ProfileNullableScalarRelationFilterSchema),z.lazy(() => ProfileWhereInputSchema) ]).optional().nullable(),
}).strict();

export const AddressOrderByWithRelationInputSchema: z.ZodType<Prisma.AddressOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  city: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  zipCode: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  country: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  state: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  street: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  formattedAddress: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  latitude: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  longitude: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  profile: z.lazy(() => ProfileOrderByWithRelationInputSchema).optional()
}).strict();

export const AddressWhereUniqueInputSchema: z.ZodType<Prisma.AddressWhereUniqueInput> = z.union([
  z.object({
    id: z.string().cuid(),
    userId: z.string()
  }),
  z.object({
    id: z.string().cuid(),
  }),
  z.object({
    userId: z.string(),
  }),
])
.and(z.object({
  id: z.string().cuid().optional(),
  userId: z.string().optional(),
  AND: z.union([ z.lazy(() => AddressWhereInputSchema),z.lazy(() => AddressWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => AddressWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => AddressWhereInputSchema),z.lazy(() => AddressWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  city: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  zipCode: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  country: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  state: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  street: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  formattedAddress: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  latitude: z.union([ z.lazy(() => FloatNullableFilterSchema),z.number() ]).optional().nullable(),
  longitude: z.union([ z.lazy(() => FloatNullableFilterSchema),z.number() ]).optional().nullable(),
  profile: z.union([ z.lazy(() => ProfileNullableScalarRelationFilterSchema),z.lazy(() => ProfileWhereInputSchema) ]).optional().nullable(),
}).strict());

export const AddressOrderByWithAggregationInputSchema: z.ZodType<Prisma.AddressOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  city: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  zipCode: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  country: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  state: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  street: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  formattedAddress: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  latitude: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  longitude: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  _count: z.lazy(() => AddressCountOrderByAggregateInputSchema).optional(),
  _avg: z.lazy(() => AddressAvgOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => AddressMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => AddressMinOrderByAggregateInputSchema).optional(),
  _sum: z.lazy(() => AddressSumOrderByAggregateInputSchema).optional()
}).strict();

export const AddressScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.AddressScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => AddressScalarWhereWithAggregatesInputSchema),z.lazy(() => AddressScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => AddressScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => AddressScalarWhereWithAggregatesInputSchema),z.lazy(() => AddressScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  city: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  zipCode: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  country: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  state: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  street: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  formattedAddress: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  latitude: z.union([ z.lazy(() => FloatNullableWithAggregatesFilterSchema),z.number() ]).optional().nullable(),
  longitude: z.union([ z.lazy(() => FloatNullableWithAggregatesFilterSchema),z.number() ]).optional().nullable(),
}).strict();

export const SaleWhereInputSchema: z.ZodType<Prisma.SaleWhereInput> = z.object({
  AND: z.union([ z.lazy(() => SaleWhereInputSchema),z.lazy(() => SaleWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => SaleWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => SaleWhereInputSchema),z.lazy(() => SaleWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  status: z.union([ z.lazy(() => EnumSaleStatusFilterSchema),z.lazy(() => SaleStatusSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => EnumCurrencyFilterSchema),z.lazy(() => CurrencySchema) ]).optional(),
  initialTokenQuantity: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  availableTokenQuantity: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.lazy(() => IntNullableFilterSchema),z.number() ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  saleStartDate: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  tokenContractAddress: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  tokenContractChainId: z.union([ z.lazy(() => IntNullableFilterSchema),z.number() ]).optional().nullable(),
  tokenName: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  tokenTotalSupply: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.lazy(() => DecimalFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional(),
  tokenSymbol: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  toWalletsAddress: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  saleClosingDate: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  createdBy: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  saftCheckbox: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  saftContract: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  tokenId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  blockchain: z.union([ z.lazy(() => BlockchainNullableScalarRelationFilterSchema),z.lazy(() => BlockchainWhereInputSchema) ]).optional().nullable(),
  user: z.union([ z.lazy(() => UserScalarRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  transactions: z.lazy(() => SaleTransactionsListRelationFilterSchema).optional(),
  saleInformation: z.union([ z.lazy(() => SaleInformationNullableScalarRelationFilterSchema),z.lazy(() => SaleInformationWhereInputSchema) ]).optional().nullable(),
  documents: z.lazy(() => DocumentListRelationFilterSchema).optional(),
  token: z.union([ z.lazy(() => TokenScalarRelationFilterSchema),z.lazy(() => TokenWhereInputSchema) ]).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleListRelationFilterSchema).optional()
}).strict();

export const SaleOrderByWithRelationInputSchema: z.ZodType<Prisma.SaleOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  status: z.lazy(() => SortOrderSchema).optional(),
  saleCurrency: z.lazy(() => SortOrderSchema).optional(),
  initialTokenQuantity: z.lazy(() => SortOrderSchema).optional(),
  availableTokenQuantity: z.lazy(() => SortOrderSchema).optional(),
  maximumTokenBuyPerUser: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  minimumTokenBuyPerUser: z.lazy(() => SortOrderSchema).optional(),
  saleStartDate: z.lazy(() => SortOrderSchema).optional(),
  tokenContractAddress: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  tokenContractChainId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  tokenName: z.lazy(() => SortOrderSchema).optional(),
  tokenTotalSupply: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  tokenPricePerUnit: z.lazy(() => SortOrderSchema).optional(),
  tokenSymbol: z.lazy(() => SortOrderSchema).optional(),
  toWalletsAddress: z.lazy(() => SortOrderSchema).optional(),
  saleClosingDate: z.lazy(() => SortOrderSchema).optional(),
  createdBy: z.lazy(() => SortOrderSchema).optional(),
  saftCheckbox: z.lazy(() => SortOrderSchema).optional(),
  saftContract: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  tokenId: z.lazy(() => SortOrderSchema).optional(),
  blockchain: z.lazy(() => BlockchainOrderByWithRelationInputSchema).optional(),
  user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsOrderByRelationAggregateInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationOrderByWithRelationInputSchema).optional(),
  documents: z.lazy(() => DocumentOrderByRelationAggregateInputSchema).optional(),
  token: z.lazy(() => TokenOrderByWithRelationInputSchema).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleOrderByRelationAggregateInputSchema).optional()
}).strict();

export const SaleWhereUniqueInputSchema: z.ZodType<Prisma.SaleWhereUniqueInput> = z.object({
  id: z.string().cuid()
})
.and(z.object({
  id: z.string().cuid().optional(),
  AND: z.union([ z.lazy(() => SaleWhereInputSchema),z.lazy(() => SaleWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => SaleWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => SaleWhereInputSchema),z.lazy(() => SaleWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  status: z.union([ z.lazy(() => EnumSaleStatusFilterSchema),z.lazy(() => SaleStatusSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => EnumCurrencyFilterSchema),z.lazy(() => CurrencySchema) ]).optional(),
  initialTokenQuantity: z.union([ z.lazy(() => IntFilterSchema),z.number().int() ]).optional(),
  availableTokenQuantity: z.union([ z.lazy(() => IntFilterSchema),z.number().int() ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.lazy(() => IntNullableFilterSchema),z.number().int() ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.lazy(() => IntFilterSchema),z.number().int() ]).optional(),
  saleStartDate: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  tokenContractAddress: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  tokenContractChainId: z.union([ z.lazy(() => IntNullableFilterSchema),z.number().int() ]).optional().nullable(),
  tokenName: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  tokenTotalSupply: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.lazy(() => DecimalFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional(),
  tokenSymbol: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  toWalletsAddress: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  saleClosingDate: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  createdBy: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  saftCheckbox: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  saftContract: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  tokenId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  blockchain: z.union([ z.lazy(() => BlockchainNullableScalarRelationFilterSchema),z.lazy(() => BlockchainWhereInputSchema) ]).optional().nullable(),
  user: z.union([ z.lazy(() => UserScalarRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  transactions: z.lazy(() => SaleTransactionsListRelationFilterSchema).optional(),
  saleInformation: z.union([ z.lazy(() => SaleInformationNullableScalarRelationFilterSchema),z.lazy(() => SaleInformationWhereInputSchema) ]).optional().nullable(),
  documents: z.lazy(() => DocumentListRelationFilterSchema).optional(),
  token: z.union([ z.lazy(() => TokenScalarRelationFilterSchema),z.lazy(() => TokenWhereInputSchema) ]).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleListRelationFilterSchema).optional()
}).strict());

export const SaleOrderByWithAggregationInputSchema: z.ZodType<Prisma.SaleOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  status: z.lazy(() => SortOrderSchema).optional(),
  saleCurrency: z.lazy(() => SortOrderSchema).optional(),
  initialTokenQuantity: z.lazy(() => SortOrderSchema).optional(),
  availableTokenQuantity: z.lazy(() => SortOrderSchema).optional(),
  maximumTokenBuyPerUser: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  minimumTokenBuyPerUser: z.lazy(() => SortOrderSchema).optional(),
  saleStartDate: z.lazy(() => SortOrderSchema).optional(),
  tokenContractAddress: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  tokenContractChainId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  tokenName: z.lazy(() => SortOrderSchema).optional(),
  tokenTotalSupply: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  tokenPricePerUnit: z.lazy(() => SortOrderSchema).optional(),
  tokenSymbol: z.lazy(() => SortOrderSchema).optional(),
  toWalletsAddress: z.lazy(() => SortOrderSchema).optional(),
  saleClosingDate: z.lazy(() => SortOrderSchema).optional(),
  createdBy: z.lazy(() => SortOrderSchema).optional(),
  saftCheckbox: z.lazy(() => SortOrderSchema).optional(),
  saftContract: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  tokenId: z.lazy(() => SortOrderSchema).optional(),
  _count: z.lazy(() => SaleCountOrderByAggregateInputSchema).optional(),
  _avg: z.lazy(() => SaleAvgOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => SaleMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => SaleMinOrderByAggregateInputSchema).optional(),
  _sum: z.lazy(() => SaleSumOrderByAggregateInputSchema).optional()
}).strict();

export const SaleScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.SaleScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => SaleScalarWhereWithAggregatesInputSchema),z.lazy(() => SaleScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => SaleScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => SaleScalarWhereWithAggregatesInputSchema),z.lazy(() => SaleScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
  name: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  status: z.union([ z.lazy(() => EnumSaleStatusWithAggregatesFilterSchema),z.lazy(() => SaleStatusSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => EnumCurrencyWithAggregatesFilterSchema),z.lazy(() => CurrencySchema) ]).optional(),
  initialTokenQuantity: z.union([ z.lazy(() => IntWithAggregatesFilterSchema),z.number() ]).optional(),
  availableTokenQuantity: z.union([ z.lazy(() => IntWithAggregatesFilterSchema),z.number() ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.lazy(() => IntNullableWithAggregatesFilterSchema),z.number() ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.lazy(() => IntWithAggregatesFilterSchema),z.number() ]).optional(),
  saleStartDate: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  tokenContractAddress: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  tokenContractChainId: z.union([ z.lazy(() => IntNullableWithAggregatesFilterSchema),z.number() ]).optional().nullable(),
  tokenName: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  tokenTotalSupply: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.lazy(() => DecimalWithAggregatesFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional(),
  tokenSymbol: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  toWalletsAddress: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  saleClosingDate: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  createdBy: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  saftCheckbox: z.union([ z.lazy(() => BoolWithAggregatesFilterSchema),z.boolean() ]).optional(),
  saftContract: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  tokenId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
}).strict();

export const DocumentWhereInputSchema: z.ZodType<Prisma.DocumentWhereInput> = z.object({
  AND: z.union([ z.lazy(() => DocumentWhereInputSchema),z.lazy(() => DocumentWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => DocumentWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => DocumentWhereInputSchema),z.lazy(() => DocumentWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  fileName: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  url: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  type: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  saleId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  sale: z.union([ z.lazy(() => SaleNullableScalarRelationFilterSchema),z.lazy(() => SaleWhereInputSchema) ]).optional().nullable(),
  user: z.union([ z.lazy(() => UserNullableScalarRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional().nullable(),
}).strict();

export const DocumentOrderByWithRelationInputSchema: z.ZodType<Prisma.DocumentOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  fileName: z.lazy(() => SortOrderSchema).optional(),
  url: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  saleId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  userId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  sale: z.lazy(() => SaleOrderByWithRelationInputSchema).optional(),
  user: z.lazy(() => UserOrderByWithRelationInputSchema).optional()
}).strict();

export const DocumentWhereUniqueInputSchema: z.ZodType<Prisma.DocumentWhereUniqueInput> = z.object({
  id: z.string().cuid()
})
.and(z.object({
  id: z.string().cuid().optional(),
  AND: z.union([ z.lazy(() => DocumentWhereInputSchema),z.lazy(() => DocumentWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => DocumentWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => DocumentWhereInputSchema),z.lazy(() => DocumentWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  fileName: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  url: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  type: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  saleId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  sale: z.union([ z.lazy(() => SaleNullableScalarRelationFilterSchema),z.lazy(() => SaleWhereInputSchema) ]).optional().nullable(),
  user: z.union([ z.lazy(() => UserNullableScalarRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional().nullable(),
}).strict());

export const DocumentOrderByWithAggregationInputSchema: z.ZodType<Prisma.DocumentOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  fileName: z.lazy(() => SortOrderSchema).optional(),
  url: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  saleId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  userId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  _count: z.lazy(() => DocumentCountOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => DocumentMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => DocumentMinOrderByAggregateInputSchema).optional()
}).strict();

export const DocumentScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.DocumentScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => DocumentScalarWhereWithAggregatesInputSchema),z.lazy(() => DocumentScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => DocumentScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => DocumentScalarWhereWithAggregatesInputSchema),z.lazy(() => DocumentScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
  name: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  fileName: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  url: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  type: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  saleId: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
}).strict();

export const VestingScheduleWhereInputSchema: z.ZodType<Prisma.VestingScheduleWhereInput> = z.object({
  AND: z.union([ z.lazy(() => VestingScheduleWhereInputSchema),z.lazy(() => VestingScheduleWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => VestingScheduleWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => VestingScheduleWhereInputSchema),z.lazy(() => VestingScheduleWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  saleId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  cliffPeriod: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  vestingPeriod: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  releaseFrequency: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  initialRelease: z.union([ z.lazy(() => FloatFilterSchema),z.number() ]).optional(),
  isEnabled: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  sale: z.union([ z.lazy(() => SaleScalarRelationFilterSchema),z.lazy(() => SaleWhereInputSchema) ]).optional(),
}).strict();

export const VestingScheduleOrderByWithRelationInputSchema: z.ZodType<Prisma.VestingScheduleOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  saleId: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  cliffPeriod: z.lazy(() => SortOrderSchema).optional(),
  vestingPeriod: z.lazy(() => SortOrderSchema).optional(),
  releaseFrequency: z.lazy(() => SortOrderSchema).optional(),
  initialRelease: z.lazy(() => SortOrderSchema).optional(),
  isEnabled: z.lazy(() => SortOrderSchema).optional(),
  sale: z.lazy(() => SaleOrderByWithRelationInputSchema).optional()
}).strict();

export const VestingScheduleWhereUniqueInputSchema: z.ZodType<Prisma.VestingScheduleWhereUniqueInput> = z.object({
  id: z.string().cuid()
})
.and(z.object({
  id: z.string().cuid().optional(),
  AND: z.union([ z.lazy(() => VestingScheduleWhereInputSchema),z.lazy(() => VestingScheduleWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => VestingScheduleWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => VestingScheduleWhereInputSchema),z.lazy(() => VestingScheduleWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  saleId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  cliffPeriod: z.union([ z.lazy(() => IntFilterSchema),z.number().int() ]).optional(),
  vestingPeriod: z.union([ z.lazy(() => IntFilterSchema),z.number().int() ]).optional(),
  releaseFrequency: z.union([ z.lazy(() => IntFilterSchema),z.number().int() ]).optional(),
  initialRelease: z.union([ z.lazy(() => FloatFilterSchema),z.number() ]).optional(),
  isEnabled: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  sale: z.union([ z.lazy(() => SaleScalarRelationFilterSchema),z.lazy(() => SaleWhereInputSchema) ]).optional(),
}).strict());

export const VestingScheduleOrderByWithAggregationInputSchema: z.ZodType<Prisma.VestingScheduleOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  saleId: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  cliffPeriod: z.lazy(() => SortOrderSchema).optional(),
  vestingPeriod: z.lazy(() => SortOrderSchema).optional(),
  releaseFrequency: z.lazy(() => SortOrderSchema).optional(),
  initialRelease: z.lazy(() => SortOrderSchema).optional(),
  isEnabled: z.lazy(() => SortOrderSchema).optional(),
  _count: z.lazy(() => VestingScheduleCountOrderByAggregateInputSchema).optional(),
  _avg: z.lazy(() => VestingScheduleAvgOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => VestingScheduleMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => VestingScheduleMinOrderByAggregateInputSchema).optional(),
  _sum: z.lazy(() => VestingScheduleSumOrderByAggregateInputSchema).optional()
}).strict();

export const VestingScheduleScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.VestingScheduleScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => VestingScheduleScalarWhereWithAggregatesInputSchema),z.lazy(() => VestingScheduleScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => VestingScheduleScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => VestingScheduleScalarWhereWithAggregatesInputSchema),z.lazy(() => VestingScheduleScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
  saleId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  name: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  cliffPeriod: z.union([ z.lazy(() => IntWithAggregatesFilterSchema),z.number() ]).optional(),
  vestingPeriod: z.union([ z.lazy(() => IntWithAggregatesFilterSchema),z.number() ]).optional(),
  releaseFrequency: z.union([ z.lazy(() => IntWithAggregatesFilterSchema),z.number() ]).optional(),
  initialRelease: z.union([ z.lazy(() => FloatWithAggregatesFilterSchema),z.number() ]).optional(),
  isEnabled: z.union([ z.lazy(() => BoolWithAggregatesFilterSchema),z.boolean() ]).optional(),
}).strict();

export const TokenDistributionWhereInputSchema: z.ZodType<Prisma.TokenDistributionWhereInput> = z.object({
  AND: z.union([ z.lazy(() => TokenDistributionWhereInputSchema),z.lazy(() => TokenDistributionWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => TokenDistributionWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TokenDistributionWhereInputSchema),z.lazy(() => TokenDistributionWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  transactionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  amount: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  distributionDate: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  txHash: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  status: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  transaction: z.union([ z.lazy(() => SaleTransactionsScalarRelationFilterSchema),z.lazy(() => SaleTransactionsWhereInputSchema) ]).optional(),
}).strict();

export const TokenDistributionOrderByWithRelationInputSchema: z.ZodType<Prisma.TokenDistributionOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  transactionId: z.lazy(() => SortOrderSchema).optional(),
  amount: z.lazy(() => SortOrderSchema).optional(),
  distributionDate: z.lazy(() => SortOrderSchema).optional(),
  txHash: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  status: z.lazy(() => SortOrderSchema).optional(),
  transaction: z.lazy(() => SaleTransactionsOrderByWithRelationInputSchema).optional()
}).strict();

export const TokenDistributionWhereUniqueInputSchema: z.ZodType<Prisma.TokenDistributionWhereUniqueInput> = z.object({
  id: z.string().cuid()
})
.and(z.object({
  id: z.string().cuid().optional(),
  AND: z.union([ z.lazy(() => TokenDistributionWhereInputSchema),z.lazy(() => TokenDistributionWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => TokenDistributionWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TokenDistributionWhereInputSchema),z.lazy(() => TokenDistributionWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  transactionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  amount: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  distributionDate: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  txHash: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  status: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  transaction: z.union([ z.lazy(() => SaleTransactionsScalarRelationFilterSchema),z.lazy(() => SaleTransactionsWhereInputSchema) ]).optional(),
}).strict());

export const TokenDistributionOrderByWithAggregationInputSchema: z.ZodType<Prisma.TokenDistributionOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  transactionId: z.lazy(() => SortOrderSchema).optional(),
  amount: z.lazy(() => SortOrderSchema).optional(),
  distributionDate: z.lazy(() => SortOrderSchema).optional(),
  txHash: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  status: z.lazy(() => SortOrderSchema).optional(),
  _count: z.lazy(() => TokenDistributionCountOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => TokenDistributionMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => TokenDistributionMinOrderByAggregateInputSchema).optional()
}).strict();

export const TokenDistributionScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.TokenDistributionScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => TokenDistributionScalarWhereWithAggregatesInputSchema),z.lazy(() => TokenDistributionScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => TokenDistributionScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TokenDistributionScalarWhereWithAggregatesInputSchema),z.lazy(() => TokenDistributionScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
  transactionId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  amount: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  distributionDate: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  txHash: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  status: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
}).strict();

export const SaleInformationWhereInputSchema: z.ZodType<Prisma.SaleInformationWhereInput> = z.object({
  AND: z.union([ z.lazy(() => SaleInformationWhereInputSchema),z.lazy(() => SaleInformationWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => SaleInformationWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => SaleInformationWhereInputSchema),z.lazy(() => SaleInformationWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  summary: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  tokenUtility: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  tokenDistribution: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  otherInformation: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  tokenLifecycle: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  liquidityPool: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  futurePlans: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  useOfProceeds: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  imageSale: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  imageToken: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  contactEmail: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  saleId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  sale: z.union([ z.lazy(() => SaleScalarRelationFilterSchema),z.lazy(() => SaleWhereInputSchema) ]).optional(),
}).strict();

export const SaleInformationOrderByWithRelationInputSchema: z.ZodType<Prisma.SaleInformationOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  summary: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  tokenUtility: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  tokenDistribution: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  otherInformation: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  tokenLifecycle: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  liquidityPool: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  futurePlans: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  useOfProceeds: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  imageSale: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  imageToken: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  contactEmail: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  saleId: z.lazy(() => SortOrderSchema).optional(),
  sale: z.lazy(() => SaleOrderByWithRelationInputSchema).optional()
}).strict();

export const SaleInformationWhereUniqueInputSchema: z.ZodType<Prisma.SaleInformationWhereUniqueInput> = z.union([
  z.object({
    id: z.string().cuid(),
    saleId: z.string()
  }),
  z.object({
    id: z.string().cuid(),
  }),
  z.object({
    saleId: z.string(),
  }),
])
.and(z.object({
  id: z.string().cuid().optional(),
  saleId: z.string().optional(),
  AND: z.union([ z.lazy(() => SaleInformationWhereInputSchema),z.lazy(() => SaleInformationWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => SaleInformationWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => SaleInformationWhereInputSchema),z.lazy(() => SaleInformationWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  summary: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  tokenUtility: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  tokenDistribution: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  otherInformation: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  tokenLifecycle: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  liquidityPool: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  futurePlans: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  useOfProceeds: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  imageSale: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  imageToken: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  contactEmail: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  sale: z.union([ z.lazy(() => SaleScalarRelationFilterSchema),z.lazy(() => SaleWhereInputSchema) ]).optional(),
}).strict());

export const SaleInformationOrderByWithAggregationInputSchema: z.ZodType<Prisma.SaleInformationOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  summary: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  tokenUtility: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  tokenDistribution: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  otherInformation: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  tokenLifecycle: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  liquidityPool: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  futurePlans: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  useOfProceeds: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  imageSale: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  imageToken: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  contactEmail: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  saleId: z.lazy(() => SortOrderSchema).optional(),
  _count: z.lazy(() => SaleInformationCountOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => SaleInformationMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => SaleInformationMinOrderByAggregateInputSchema).optional()
}).strict();

export const SaleInformationScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.SaleInformationScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => SaleInformationScalarWhereWithAggregatesInputSchema),z.lazy(() => SaleInformationScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => SaleInformationScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => SaleInformationScalarWhereWithAggregatesInputSchema),z.lazy(() => SaleInformationScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
  summary: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  tokenUtility: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  tokenDistribution: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  otherInformation: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  tokenLifecycle: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  liquidityPool: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  futurePlans: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  useOfProceeds: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  imageSale: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  imageToken: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  contactEmail: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  saleId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
}).strict();

export const SaleTransactionsWhereInputSchema: z.ZodType<Prisma.SaleTransactionsWhereInput> = z.object({
  AND: z.union([ z.lazy(() => SaleTransactionsWhereInputSchema),z.lazy(() => SaleTransactionsWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => SaleTransactionsWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => SaleTransactionsWhereInputSchema),z.lazy(() => SaleTransactionsWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  tokenSymbol: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  quantity: z.union([ z.lazy(() => DecimalFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional(),
  rawPrice: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  price: z.union([ z.lazy(() => DecimalFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional(),
  totalAmount: z.union([ z.lazy(() => DecimalFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional(),
  formOfPayment: z.union([ z.lazy(() => EnumFOPFilterSchema),z.lazy(() => FOPSchema) ]).optional(),
  confirmationId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  receivingWallet: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  status: z.union([ z.lazy(() => EnumTransactionStatusFilterSchema),z.lazy(() => TransactionStatusSchema) ]).optional(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  saleId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  comment: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  amountPaid: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  amountPaidCurrency: z.union([ z.lazy(() => EnumCurrencyFilterSchema),z.lazy(() => CurrencySchema) ]).optional(),
  txHash: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  blockchainId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  agreementId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  approvedBy: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  rejectionReason: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  paymentEvidence: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  paymentDate: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  user: z.union([ z.lazy(() => UserScalarRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  sale: z.union([ z.lazy(() => SaleScalarRelationFilterSchema),z.lazy(() => SaleWhereInputSchema) ]).optional(),
  blockchain: z.union([ z.lazy(() => BlockchainNullableScalarRelationFilterSchema),z.lazy(() => BlockchainWhereInputSchema) ]).optional().nullable(),
  approver: z.union([ z.lazy(() => UserNullableScalarRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional().nullable(),
  auditTrail: z.lazy(() => TransactionAuditListRelationFilterSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionListRelationFilterSchema).optional()
}).strict();

export const SaleTransactionsOrderByWithRelationInputSchema: z.ZodType<Prisma.SaleTransactionsOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  tokenSymbol: z.lazy(() => SortOrderSchema).optional(),
  quantity: z.lazy(() => SortOrderSchema).optional(),
  rawPrice: z.lazy(() => SortOrderSchema).optional(),
  price: z.lazy(() => SortOrderSchema).optional(),
  totalAmount: z.lazy(() => SortOrderSchema).optional(),
  formOfPayment: z.lazy(() => SortOrderSchema).optional(),
  confirmationId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  receivingWallet: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  status: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  saleId: z.lazy(() => SortOrderSchema).optional(),
  comment: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  amountPaid: z.lazy(() => SortOrderSchema).optional(),
  amountPaidCurrency: z.lazy(() => SortOrderSchema).optional(),
  txHash: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  blockchainId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  agreementId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  approvedBy: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  rejectionReason: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  paymentEvidence: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  paymentDate: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
  sale: z.lazy(() => SaleOrderByWithRelationInputSchema).optional(),
  blockchain: z.lazy(() => BlockchainOrderByWithRelationInputSchema).optional(),
  approver: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
  auditTrail: z.lazy(() => TransactionAuditOrderByRelationAggregateInputSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionOrderByRelationAggregateInputSchema).optional()
}).strict();

export const SaleTransactionsWhereUniqueInputSchema: z.ZodType<Prisma.SaleTransactionsWhereUniqueInput> = z.object({
  id: z.string().cuid()
})
.and(z.object({
  id: z.string().cuid().optional(),
  AND: z.union([ z.lazy(() => SaleTransactionsWhereInputSchema),z.lazy(() => SaleTransactionsWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => SaleTransactionsWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => SaleTransactionsWhereInputSchema),z.lazy(() => SaleTransactionsWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  tokenSymbol: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  quantity: z.union([ z.lazy(() => DecimalFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional(),
  rawPrice: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  price: z.union([ z.lazy(() => DecimalFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional(),
  totalAmount: z.union([ z.lazy(() => DecimalFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional(),
  formOfPayment: z.union([ z.lazy(() => EnumFOPFilterSchema),z.lazy(() => FOPSchema) ]).optional(),
  confirmationId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  receivingWallet: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  status: z.union([ z.lazy(() => EnumTransactionStatusFilterSchema),z.lazy(() => TransactionStatusSchema) ]).optional(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  saleId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  comment: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  amountPaid: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  amountPaidCurrency: z.union([ z.lazy(() => EnumCurrencyFilterSchema),z.lazy(() => CurrencySchema) ]).optional(),
  txHash: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  blockchainId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  agreementId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  approvedBy: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  rejectionReason: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  paymentEvidence: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  paymentDate: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  user: z.union([ z.lazy(() => UserScalarRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  sale: z.union([ z.lazy(() => SaleScalarRelationFilterSchema),z.lazy(() => SaleWhereInputSchema) ]).optional(),
  blockchain: z.union([ z.lazy(() => BlockchainNullableScalarRelationFilterSchema),z.lazy(() => BlockchainWhereInputSchema) ]).optional().nullable(),
  approver: z.union([ z.lazy(() => UserNullableScalarRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional().nullable(),
  auditTrail: z.lazy(() => TransactionAuditListRelationFilterSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionListRelationFilterSchema).optional()
}).strict());

export const SaleTransactionsOrderByWithAggregationInputSchema: z.ZodType<Prisma.SaleTransactionsOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  tokenSymbol: z.lazy(() => SortOrderSchema).optional(),
  quantity: z.lazy(() => SortOrderSchema).optional(),
  rawPrice: z.lazy(() => SortOrderSchema).optional(),
  price: z.lazy(() => SortOrderSchema).optional(),
  totalAmount: z.lazy(() => SortOrderSchema).optional(),
  formOfPayment: z.lazy(() => SortOrderSchema).optional(),
  confirmationId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  receivingWallet: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  status: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  saleId: z.lazy(() => SortOrderSchema).optional(),
  comment: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  amountPaid: z.lazy(() => SortOrderSchema).optional(),
  amountPaidCurrency: z.lazy(() => SortOrderSchema).optional(),
  txHash: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  blockchainId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  agreementId: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  approvedBy: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  rejectionReason: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  paymentEvidence: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  paymentDate: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  _count: z.lazy(() => SaleTransactionsCountOrderByAggregateInputSchema).optional(),
  _avg: z.lazy(() => SaleTransactionsAvgOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => SaleTransactionsMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => SaleTransactionsMinOrderByAggregateInputSchema).optional(),
  _sum: z.lazy(() => SaleTransactionsSumOrderByAggregateInputSchema).optional()
}).strict();

export const SaleTransactionsScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.SaleTransactionsScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => SaleTransactionsScalarWhereWithAggregatesInputSchema),z.lazy(() => SaleTransactionsScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => SaleTransactionsScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => SaleTransactionsScalarWhereWithAggregatesInputSchema),z.lazy(() => SaleTransactionsScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
  tokenSymbol: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  quantity: z.union([ z.lazy(() => DecimalWithAggregatesFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional(),
  rawPrice: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  price: z.union([ z.lazy(() => DecimalWithAggregatesFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional(),
  totalAmount: z.union([ z.lazy(() => DecimalWithAggregatesFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional(),
  formOfPayment: z.union([ z.lazy(() => EnumFOPWithAggregatesFilterSchema),z.lazy(() => FOPSchema) ]).optional(),
  confirmationId: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  receivingWallet: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  status: z.union([ z.lazy(() => EnumTransactionStatusWithAggregatesFilterSchema),z.lazy(() => TransactionStatusSchema) ]).optional(),
  userId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  saleId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  comment: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  amountPaid: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  amountPaidCurrency: z.union([ z.lazy(() => EnumCurrencyWithAggregatesFilterSchema),z.lazy(() => CurrencySchema) ]).optional(),
  txHash: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  blockchainId: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  agreementId: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  approvedBy: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  rejectionReason: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  paymentEvidence: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  paymentDate: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
}).strict();

export const BlockchainWhereInputSchema: z.ZodType<Prisma.BlockchainWhereInput> = z.object({
  AND: z.union([ z.lazy(() => BlockchainWhereInputSchema),z.lazy(() => BlockchainWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => BlockchainWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => BlockchainWhereInputSchema),z.lazy(() => BlockchainWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  chainId: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  rpcUrl: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  explorerUrl: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  isTestnet: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  isEnabled: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  transactions: z.lazy(() => SaleTransactionsListRelationFilterSchema).optional(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsListRelationFilterSchema).optional(),
  Sale: z.lazy(() => SaleListRelationFilterSchema).optional()
}).strict();

export const BlockchainOrderByWithRelationInputSchema: z.ZodType<Prisma.BlockchainOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  chainId: z.lazy(() => SortOrderSchema).optional(),
  rpcUrl: z.lazy(() => SortOrderSchema).optional(),
  explorerUrl: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  isTestnet: z.lazy(() => SortOrderSchema).optional(),
  isEnabled: z.lazy(() => SortOrderSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsOrderByRelationAggregateInputSchema).optional(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsOrderByRelationAggregateInputSchema).optional(),
  Sale: z.lazy(() => SaleOrderByRelationAggregateInputSchema).optional()
}).strict();

export const BlockchainWhereUniqueInputSchema: z.ZodType<Prisma.BlockchainWhereUniqueInput> = z.union([
  z.object({
    id: z.string().cuid(),
    chainId: z.number().int()
  }),
  z.object({
    id: z.string().cuid(),
  }),
  z.object({
    chainId: z.number().int(),
  }),
])
.and(z.object({
  id: z.string().cuid().optional(),
  chainId: z.number().int().optional(),
  AND: z.union([ z.lazy(() => BlockchainWhereInputSchema),z.lazy(() => BlockchainWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => BlockchainWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => BlockchainWhereInputSchema),z.lazy(() => BlockchainWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  rpcUrl: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  explorerUrl: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  isTestnet: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  isEnabled: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  transactions: z.lazy(() => SaleTransactionsListRelationFilterSchema).optional(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsListRelationFilterSchema).optional(),
  Sale: z.lazy(() => SaleListRelationFilterSchema).optional()
}).strict());

export const BlockchainOrderByWithAggregationInputSchema: z.ZodType<Prisma.BlockchainOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  chainId: z.lazy(() => SortOrderSchema).optional(),
  rpcUrl: z.lazy(() => SortOrderSchema).optional(),
  explorerUrl: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  isTestnet: z.lazy(() => SortOrderSchema).optional(),
  isEnabled: z.lazy(() => SortOrderSchema).optional(),
  _count: z.lazy(() => BlockchainCountOrderByAggregateInputSchema).optional(),
  _avg: z.lazy(() => BlockchainAvgOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => BlockchainMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => BlockchainMinOrderByAggregateInputSchema).optional(),
  _sum: z.lazy(() => BlockchainSumOrderByAggregateInputSchema).optional()
}).strict();

export const BlockchainScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.BlockchainScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => BlockchainScalarWhereWithAggregatesInputSchema),z.lazy(() => BlockchainScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => BlockchainScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => BlockchainScalarWhereWithAggregatesInputSchema),z.lazy(() => BlockchainScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
  name: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  chainId: z.union([ z.lazy(() => IntWithAggregatesFilterSchema),z.number() ]).optional(),
  rpcUrl: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  explorerUrl: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  isTestnet: z.union([ z.lazy(() => BoolWithAggregatesFilterSchema),z.boolean() ]).optional(),
  isEnabled: z.union([ z.lazy(() => BoolWithAggregatesFilterSchema),z.boolean() ]).optional(),
}).strict();

export const ContractStatusWhereInputSchema: z.ZodType<Prisma.ContractStatusWhereInput> = z.object({
  AND: z.union([ z.lazy(() => ContractStatusWhereInputSchema),z.lazy(() => ContractStatusWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => ContractStatusWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => ContractStatusWhereInputSchema),z.lazy(() => ContractStatusWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  saleId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  contractId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  status: z.union([ z.lazy(() => EnumContractSignatureStatusFilterSchema),z.lazy(() => ContractSignatureStatusSchema) ]).optional(),
}).strict();

export const ContractStatusOrderByWithRelationInputSchema: z.ZodType<Prisma.ContractStatusOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  saleId: z.lazy(() => SortOrderSchema).optional(),
  contractId: z.lazy(() => SortOrderSchema).optional(),
  status: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const ContractStatusWhereUniqueInputSchema: z.ZodType<Prisma.ContractStatusWhereUniqueInput> = z.object({
  id: z.string().cuid()
})
.and(z.object({
  id: z.string().cuid().optional(),
  AND: z.union([ z.lazy(() => ContractStatusWhereInputSchema),z.lazy(() => ContractStatusWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => ContractStatusWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => ContractStatusWhereInputSchema),z.lazy(() => ContractStatusWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  saleId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  contractId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  status: z.union([ z.lazy(() => EnumContractSignatureStatusFilterSchema),z.lazy(() => ContractSignatureStatusSchema) ]).optional(),
}).strict());

export const ContractStatusOrderByWithAggregationInputSchema: z.ZodType<Prisma.ContractStatusOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  saleId: z.lazy(() => SortOrderSchema).optional(),
  contractId: z.lazy(() => SortOrderSchema).optional(),
  status: z.lazy(() => SortOrderSchema).optional(),
  _count: z.lazy(() => ContractStatusCountOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => ContractStatusMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => ContractStatusMinOrderByAggregateInputSchema).optional()
}).strict();

export const ContractStatusScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.ContractStatusScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => ContractStatusScalarWhereWithAggregatesInputSchema),z.lazy(() => ContractStatusScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => ContractStatusScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => ContractStatusScalarWhereWithAggregatesInputSchema),z.lazy(() => ContractStatusScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  saleId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  contractId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  status: z.union([ z.lazy(() => EnumContractSignatureStatusWithAggregatesFilterSchema),z.lazy(() => ContractSignatureStatusSchema) ]).optional(),
}).strict();

export const TransactionAuditWhereInputSchema: z.ZodType<Prisma.TransactionAuditWhereInput> = z.object({
  AND: z.union([ z.lazy(() => TransactionAuditWhereInputSchema),z.lazy(() => TransactionAuditWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => TransactionAuditWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TransactionAuditWhereInputSchema),z.lazy(() => TransactionAuditWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  transactionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  actionType: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  fromStatus: z.union([ z.lazy(() => EnumTransactionStatusFilterSchema),z.lazy(() => TransactionStatusSchema) ]).optional(),
  toStatus: z.union([ z.lazy(() => EnumTransactionStatusFilterSchema),z.lazy(() => TransactionStatusSchema) ]).optional(),
  performedBy: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  comment: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  transaction: z.union([ z.lazy(() => SaleTransactionsScalarRelationFilterSchema),z.lazy(() => SaleTransactionsWhereInputSchema) ]).optional(),
  admin: z.union([ z.lazy(() => UserScalarRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
}).strict();

export const TransactionAuditOrderByWithRelationInputSchema: z.ZodType<Prisma.TransactionAuditOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  transactionId: z.lazy(() => SortOrderSchema).optional(),
  actionType: z.lazy(() => SortOrderSchema).optional(),
  fromStatus: z.lazy(() => SortOrderSchema).optional(),
  toStatus: z.lazy(() => SortOrderSchema).optional(),
  performedBy: z.lazy(() => SortOrderSchema).optional(),
  comment: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  transaction: z.lazy(() => SaleTransactionsOrderByWithRelationInputSchema).optional(),
  admin: z.lazy(() => UserOrderByWithRelationInputSchema).optional()
}).strict();

export const TransactionAuditWhereUniqueInputSchema: z.ZodType<Prisma.TransactionAuditWhereUniqueInput> = z.object({
  id: z.string().cuid()
})
.and(z.object({
  id: z.string().cuid().optional(),
  AND: z.union([ z.lazy(() => TransactionAuditWhereInputSchema),z.lazy(() => TransactionAuditWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => TransactionAuditWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TransactionAuditWhereInputSchema),z.lazy(() => TransactionAuditWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  transactionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  actionType: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  fromStatus: z.union([ z.lazy(() => EnumTransactionStatusFilterSchema),z.lazy(() => TransactionStatusSchema) ]).optional(),
  toStatus: z.union([ z.lazy(() => EnumTransactionStatusFilterSchema),z.lazy(() => TransactionStatusSchema) ]).optional(),
  performedBy: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  comment: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  transaction: z.union([ z.lazy(() => SaleTransactionsScalarRelationFilterSchema),z.lazy(() => SaleTransactionsWhereInputSchema) ]).optional(),
  admin: z.union([ z.lazy(() => UserScalarRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
}).strict());

export const TransactionAuditOrderByWithAggregationInputSchema: z.ZodType<Prisma.TransactionAuditOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  transactionId: z.lazy(() => SortOrderSchema).optional(),
  actionType: z.lazy(() => SortOrderSchema).optional(),
  fromStatus: z.lazy(() => SortOrderSchema).optional(),
  toStatus: z.lazy(() => SortOrderSchema).optional(),
  performedBy: z.lazy(() => SortOrderSchema).optional(),
  comment: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  _count: z.lazy(() => TransactionAuditCountOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => TransactionAuditMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => TransactionAuditMinOrderByAggregateInputSchema).optional()
}).strict();

export const TransactionAuditScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.TransactionAuditScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => TransactionAuditScalarWhereWithAggregatesInputSchema),z.lazy(() => TransactionAuditScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => TransactionAuditScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TransactionAuditScalarWhereWithAggregatesInputSchema),z.lazy(() => TransactionAuditScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
  transactionId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  actionType: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  fromStatus: z.union([ z.lazy(() => EnumTransactionStatusWithAggregatesFilterSchema),z.lazy(() => TransactionStatusSchema) ]).optional(),
  toStatus: z.union([ z.lazy(() => EnumTransactionStatusWithAggregatesFilterSchema),z.lazy(() => TransactionStatusSchema) ]).optional(),
  performedBy: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  comment: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
}).strict();

export const KycVerificationWhereInputSchema: z.ZodType<Prisma.KycVerificationWhereInput> = z.object({
  AND: z.union([ z.lazy(() => KycVerificationWhereInputSchema),z.lazy(() => KycVerificationWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => KycVerificationWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => KycVerificationWhereInputSchema),z.lazy(() => KycVerificationWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  status: z.union([ z.lazy(() => EnumKycStatusFilterSchema),z.lazy(() => KycStatusSchema) ]).optional(),
  documentType: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  documentNumber: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  verifiedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  rejectionReason: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  user: z.union([ z.lazy(() => UserScalarRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
}).strict();

export const KycVerificationOrderByWithRelationInputSchema: z.ZodType<Prisma.KycVerificationOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  status: z.lazy(() => SortOrderSchema).optional(),
  documentType: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  documentNumber: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  verifiedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  rejectionReason: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  user: z.lazy(() => UserOrderByWithRelationInputSchema).optional()
}).strict();

export const KycVerificationWhereUniqueInputSchema: z.ZodType<Prisma.KycVerificationWhereUniqueInput> = z.union([
  z.object({
    id: z.string().cuid(),
    userId: z.string()
  }),
  z.object({
    id: z.string().cuid(),
  }),
  z.object({
    userId: z.string(),
  }),
])
.and(z.object({
  id: z.string().cuid().optional(),
  userId: z.string().optional(),
  AND: z.union([ z.lazy(() => KycVerificationWhereInputSchema),z.lazy(() => KycVerificationWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => KycVerificationWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => KycVerificationWhereInputSchema),z.lazy(() => KycVerificationWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  status: z.union([ z.lazy(() => EnumKycStatusFilterSchema),z.lazy(() => KycStatusSchema) ]).optional(),
  documentType: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  documentNumber: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  verifiedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  rejectionReason: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  user: z.union([ z.lazy(() => UserScalarRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
}).strict());

export const KycVerificationOrderByWithAggregationInputSchema: z.ZodType<Prisma.KycVerificationOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  status: z.lazy(() => SortOrderSchema).optional(),
  documentType: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  documentNumber: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  verifiedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  rejectionReason: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  _count: z.lazy(() => KycVerificationCountOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => KycVerificationMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => KycVerificationMinOrderByAggregateInputSchema).optional()
}).strict();

export const KycVerificationScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.KycVerificationScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => KycVerificationScalarWhereWithAggregatesInputSchema),z.lazy(() => KycVerificationScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => KycVerificationScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => KycVerificationScalarWhereWithAggregatesInputSchema),z.lazy(() => KycVerificationScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  status: z.union([ z.lazy(() => EnumKycStatusWithAggregatesFilterSchema),z.lazy(() => KycStatusSchema) ]).optional(),
  documentType: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  documentNumber: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  verifiedAt: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
  rejectionReason: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
}).strict();

export const RoleWhereInputSchema: z.ZodType<Prisma.RoleWhereInput> = z.object({
  AND: z.union([ z.lazy(() => RoleWhereInputSchema),z.lazy(() => RoleWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => RoleWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => RoleWhereInputSchema),z.lazy(() => RoleWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  description: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  users: z.lazy(() => UserRoleListRelationFilterSchema).optional()
}).strict();

export const RoleOrderByWithRelationInputSchema: z.ZodType<Prisma.RoleOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  description: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  users: z.lazy(() => UserRoleOrderByRelationAggregateInputSchema).optional()
}).strict();

export const RoleWhereUniqueInputSchema: z.ZodType<Prisma.RoleWhereUniqueInput> = z.union([
  z.object({
    id: z.string().cuid(),
    name: z.string()
  }),
  z.object({
    id: z.string().cuid(),
  }),
  z.object({
    name: z.string(),
  }),
])
.and(z.object({
  id: z.string().cuid().optional(),
  name: z.string().optional(),
  AND: z.union([ z.lazy(() => RoleWhereInputSchema),z.lazy(() => RoleWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => RoleWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => RoleWhereInputSchema),z.lazy(() => RoleWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  description: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  users: z.lazy(() => UserRoleListRelationFilterSchema).optional()
}).strict());

export const RoleOrderByWithAggregationInputSchema: z.ZodType<Prisma.RoleOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  description: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  _count: z.lazy(() => RoleCountOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => RoleMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => RoleMinOrderByAggregateInputSchema).optional()
}).strict();

export const RoleScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.RoleScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => RoleScalarWhereWithAggregatesInputSchema),z.lazy(() => RoleScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => RoleScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => RoleScalarWhereWithAggregatesInputSchema),z.lazy(() => RoleScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
  name: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  description: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
}).strict();

export const UserRoleWhereInputSchema: z.ZodType<Prisma.UserRoleWhereInput> = z.object({
  AND: z.union([ z.lazy(() => UserRoleWhereInputSchema),z.lazy(() => UserRoleWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => UserRoleWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => UserRoleWhereInputSchema),z.lazy(() => UserRoleWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  roleId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  user: z.union([ z.lazy(() => UserScalarRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  role: z.union([ z.lazy(() => RoleScalarRelationFilterSchema),z.lazy(() => RoleWhereInputSchema) ]).optional(),
}).strict();

export const UserRoleOrderByWithRelationInputSchema: z.ZodType<Prisma.UserRoleOrderByWithRelationInput> = z.object({
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  roleId: z.lazy(() => SortOrderSchema).optional(),
  user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
  role: z.lazy(() => RoleOrderByWithRelationInputSchema).optional()
}).strict();

export const UserRoleWhereUniqueInputSchema: z.ZodType<Prisma.UserRoleWhereUniqueInput> = z.object({
  userId_roleId: z.lazy(() => UserRoleUserIdRoleIdCompoundUniqueInputSchema)
})
.and(z.object({
  userId_roleId: z.lazy(() => UserRoleUserIdRoleIdCompoundUniqueInputSchema).optional(),
  AND: z.union([ z.lazy(() => UserRoleWhereInputSchema),z.lazy(() => UserRoleWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => UserRoleWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => UserRoleWhereInputSchema),z.lazy(() => UserRoleWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  roleId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  user: z.union([ z.lazy(() => UserScalarRelationFilterSchema),z.lazy(() => UserWhereInputSchema) ]).optional(),
  role: z.union([ z.lazy(() => RoleScalarRelationFilterSchema),z.lazy(() => RoleWhereInputSchema) ]).optional(),
}).strict());

export const UserRoleOrderByWithAggregationInputSchema: z.ZodType<Prisma.UserRoleOrderByWithAggregationInput> = z.object({
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  roleId: z.lazy(() => SortOrderSchema).optional(),
  _count: z.lazy(() => UserRoleCountOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => UserRoleMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => UserRoleMinOrderByAggregateInputSchema).optional()
}).strict();

export const UserRoleScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.UserRoleScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => UserRoleScalarWhereWithAggregatesInputSchema),z.lazy(() => UserRoleScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => UserRoleScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => UserRoleScalarWhereWithAggregatesInputSchema),z.lazy(() => UserRoleScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  roleId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
}).strict();

export const TokenWhereInputSchema: z.ZodType<Prisma.TokenWhereInput> = z.object({
  AND: z.union([ z.lazy(() => TokenWhereInputSchema),z.lazy(() => TokenWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => TokenWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TokenWhereInputSchema),z.lazy(() => TokenWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  symbol: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  totalSupply: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  image: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  sales: z.lazy(() => SaleListRelationFilterSchema).optional(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsListRelationFilterSchema).optional()
}).strict();

export const TokenOrderByWithRelationInputSchema: z.ZodType<Prisma.TokenOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  symbol: z.lazy(() => SortOrderSchema).optional(),
  totalSupply: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  image: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  sales: z.lazy(() => SaleOrderByRelationAggregateInputSchema).optional(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsOrderByRelationAggregateInputSchema).optional()
}).strict();

export const TokenWhereUniqueInputSchema: z.ZodType<Prisma.TokenWhereUniqueInput> = z.object({
  id: z.string().cuid()
})
.and(z.object({
  id: z.string().cuid().optional(),
  AND: z.union([ z.lazy(() => TokenWhereInputSchema),z.lazy(() => TokenWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => TokenWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TokenWhereInputSchema),z.lazy(() => TokenWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  symbol: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  totalSupply: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  image: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  sales: z.lazy(() => SaleListRelationFilterSchema).optional(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsListRelationFilterSchema).optional()
}).strict());

export const TokenOrderByWithAggregationInputSchema: z.ZodType<Prisma.TokenOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  symbol: z.lazy(() => SortOrderSchema).optional(),
  totalSupply: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  image: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  _count: z.lazy(() => TokenCountOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => TokenMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => TokenMinOrderByAggregateInputSchema).optional()
}).strict();

export const TokenScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.TokenScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => TokenScalarWhereWithAggregatesInputSchema),z.lazy(() => TokenScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => TokenScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TokenScalarWhereWithAggregatesInputSchema),z.lazy(() => TokenScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeWithAggregatesFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),z.coerce.date() ]).optional().nullable(),
  symbol: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  totalSupply: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
  image: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
}).strict();

export const TokensOnBlockchainsWhereInputSchema: z.ZodType<Prisma.TokensOnBlockchainsWhereInput> = z.object({
  AND: z.union([ z.lazy(() => TokensOnBlockchainsWhereInputSchema),z.lazy(() => TokensOnBlockchainsWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => TokensOnBlockchainsWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TokensOnBlockchainsWhereInputSchema),z.lazy(() => TokensOnBlockchainsWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  tokenId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  tokenSymbol: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  blockchainId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  isNative: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  decimals: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  contractAddress: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  token: z.union([ z.lazy(() => TokenScalarRelationFilterSchema),z.lazy(() => TokenWhereInputSchema) ]).optional(),
  blockchain: z.union([ z.lazy(() => BlockchainScalarRelationFilterSchema),z.lazy(() => BlockchainWhereInputSchema) ]).optional(),
}).strict();

export const TokensOnBlockchainsOrderByWithRelationInputSchema: z.ZodType<Prisma.TokensOnBlockchainsOrderByWithRelationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  tokenId: z.lazy(() => SortOrderSchema).optional(),
  tokenSymbol: z.lazy(() => SortOrderSchema).optional(),
  blockchainId: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  isNative: z.lazy(() => SortOrderSchema).optional(),
  decimals: z.lazy(() => SortOrderSchema).optional(),
  contractAddress: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  token: z.lazy(() => TokenOrderByWithRelationInputSchema).optional(),
  blockchain: z.lazy(() => BlockchainOrderByWithRelationInputSchema).optional()
}).strict();

export const TokensOnBlockchainsWhereUniqueInputSchema: z.ZodType<Prisma.TokensOnBlockchainsWhereUniqueInput> = z.union([
  z.object({
    id: z.string().cuid(),
    tokenId_blockchainId: z.lazy(() => TokensOnBlockchainsTokenIdBlockchainIdCompoundUniqueInputSchema),
    tokenSymbol_blockchainId: z.lazy(() => TokensOnBlockchainsTokenSymbolBlockchainIdCompoundUniqueInputSchema)
  }),
  z.object({
    id: z.string().cuid(),
    tokenId_blockchainId: z.lazy(() => TokensOnBlockchainsTokenIdBlockchainIdCompoundUniqueInputSchema),
  }),
  z.object({
    id: z.string().cuid(),
    tokenSymbol_blockchainId: z.lazy(() => TokensOnBlockchainsTokenSymbolBlockchainIdCompoundUniqueInputSchema),
  }),
  z.object({
    id: z.string().cuid(),
  }),
  z.object({
    tokenId_blockchainId: z.lazy(() => TokensOnBlockchainsTokenIdBlockchainIdCompoundUniqueInputSchema),
    tokenSymbol_blockchainId: z.lazy(() => TokensOnBlockchainsTokenSymbolBlockchainIdCompoundUniqueInputSchema),
  }),
  z.object({
    tokenId_blockchainId: z.lazy(() => TokensOnBlockchainsTokenIdBlockchainIdCompoundUniqueInputSchema),
  }),
  z.object({
    tokenSymbol_blockchainId: z.lazy(() => TokensOnBlockchainsTokenSymbolBlockchainIdCompoundUniqueInputSchema),
  }),
])
.and(z.object({
  id: z.string().cuid().optional(),
  tokenId_blockchainId: z.lazy(() => TokensOnBlockchainsTokenIdBlockchainIdCompoundUniqueInputSchema).optional(),
  tokenSymbol_blockchainId: z.lazy(() => TokensOnBlockchainsTokenSymbolBlockchainIdCompoundUniqueInputSchema).optional(),
  AND: z.union([ z.lazy(() => TokensOnBlockchainsWhereInputSchema),z.lazy(() => TokensOnBlockchainsWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => TokensOnBlockchainsWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TokensOnBlockchainsWhereInputSchema),z.lazy(() => TokensOnBlockchainsWhereInputSchema).array() ]).optional(),
  tokenId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  tokenSymbol: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  blockchainId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  isNative: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  decimals: z.union([ z.lazy(() => IntFilterSchema),z.number().int() ]).optional(),
  contractAddress: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  token: z.union([ z.lazy(() => TokenScalarRelationFilterSchema),z.lazy(() => TokenWhereInputSchema) ]).optional(),
  blockchain: z.union([ z.lazy(() => BlockchainScalarRelationFilterSchema),z.lazy(() => BlockchainWhereInputSchema) ]).optional(),
}).strict());

export const TokensOnBlockchainsOrderByWithAggregationInputSchema: z.ZodType<Prisma.TokensOnBlockchainsOrderByWithAggregationInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  tokenId: z.lazy(() => SortOrderSchema).optional(),
  tokenSymbol: z.lazy(() => SortOrderSchema).optional(),
  blockchainId: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  isNative: z.lazy(() => SortOrderSchema).optional(),
  decimals: z.lazy(() => SortOrderSchema).optional(),
  contractAddress: z.union([ z.lazy(() => SortOrderSchema),z.lazy(() => SortOrderInputSchema) ]).optional(),
  _count: z.lazy(() => TokensOnBlockchainsCountOrderByAggregateInputSchema).optional(),
  _avg: z.lazy(() => TokensOnBlockchainsAvgOrderByAggregateInputSchema).optional(),
  _max: z.lazy(() => TokensOnBlockchainsMaxOrderByAggregateInputSchema).optional(),
  _min: z.lazy(() => TokensOnBlockchainsMinOrderByAggregateInputSchema).optional(),
  _sum: z.lazy(() => TokensOnBlockchainsSumOrderByAggregateInputSchema).optional()
}).strict();

export const TokensOnBlockchainsScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.TokensOnBlockchainsScalarWhereWithAggregatesInput> = z.object({
  AND: z.union([ z.lazy(() => TokensOnBlockchainsScalarWhereWithAggregatesInputSchema),z.lazy(() => TokensOnBlockchainsScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  OR: z.lazy(() => TokensOnBlockchainsScalarWhereWithAggregatesInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TokensOnBlockchainsScalarWhereWithAggregatesInputSchema),z.lazy(() => TokensOnBlockchainsScalarWhereWithAggregatesInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  tokenId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  tokenSymbol: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  blockchainId: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  name: z.union([ z.lazy(() => StringWithAggregatesFilterSchema),z.string() ]).optional(),
  isNative: z.union([ z.lazy(() => BoolWithAggregatesFilterSchema),z.boolean() ]).optional(),
  decimals: z.union([ z.lazy(() => IntWithAggregatesFilterSchema),z.number() ]).optional(),
  contractAddress: z.union([ z.lazy(() => StringNullableWithAggregatesFilterSchema),z.string() ]).optional().nullable(),
}).strict();

export const UserCreateInputSchema: z.ZodType<Prisma.UserCreateInput> = z.object({
  id: z.string().cuid().optional(),
  externalId: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  walletAddress: z.string(),
  email: z.string(),
  emailVerified: z.boolean().optional(),
  image: z.string().optional().nullable(),
  isSiwe: z.boolean().optional().nullable(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutUserInputSchema).optional(),
  sales: z.lazy(() => SaleCreateNestedManyWithoutUserInputSchema).optional(),
  userRole: z.lazy(() => UserRoleCreateNestedManyWithoutUserInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditCreateNestedManyWithoutAdminInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationCreateNestedOneWithoutUserInputSchema).optional(),
  sessions: z.lazy(() => SessionCreateNestedManyWithoutUserInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsCreateNestedManyWithoutUserInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsCreateNestedManyWithoutApproverInputSchema).optional(),
  Document: z.lazy(() => DocumentCreateNestedManyWithoutUserInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressCreateNestedManyWithoutAddressInputSchema).optional()
}).strict();

export const UserUncheckedCreateInputSchema: z.ZodType<Prisma.UserUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  externalId: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  walletAddress: z.string(),
  email: z.string(),
  emailVerified: z.boolean().optional(),
  image: z.string().optional().nullable(),
  isSiwe: z.boolean().optional().nullable(),
  profile: z.lazy(() => ProfileUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  sales: z.lazy(() => SaleUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUncheckedCreateNestedManyWithoutAdminInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  sessions: z.lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutApproverInputSchema).optional(),
  Document: z.lazy(() => DocumentUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUncheckedCreateNestedManyWithoutAddressInputSchema).optional()
}).strict();

export const UserUpdateInputSchema: z.ZodType<Prisma.UserUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  externalId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailVerified: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isSiwe: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profile: z.lazy(() => ProfileUpdateOneWithoutUserNestedInputSchema).optional(),
  sales: z.lazy(() => SaleUpdateManyWithoutUserNestedInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUpdateManyWithoutAdminNestedInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUpdateOneWithoutUserNestedInputSchema).optional(),
  sessions: z.lazy(() => SessionUpdateManyWithoutUserNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUpdateManyWithoutApproverNestedInputSchema).optional(),
  Document: z.lazy(() => DocumentUpdateManyWithoutUserNestedInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUpdateManyWithoutAddressNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateInputSchema: z.ZodType<Prisma.UserUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  externalId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailVerified: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isSiwe: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profile: z.lazy(() => ProfileUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  sales: z.lazy(() => SaleUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUncheckedUpdateManyWithoutAdminNestedInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  sessions: z.lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutApproverNestedInputSchema).optional(),
  Document: z.lazy(() => DocumentUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUncheckedUpdateManyWithoutAddressNestedInputSchema).optional()
}).strict();

export const UserCreateManyInputSchema: z.ZodType<Prisma.UserCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  externalId: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  walletAddress: z.string(),
  email: z.string(),
  emailVerified: z.boolean().optional(),
  image: z.string().optional().nullable(),
  isSiwe: z.boolean().optional().nullable()
}).strict();

export const UserUpdateManyMutationInputSchema: z.ZodType<Prisma.UserUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  externalId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailVerified: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isSiwe: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const UserUncheckedUpdateManyInputSchema: z.ZodType<Prisma.UserUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  externalId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailVerified: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isSiwe: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const WalletAddressCreateInputSchema: z.ZodType<Prisma.WalletAddressCreateInput> = z.object({
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  chainId: z.number().int(),
  address: z.lazy(() => UserCreateNestedOneWithoutWalletAddressInputSchema)
}).strict();

export const WalletAddressUncheckedCreateInputSchema: z.ZodType<Prisma.WalletAddressUncheckedCreateInput> = z.object({
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  walletAddress: z.string(),
  chainId: z.number().int()
}).strict();

export const WalletAddressUpdateInputSchema: z.ZodType<Prisma.WalletAddressUpdateInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  chainId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  address: z.lazy(() => UserUpdateOneRequiredWithoutWalletAddressNestedInputSchema).optional()
}).strict();

export const WalletAddressUncheckedUpdateInputSchema: z.ZodType<Prisma.WalletAddressUncheckedUpdateInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  chainId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const WalletAddressCreateManyInputSchema: z.ZodType<Prisma.WalletAddressCreateManyInput> = z.object({
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  walletAddress: z.string(),
  chainId: z.number().int()
}).strict();

export const WalletAddressUpdateManyMutationInputSchema: z.ZodType<Prisma.WalletAddressUpdateManyMutationInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  chainId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const WalletAddressUncheckedUpdateManyInputSchema: z.ZodType<Prisma.WalletAddressUncheckedUpdateManyInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  chainId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const SessionCreateInputSchema: z.ZodType<Prisma.SessionCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  expiresAt: z.coerce.date(),
  token: z.string(),
  ipAddress: z.string().optional().nullable(),
  userAgent: z.string().optional().nullable(),
  user: z.lazy(() => UserCreateNestedOneWithoutSessionsInputSchema)
}).strict();

export const SessionUncheckedCreateInputSchema: z.ZodType<Prisma.SessionUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  expiresAt: z.coerce.date(),
  token: z.string(),
  ipAddress: z.string().optional().nullable(),
  userAgent: z.string().optional().nullable(),
  userId: z.string()
}).strict();

export const SessionUpdateInputSchema: z.ZodType<Prisma.SessionUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  expiresAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  token: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  ipAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userAgent: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutSessionsNestedInputSchema).optional()
}).strict();

export const SessionUncheckedUpdateInputSchema: z.ZodType<Prisma.SessionUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  expiresAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  token: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  ipAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userAgent: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const SessionCreateManyInputSchema: z.ZodType<Prisma.SessionCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  expiresAt: z.coerce.date(),
  token: z.string(),
  ipAddress: z.string().optional().nullable(),
  userAgent: z.string().optional().nullable(),
  userId: z.string()
}).strict();

export const SessionUpdateManyMutationInputSchema: z.ZodType<Prisma.SessionUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  expiresAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  token: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  ipAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userAgent: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const SessionUncheckedUpdateManyInputSchema: z.ZodType<Prisma.SessionUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  expiresAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  token: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  ipAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userAgent: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const VerificationCreateInputSchema: z.ZodType<Prisma.VerificationCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  expiresAt: z.coerce.date(),
  identifier: z.string(),
  value: z.string()
}).strict();

export const VerificationUncheckedCreateInputSchema: z.ZodType<Prisma.VerificationUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  expiresAt: z.coerce.date(),
  identifier: z.string(),
  value: z.string()
}).strict();

export const VerificationUpdateInputSchema: z.ZodType<Prisma.VerificationUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  expiresAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  identifier: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  value: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const VerificationUncheckedUpdateInputSchema: z.ZodType<Prisma.VerificationUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  expiresAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  identifier: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  value: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const VerificationCreateManyInputSchema: z.ZodType<Prisma.VerificationCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  expiresAt: z.coerce.date(),
  identifier: z.string(),
  value: z.string()
}).strict();

export const VerificationUpdateManyMutationInputSchema: z.ZodType<Prisma.VerificationUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  expiresAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  identifier: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  value: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const VerificationUncheckedUpdateManyInputSchema: z.ZodType<Prisma.VerificationUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  expiresAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  identifier: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  value: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const ProfileCreateInputSchema: z.ZodType<Prisma.ProfileCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  firstName: z.string().optional().nullable(),
  lastName: z.string().optional().nullable(),
  email: z.string().optional().nullable(),
  phoneNumber: z.string().optional().nullable(),
  dateOfBirth: z.coerce.date().optional().nullable(),
  user: z.lazy(() => UserCreateNestedOneWithoutProfileInputSchema),
  address: z.lazy(() => AddressCreateNestedOneWithoutProfileInputSchema).optional()
}).strict();

export const ProfileUncheckedCreateInputSchema: z.ZodType<Prisma.ProfileUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  firstName: z.string().optional().nullable(),
  lastName: z.string().optional().nullable(),
  userId: z.string(),
  email: z.string().optional().nullable(),
  phoneNumber: z.string().optional().nullable(),
  dateOfBirth: z.coerce.date().optional().nullable(),
  address: z.lazy(() => AddressUncheckedCreateNestedOneWithoutProfileInputSchema).optional()
}).strict();

export const ProfileUpdateInputSchema: z.ZodType<Prisma.ProfileUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  firstName: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  lastName: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  email: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  phoneNumber: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  dateOfBirth: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutProfileNestedInputSchema).optional(),
  address: z.lazy(() => AddressUpdateOneWithoutProfileNestedInputSchema).optional()
}).strict();

export const ProfileUncheckedUpdateInputSchema: z.ZodType<Prisma.ProfileUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  firstName: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  lastName: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  phoneNumber: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  dateOfBirth: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  address: z.lazy(() => AddressUncheckedUpdateOneWithoutProfileNestedInputSchema).optional()
}).strict();

export const ProfileCreateManyInputSchema: z.ZodType<Prisma.ProfileCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  firstName: z.string().optional().nullable(),
  lastName: z.string().optional().nullable(),
  userId: z.string(),
  email: z.string().optional().nullable(),
  phoneNumber: z.string().optional().nullable(),
  dateOfBirth: z.coerce.date().optional().nullable()
}).strict();

export const ProfileUpdateManyMutationInputSchema: z.ZodType<Prisma.ProfileUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  firstName: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  lastName: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  email: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  phoneNumber: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  dateOfBirth: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const ProfileUncheckedUpdateManyInputSchema: z.ZodType<Prisma.ProfileUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  firstName: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  lastName: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  phoneNumber: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  dateOfBirth: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const AddressCreateInputSchema: z.ZodType<Prisma.AddressCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  city: z.string().optional().nullable(),
  zipCode: z.string().optional().nullable(),
  country: z.string().optional().nullable(),
  state: z.string().optional().nullable(),
  street: z.string().optional().nullable(),
  formattedAddress: z.string().optional().nullable(),
  latitude: z.number().optional().nullable(),
  longitude: z.number().optional().nullable(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutAddressInputSchema).optional()
}).strict();

export const AddressUncheckedCreateInputSchema: z.ZodType<Prisma.AddressUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  userId: z.string(),
  city: z.string().optional().nullable(),
  zipCode: z.string().optional().nullable(),
  country: z.string().optional().nullable(),
  state: z.string().optional().nullable(),
  street: z.string().optional().nullable(),
  formattedAddress: z.string().optional().nullable(),
  latitude: z.number().optional().nullable(),
  longitude: z.number().optional().nullable()
}).strict();

export const AddressUpdateInputSchema: z.ZodType<Prisma.AddressUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  city: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  zipCode: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  country: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  state: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  street: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  formattedAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  latitude: z.union([ z.number(),z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  longitude: z.union([ z.number(),z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profile: z.lazy(() => ProfileUpdateOneWithoutAddressNestedInputSchema).optional()
}).strict();

export const AddressUncheckedUpdateInputSchema: z.ZodType<Prisma.AddressUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  city: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  zipCode: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  country: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  state: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  street: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  formattedAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  latitude: z.union([ z.number(),z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  longitude: z.union([ z.number(),z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const AddressCreateManyInputSchema: z.ZodType<Prisma.AddressCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  userId: z.string(),
  city: z.string().optional().nullable(),
  zipCode: z.string().optional().nullable(),
  country: z.string().optional().nullable(),
  state: z.string().optional().nullable(),
  street: z.string().optional().nullable(),
  formattedAddress: z.string().optional().nullable(),
  latitude: z.number().optional().nullable(),
  longitude: z.number().optional().nullable()
}).strict();

export const AddressUpdateManyMutationInputSchema: z.ZodType<Prisma.AddressUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  city: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  zipCode: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  country: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  state: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  street: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  formattedAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  latitude: z.union([ z.number(),z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  longitude: z.union([ z.number(),z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const AddressUncheckedUpdateManyInputSchema: z.ZodType<Prisma.AddressUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  city: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  zipCode: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  country: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  state: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  street: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  formattedAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  latitude: z.union([ z.number(),z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  longitude: z.union([ z.number(),z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const SaleCreateInputSchema: z.ZodType<Prisma.SaleCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  status: z.lazy(() => SaleStatusSchema).optional(),
  saleCurrency: z.lazy(() => CurrencySchema).optional(),
  initialTokenQuantity: z.number().int(),
  availableTokenQuantity: z.number().int(),
  maximumTokenBuyPerUser: z.number().int().optional().nullable(),
  minimumTokenBuyPerUser: z.number().int().optional(),
  saleStartDate: z.coerce.date(),
  tokenContractAddress: z.string().optional().nullable(),
  tokenName: z.string(),
  tokenTotalSupply: z.string().optional().nullable(),
  tokenPricePerUnit: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  tokenSymbol: z.string(),
  toWalletsAddress: z.string(),
  saleClosingDate: z.coerce.date(),
  saftCheckbox: z.boolean().optional(),
  saftContract: z.string().optional().nullable(),
  blockchain: z.lazy(() => BlockchainCreateNestedOneWithoutSaleInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutSalesInputSchema),
  transactions: z.lazy(() => SaleTransactionsCreateNestedManyWithoutSaleInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationCreateNestedOneWithoutSaleInputSchema).optional(),
  documents: z.lazy(() => DocumentCreateNestedManyWithoutSaleInputSchema).optional(),
  token: z.lazy(() => TokenCreateNestedOneWithoutSalesInputSchema),
  vestingSchedules: z.lazy(() => VestingScheduleCreateNestedManyWithoutSaleInputSchema).optional()
}).strict();

export const SaleUncheckedCreateInputSchema: z.ZodType<Prisma.SaleUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  status: z.lazy(() => SaleStatusSchema).optional(),
  saleCurrency: z.lazy(() => CurrencySchema).optional(),
  initialTokenQuantity: z.number().int(),
  availableTokenQuantity: z.number().int(),
  maximumTokenBuyPerUser: z.number().int().optional().nullable(),
  minimumTokenBuyPerUser: z.number().int().optional(),
  saleStartDate: z.coerce.date(),
  tokenContractAddress: z.string().optional().nullable(),
  tokenContractChainId: z.number().int().optional().nullable(),
  tokenName: z.string(),
  tokenTotalSupply: z.string().optional().nullable(),
  tokenPricePerUnit: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  tokenSymbol: z.string(),
  toWalletsAddress: z.string(),
  saleClosingDate: z.coerce.date(),
  createdBy: z.string(),
  saftCheckbox: z.boolean().optional(),
  saftContract: z.string().optional().nullable(),
  tokenId: z.string(),
  transactions: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutSaleInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationUncheckedCreateNestedOneWithoutSaleInputSchema).optional(),
  documents: z.lazy(() => DocumentUncheckedCreateNestedManyWithoutSaleInputSchema).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleUncheckedCreateNestedManyWithoutSaleInputSchema).optional()
}).strict();

export const SaleUpdateInputSchema: z.ZodType<Prisma.SaleUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => EnumSaleStatusFieldUpdateOperationsInputSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  initialTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  availableTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  saleStartDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  tokenContractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenTotalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  toWalletsAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleClosingDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  saftCheckbox: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  saftContract: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  blockchain: z.lazy(() => BlockchainUpdateOneWithoutSaleNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutSalesNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUpdateManyWithoutSaleNestedInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationUpdateOneWithoutSaleNestedInputSchema).optional(),
  documents: z.lazy(() => DocumentUpdateManyWithoutSaleNestedInputSchema).optional(),
  token: z.lazy(() => TokenUpdateOneRequiredWithoutSalesNestedInputSchema).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleUpdateManyWithoutSaleNestedInputSchema).optional()
}).strict();

export const SaleUncheckedUpdateInputSchema: z.ZodType<Prisma.SaleUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => EnumSaleStatusFieldUpdateOperationsInputSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  initialTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  availableTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  saleStartDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  tokenContractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenContractChainId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenTotalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  toWalletsAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleClosingDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  createdBy: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saftCheckbox: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  saftContract: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutSaleNestedInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationUncheckedUpdateOneWithoutSaleNestedInputSchema).optional(),
  documents: z.lazy(() => DocumentUncheckedUpdateManyWithoutSaleNestedInputSchema).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleUncheckedUpdateManyWithoutSaleNestedInputSchema).optional()
}).strict();

export const SaleCreateManyInputSchema: z.ZodType<Prisma.SaleCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  status: z.lazy(() => SaleStatusSchema).optional(),
  saleCurrency: z.lazy(() => CurrencySchema).optional(),
  initialTokenQuantity: z.number().int(),
  availableTokenQuantity: z.number().int(),
  maximumTokenBuyPerUser: z.number().int().optional().nullable(),
  minimumTokenBuyPerUser: z.number().int().optional(),
  saleStartDate: z.coerce.date(),
  tokenContractAddress: z.string().optional().nullable(),
  tokenContractChainId: z.number().int().optional().nullable(),
  tokenName: z.string(),
  tokenTotalSupply: z.string().optional().nullable(),
  tokenPricePerUnit: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  tokenSymbol: z.string(),
  toWalletsAddress: z.string(),
  saleClosingDate: z.coerce.date(),
  createdBy: z.string(),
  saftCheckbox: z.boolean().optional(),
  saftContract: z.string().optional().nullable(),
  tokenId: z.string()
}).strict();

export const SaleUpdateManyMutationInputSchema: z.ZodType<Prisma.SaleUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => EnumSaleStatusFieldUpdateOperationsInputSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  initialTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  availableTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  saleStartDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  tokenContractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenTotalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  toWalletsAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleClosingDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  saftCheckbox: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  saftContract: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const SaleUncheckedUpdateManyInputSchema: z.ZodType<Prisma.SaleUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => EnumSaleStatusFieldUpdateOperationsInputSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  initialTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  availableTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  saleStartDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  tokenContractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenContractChainId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenTotalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  toWalletsAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleClosingDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  createdBy: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saftCheckbox: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  saftContract: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const DocumentCreateInputSchema: z.ZodType<Prisma.DocumentCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  fileName: z.string(),
  url: z.string(),
  type: z.string(),
  sale: z.lazy(() => SaleCreateNestedOneWithoutDocumentsInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutDocumentInputSchema).optional()
}).strict();

export const DocumentUncheckedCreateInputSchema: z.ZodType<Prisma.DocumentUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  fileName: z.string(),
  url: z.string(),
  type: z.string(),
  saleId: z.string().optional().nullable(),
  userId: z.string().optional().nullable()
}).strict();

export const DocumentUpdateInputSchema: z.ZodType<Prisma.DocumentUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  fileName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  url: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sale: z.lazy(() => SaleUpdateOneWithoutDocumentsNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneWithoutDocumentNestedInputSchema).optional()
}).strict();

export const DocumentUncheckedUpdateInputSchema: z.ZodType<Prisma.DocumentUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  fileName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  url: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const DocumentCreateManyInputSchema: z.ZodType<Prisma.DocumentCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  fileName: z.string(),
  url: z.string(),
  type: z.string(),
  saleId: z.string().optional().nullable(),
  userId: z.string().optional().nullable()
}).strict();

export const DocumentUpdateManyMutationInputSchema: z.ZodType<Prisma.DocumentUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  fileName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  url: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const DocumentUncheckedUpdateManyInputSchema: z.ZodType<Prisma.DocumentUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  fileName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  url: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const VestingScheduleCreateInputSchema: z.ZodType<Prisma.VestingScheduleCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  cliffPeriod: z.number().int(),
  vestingPeriod: z.number().int(),
  releaseFrequency: z.number().int(),
  initialRelease: z.number(),
  isEnabled: z.boolean().optional(),
  sale: z.lazy(() => SaleCreateNestedOneWithoutVestingSchedulesInputSchema)
}).strict();

export const VestingScheduleUncheckedCreateInputSchema: z.ZodType<Prisma.VestingScheduleUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  saleId: z.string(),
  name: z.string(),
  cliffPeriod: z.number().int(),
  vestingPeriod: z.number().int(),
  releaseFrequency: z.number().int(),
  initialRelease: z.number(),
  isEnabled: z.boolean().optional()
}).strict();

export const VestingScheduleUpdateInputSchema: z.ZodType<Prisma.VestingScheduleUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  cliffPeriod: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  vestingPeriod: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  releaseFrequency: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  initialRelease: z.union([ z.number(),z.lazy(() => FloatFieldUpdateOperationsInputSchema) ]).optional(),
  isEnabled: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  sale: z.lazy(() => SaleUpdateOneRequiredWithoutVestingSchedulesNestedInputSchema).optional()
}).strict();

export const VestingScheduleUncheckedUpdateInputSchema: z.ZodType<Prisma.VestingScheduleUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  saleId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  cliffPeriod: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  vestingPeriod: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  releaseFrequency: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  initialRelease: z.union([ z.number(),z.lazy(() => FloatFieldUpdateOperationsInputSchema) ]).optional(),
  isEnabled: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const VestingScheduleCreateManyInputSchema: z.ZodType<Prisma.VestingScheduleCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  saleId: z.string(),
  name: z.string(),
  cliffPeriod: z.number().int(),
  vestingPeriod: z.number().int(),
  releaseFrequency: z.number().int(),
  initialRelease: z.number(),
  isEnabled: z.boolean().optional()
}).strict();

export const VestingScheduleUpdateManyMutationInputSchema: z.ZodType<Prisma.VestingScheduleUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  cliffPeriod: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  vestingPeriod: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  releaseFrequency: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  initialRelease: z.union([ z.number(),z.lazy(() => FloatFieldUpdateOperationsInputSchema) ]).optional(),
  isEnabled: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const VestingScheduleUncheckedUpdateManyInputSchema: z.ZodType<Prisma.VestingScheduleUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  saleId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  cliffPeriod: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  vestingPeriod: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  releaseFrequency: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  initialRelease: z.union([ z.number(),z.lazy(() => FloatFieldUpdateOperationsInputSchema) ]).optional(),
  isEnabled: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const TokenDistributionCreateInputSchema: z.ZodType<Prisma.TokenDistributionCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  amount: z.string(),
  distributionDate: z.coerce.date(),
  txHash: z.string().optional().nullable(),
  status: z.string(),
  transaction: z.lazy(() => SaleTransactionsCreateNestedOneWithoutTokenDistributionsInputSchema)
}).strict();

export const TokenDistributionUncheckedCreateInputSchema: z.ZodType<Prisma.TokenDistributionUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  transactionId: z.string(),
  amount: z.string(),
  distributionDate: z.coerce.date(),
  txHash: z.string().optional().nullable(),
  status: z.string()
}).strict();

export const TokenDistributionUpdateInputSchema: z.ZodType<Prisma.TokenDistributionUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amount: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  distributionDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  transaction: z.lazy(() => SaleTransactionsUpdateOneRequiredWithoutTokenDistributionsNestedInputSchema).optional()
}).strict();

export const TokenDistributionUncheckedUpdateInputSchema: z.ZodType<Prisma.TokenDistributionUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  transactionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  amount: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  distributionDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const TokenDistributionCreateManyInputSchema: z.ZodType<Prisma.TokenDistributionCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  transactionId: z.string(),
  amount: z.string(),
  distributionDate: z.coerce.date(),
  txHash: z.string().optional().nullable(),
  status: z.string()
}).strict();

export const TokenDistributionUpdateManyMutationInputSchema: z.ZodType<Prisma.TokenDistributionUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amount: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  distributionDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const TokenDistributionUncheckedUpdateManyInputSchema: z.ZodType<Prisma.TokenDistributionUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  transactionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  amount: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  distributionDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const SaleInformationCreateInputSchema: z.ZodType<Prisma.SaleInformationCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  summary: z.string().optional().nullable(),
  tokenUtility: z.string().optional().nullable(),
  tokenDistribution: z.string().optional().nullable(),
  otherInformation: z.string().optional().nullable(),
  tokenLifecycle: z.string().optional().nullable(),
  liquidityPool: z.string().optional().nullable(),
  futurePlans: z.string().optional().nullable(),
  useOfProceeds: z.string().optional().nullable(),
  imageSale: z.string().optional().nullable(),
  imageToken: z.string().optional().nullable(),
  contactEmail: z.string().optional().nullable(),
  sale: z.lazy(() => SaleCreateNestedOneWithoutSaleInformationInputSchema)
}).strict();

export const SaleInformationUncheckedCreateInputSchema: z.ZodType<Prisma.SaleInformationUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  summary: z.string().optional().nullable(),
  tokenUtility: z.string().optional().nullable(),
  tokenDistribution: z.string().optional().nullable(),
  otherInformation: z.string().optional().nullable(),
  tokenLifecycle: z.string().optional().nullable(),
  liquidityPool: z.string().optional().nullable(),
  futurePlans: z.string().optional().nullable(),
  useOfProceeds: z.string().optional().nullable(),
  imageSale: z.string().optional().nullable(),
  imageToken: z.string().optional().nullable(),
  contactEmail: z.string().optional().nullable(),
  saleId: z.string()
}).strict();

export const SaleInformationUpdateInputSchema: z.ZodType<Prisma.SaleInformationUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  summary: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenUtility: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenDistribution: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  otherInformation: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenLifecycle: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  liquidityPool: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  futurePlans: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  useOfProceeds: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  imageSale: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  imageToken: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  contactEmail: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sale: z.lazy(() => SaleUpdateOneRequiredWithoutSaleInformationNestedInputSchema).optional()
}).strict();

export const SaleInformationUncheckedUpdateInputSchema: z.ZodType<Prisma.SaleInformationUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  summary: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenUtility: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenDistribution: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  otherInformation: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenLifecycle: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  liquidityPool: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  futurePlans: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  useOfProceeds: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  imageSale: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  imageToken: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  contactEmail: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  saleId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const SaleInformationCreateManyInputSchema: z.ZodType<Prisma.SaleInformationCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  summary: z.string().optional().nullable(),
  tokenUtility: z.string().optional().nullable(),
  tokenDistribution: z.string().optional().nullable(),
  otherInformation: z.string().optional().nullable(),
  tokenLifecycle: z.string().optional().nullable(),
  liquidityPool: z.string().optional().nullable(),
  futurePlans: z.string().optional().nullable(),
  useOfProceeds: z.string().optional().nullable(),
  imageSale: z.string().optional().nullable(),
  imageToken: z.string().optional().nullable(),
  contactEmail: z.string().optional().nullable(),
  saleId: z.string()
}).strict();

export const SaleInformationUpdateManyMutationInputSchema: z.ZodType<Prisma.SaleInformationUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  summary: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenUtility: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenDistribution: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  otherInformation: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenLifecycle: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  liquidityPool: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  futurePlans: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  useOfProceeds: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  imageSale: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  imageToken: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  contactEmail: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const SaleInformationUncheckedUpdateManyInputSchema: z.ZodType<Prisma.SaleInformationUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  summary: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenUtility: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenDistribution: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  otherInformation: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenLifecycle: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  liquidityPool: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  futurePlans: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  useOfProceeds: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  imageSale: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  imageToken: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  contactEmail: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  saleId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const SaleTransactionsCreateInputSchema: z.ZodType<Prisma.SaleTransactionsCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  tokenSymbol: z.string(),
  quantity: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rawPrice: z.string(),
  price: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  totalAmount: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  formOfPayment: z.lazy(() => FOPSchema),
  confirmationId: z.string().optional().nullable(),
  receivingWallet: z.string().optional().nullable(),
  status: z.lazy(() => TransactionStatusSchema).optional(),
  comment: z.string().optional().nullable(),
  amountPaid: z.string(),
  amountPaidCurrency: z.lazy(() => CurrencySchema),
  txHash: z.string().optional().nullable(),
  agreementId: z.string().optional().nullable(),
  rejectionReason: z.string().optional().nullable(),
  paymentEvidence: z.string().optional().nullable(),
  paymentDate: z.coerce.date().optional().nullable(),
  user: z.lazy(() => UserCreateNestedOneWithoutTransactionsInputSchema),
  sale: z.lazy(() => SaleCreateNestedOneWithoutTransactionsInputSchema),
  blockchain: z.lazy(() => BlockchainCreateNestedOneWithoutTransactionsInputSchema).optional(),
  approver: z.lazy(() => UserCreateNestedOneWithoutTransactionApprovalsInputSchema).optional(),
  auditTrail: z.lazy(() => TransactionAuditCreateNestedManyWithoutTransactionInputSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionCreateNestedManyWithoutTransactionInputSchema).optional()
}).strict();

export const SaleTransactionsUncheckedCreateInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  tokenSymbol: z.string(),
  quantity: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rawPrice: z.string(),
  price: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  totalAmount: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  formOfPayment: z.lazy(() => FOPSchema),
  confirmationId: z.string().optional().nullable(),
  receivingWallet: z.string().optional().nullable(),
  status: z.lazy(() => TransactionStatusSchema).optional(),
  userId: z.string(),
  saleId: z.string(),
  comment: z.string().optional().nullable(),
  amountPaid: z.string(),
  amountPaidCurrency: z.lazy(() => CurrencySchema),
  txHash: z.string().optional().nullable(),
  blockchainId: z.string().optional().nullable(),
  agreementId: z.string().optional().nullable(),
  approvedBy: z.string().optional().nullable(),
  rejectionReason: z.string().optional().nullable(),
  paymentEvidence: z.string().optional().nullable(),
  paymentDate: z.coerce.date().optional().nullable(),
  auditTrail: z.lazy(() => TransactionAuditUncheckedCreateNestedManyWithoutTransactionInputSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionUncheckedCreateNestedManyWithoutTransactionInputSchema).optional()
}).strict();

export const SaleTransactionsUpdateInputSchema: z.ZodType<Prisma.SaleTransactionsUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  quantity: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rawPrice: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  price: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  totalAmount: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  formOfPayment: z.union([ z.lazy(() => FOPSchema),z.lazy(() => EnumFOPFieldUpdateOperationsInputSchema) ]).optional(),
  confirmationId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  receivingWallet: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amountPaid: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  amountPaidCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  agreementId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentEvidence: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentDate: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutTransactionsNestedInputSchema).optional(),
  sale: z.lazy(() => SaleUpdateOneRequiredWithoutTransactionsNestedInputSchema).optional(),
  blockchain: z.lazy(() => BlockchainUpdateOneWithoutTransactionsNestedInputSchema).optional(),
  approver: z.lazy(() => UserUpdateOneWithoutTransactionApprovalsNestedInputSchema).optional(),
  auditTrail: z.lazy(() => TransactionAuditUpdateManyWithoutTransactionNestedInputSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionUpdateManyWithoutTransactionNestedInputSchema).optional()
}).strict();

export const SaleTransactionsUncheckedUpdateInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  quantity: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rawPrice: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  price: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  totalAmount: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  formOfPayment: z.union([ z.lazy(() => FOPSchema),z.lazy(() => EnumFOPFieldUpdateOperationsInputSchema) ]).optional(),
  confirmationId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  receivingWallet: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amountPaid: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  amountPaidCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  blockchainId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  agreementId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  approvedBy: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentEvidence: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentDate: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  auditTrail: z.lazy(() => TransactionAuditUncheckedUpdateManyWithoutTransactionNestedInputSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionUncheckedUpdateManyWithoutTransactionNestedInputSchema).optional()
}).strict();

export const SaleTransactionsCreateManyInputSchema: z.ZodType<Prisma.SaleTransactionsCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  tokenSymbol: z.string(),
  quantity: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rawPrice: z.string(),
  price: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  totalAmount: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  formOfPayment: z.lazy(() => FOPSchema),
  confirmationId: z.string().optional().nullable(),
  receivingWallet: z.string().optional().nullable(),
  status: z.lazy(() => TransactionStatusSchema).optional(),
  userId: z.string(),
  saleId: z.string(),
  comment: z.string().optional().nullable(),
  amountPaid: z.string(),
  amountPaidCurrency: z.lazy(() => CurrencySchema),
  txHash: z.string().optional().nullable(),
  blockchainId: z.string().optional().nullable(),
  agreementId: z.string().optional().nullable(),
  approvedBy: z.string().optional().nullable(),
  rejectionReason: z.string().optional().nullable(),
  paymentEvidence: z.string().optional().nullable(),
  paymentDate: z.coerce.date().optional().nullable()
}).strict();

export const SaleTransactionsUpdateManyMutationInputSchema: z.ZodType<Prisma.SaleTransactionsUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  quantity: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rawPrice: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  price: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  totalAmount: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  formOfPayment: z.union([ z.lazy(() => FOPSchema),z.lazy(() => EnumFOPFieldUpdateOperationsInputSchema) ]).optional(),
  confirmationId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  receivingWallet: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amountPaid: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  amountPaidCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  agreementId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentEvidence: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentDate: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const SaleTransactionsUncheckedUpdateManyInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  quantity: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rawPrice: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  price: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  totalAmount: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  formOfPayment: z.union([ z.lazy(() => FOPSchema),z.lazy(() => EnumFOPFieldUpdateOperationsInputSchema) ]).optional(),
  confirmationId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  receivingWallet: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amountPaid: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  amountPaidCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  blockchainId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  agreementId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  approvedBy: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentEvidence: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentDate: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const BlockchainCreateInputSchema: z.ZodType<Prisma.BlockchainCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  chainId: z.number().int(),
  rpcUrl: z.string(),
  explorerUrl: z.string().optional().nullable(),
  isTestnet: z.boolean().optional(),
  isEnabled: z.boolean().optional(),
  transactions: z.lazy(() => SaleTransactionsCreateNestedManyWithoutBlockchainInputSchema).optional(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsCreateNestedManyWithoutBlockchainInputSchema).optional(),
  Sale: z.lazy(() => SaleCreateNestedManyWithoutBlockchainInputSchema).optional()
}).strict();

export const BlockchainUncheckedCreateInputSchema: z.ZodType<Prisma.BlockchainUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  chainId: z.number().int(),
  rpcUrl: z.string(),
  explorerUrl: z.string().optional().nullable(),
  isTestnet: z.boolean().optional(),
  isEnabled: z.boolean().optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutBlockchainInputSchema).optional(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsUncheckedCreateNestedManyWithoutBlockchainInputSchema).optional(),
  Sale: z.lazy(() => SaleUncheckedCreateNestedManyWithoutBlockchainInputSchema).optional()
}).strict();

export const BlockchainUpdateInputSchema: z.ZodType<Prisma.BlockchainUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  chainId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  rpcUrl: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  explorerUrl: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isTestnet: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  isEnabled: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  transactions: z.lazy(() => SaleTransactionsUpdateManyWithoutBlockchainNestedInputSchema).optional(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsUpdateManyWithoutBlockchainNestedInputSchema).optional(),
  Sale: z.lazy(() => SaleUpdateManyWithoutBlockchainNestedInputSchema).optional()
}).strict();

export const BlockchainUncheckedUpdateInputSchema: z.ZodType<Prisma.BlockchainUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  chainId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  rpcUrl: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  explorerUrl: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isTestnet: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  isEnabled: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutBlockchainNestedInputSchema).optional(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsUncheckedUpdateManyWithoutBlockchainNestedInputSchema).optional(),
  Sale: z.lazy(() => SaleUncheckedUpdateManyWithoutBlockchainNestedInputSchema).optional()
}).strict();

export const BlockchainCreateManyInputSchema: z.ZodType<Prisma.BlockchainCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  chainId: z.number().int(),
  rpcUrl: z.string(),
  explorerUrl: z.string().optional().nullable(),
  isTestnet: z.boolean().optional(),
  isEnabled: z.boolean().optional()
}).strict();

export const BlockchainUpdateManyMutationInputSchema: z.ZodType<Prisma.BlockchainUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  chainId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  rpcUrl: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  explorerUrl: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isTestnet: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  isEnabled: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const BlockchainUncheckedUpdateManyInputSchema: z.ZodType<Prisma.BlockchainUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  chainId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  rpcUrl: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  explorerUrl: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isTestnet: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  isEnabled: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const ContractStatusCreateInputSchema: z.ZodType<Prisma.ContractStatusCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  userId: z.string(),
  saleId: z.string(),
  contractId: z.string(),
  status: z.lazy(() => ContractSignatureStatusSchema)
}).strict();

export const ContractStatusUncheckedCreateInputSchema: z.ZodType<Prisma.ContractStatusUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  userId: z.string(),
  saleId: z.string(),
  contractId: z.string(),
  status: z.lazy(() => ContractSignatureStatusSchema)
}).strict();

export const ContractStatusUpdateInputSchema: z.ZodType<Prisma.ContractStatusUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  contractId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => ContractSignatureStatusSchema),z.lazy(() => EnumContractSignatureStatusFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const ContractStatusUncheckedUpdateInputSchema: z.ZodType<Prisma.ContractStatusUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  contractId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => ContractSignatureStatusSchema),z.lazy(() => EnumContractSignatureStatusFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const ContractStatusCreateManyInputSchema: z.ZodType<Prisma.ContractStatusCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  userId: z.string(),
  saleId: z.string(),
  contractId: z.string(),
  status: z.lazy(() => ContractSignatureStatusSchema)
}).strict();

export const ContractStatusUpdateManyMutationInputSchema: z.ZodType<Prisma.ContractStatusUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  contractId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => ContractSignatureStatusSchema),z.lazy(() => EnumContractSignatureStatusFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const ContractStatusUncheckedUpdateManyInputSchema: z.ZodType<Prisma.ContractStatusUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  contractId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => ContractSignatureStatusSchema),z.lazy(() => EnumContractSignatureStatusFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const TransactionAuditCreateInputSchema: z.ZodType<Prisma.TransactionAuditCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  actionType: z.string(),
  fromStatus: z.lazy(() => TransactionStatusSchema),
  toStatus: z.lazy(() => TransactionStatusSchema),
  comment: z.string().optional().nullable(),
  transaction: z.lazy(() => SaleTransactionsCreateNestedOneWithoutAuditTrailInputSchema),
  admin: z.lazy(() => UserCreateNestedOneWithoutTransactionAuditInputSchema)
}).strict();

export const TransactionAuditUncheckedCreateInputSchema: z.ZodType<Prisma.TransactionAuditUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  transactionId: z.string(),
  actionType: z.string(),
  fromStatus: z.lazy(() => TransactionStatusSchema),
  toStatus: z.lazy(() => TransactionStatusSchema),
  performedBy: z.string(),
  comment: z.string().optional().nullable()
}).strict();

export const TransactionAuditUpdateInputSchema: z.ZodType<Prisma.TransactionAuditUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  actionType: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  fromStatus: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  toStatus: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  transaction: z.lazy(() => SaleTransactionsUpdateOneRequiredWithoutAuditTrailNestedInputSchema).optional(),
  admin: z.lazy(() => UserUpdateOneRequiredWithoutTransactionAuditNestedInputSchema).optional()
}).strict();

export const TransactionAuditUncheckedUpdateInputSchema: z.ZodType<Prisma.TransactionAuditUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  transactionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  actionType: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  fromStatus: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  toStatus: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  performedBy: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const TransactionAuditCreateManyInputSchema: z.ZodType<Prisma.TransactionAuditCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  transactionId: z.string(),
  actionType: z.string(),
  fromStatus: z.lazy(() => TransactionStatusSchema),
  toStatus: z.lazy(() => TransactionStatusSchema),
  performedBy: z.string(),
  comment: z.string().optional().nullable()
}).strict();

export const TransactionAuditUpdateManyMutationInputSchema: z.ZodType<Prisma.TransactionAuditUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  actionType: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  fromStatus: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  toStatus: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const TransactionAuditUncheckedUpdateManyInputSchema: z.ZodType<Prisma.TransactionAuditUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  transactionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  actionType: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  fromStatus: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  toStatus: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  performedBy: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const KycVerificationCreateInputSchema: z.ZodType<Prisma.KycVerificationCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  status: z.lazy(() => KycStatusSchema).optional(),
  documentType: z.string().optional().nullable(),
  documentNumber: z.string().optional().nullable(),
  verifiedAt: z.coerce.date().optional().nullable(),
  rejectionReason: z.string().optional().nullable(),
  user: z.lazy(() => UserCreateNestedOneWithoutKycVerificationInputSchema)
}).strict();

export const KycVerificationUncheckedCreateInputSchema: z.ZodType<Prisma.KycVerificationUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  userId: z.string(),
  status: z.lazy(() => KycStatusSchema).optional(),
  documentType: z.string().optional().nullable(),
  documentNumber: z.string().optional().nullable(),
  verifiedAt: z.coerce.date().optional().nullable(),
  rejectionReason: z.string().optional().nullable()
}).strict();

export const KycVerificationUpdateInputSchema: z.ZodType<Prisma.KycVerificationUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.lazy(() => KycStatusSchema),z.lazy(() => EnumKycStatusFieldUpdateOperationsInputSchema) ]).optional(),
  documentType: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  documentNumber: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  verifiedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutKycVerificationNestedInputSchema).optional()
}).strict();

export const KycVerificationUncheckedUpdateInputSchema: z.ZodType<Prisma.KycVerificationUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => KycStatusSchema),z.lazy(() => EnumKycStatusFieldUpdateOperationsInputSchema) ]).optional(),
  documentType: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  documentNumber: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  verifiedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const KycVerificationCreateManyInputSchema: z.ZodType<Prisma.KycVerificationCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  userId: z.string(),
  status: z.lazy(() => KycStatusSchema).optional(),
  documentType: z.string().optional().nullable(),
  documentNumber: z.string().optional().nullable(),
  verifiedAt: z.coerce.date().optional().nullable(),
  rejectionReason: z.string().optional().nullable()
}).strict();

export const KycVerificationUpdateManyMutationInputSchema: z.ZodType<Prisma.KycVerificationUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.lazy(() => KycStatusSchema),z.lazy(() => EnumKycStatusFieldUpdateOperationsInputSchema) ]).optional(),
  documentType: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  documentNumber: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  verifiedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const KycVerificationUncheckedUpdateManyInputSchema: z.ZodType<Prisma.KycVerificationUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => KycStatusSchema),z.lazy(() => EnumKycStatusFieldUpdateOperationsInputSchema) ]).optional(),
  documentType: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  documentNumber: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  verifiedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const RoleCreateInputSchema: z.ZodType<Prisma.RoleCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  description: z.string().optional().nullable(),
  users: z.lazy(() => UserRoleCreateNestedManyWithoutRoleInputSchema).optional()
}).strict();

export const RoleUncheckedCreateInputSchema: z.ZodType<Prisma.RoleUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  description: z.string().optional().nullable(),
  users: z.lazy(() => UserRoleUncheckedCreateNestedManyWithoutRoleInputSchema).optional()
}).strict();

export const RoleUpdateInputSchema: z.ZodType<Prisma.RoleUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  description: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  users: z.lazy(() => UserRoleUpdateManyWithoutRoleNestedInputSchema).optional()
}).strict();

export const RoleUncheckedUpdateInputSchema: z.ZodType<Prisma.RoleUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  description: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  users: z.lazy(() => UserRoleUncheckedUpdateManyWithoutRoleNestedInputSchema).optional()
}).strict();

export const RoleCreateManyInputSchema: z.ZodType<Prisma.RoleCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  description: z.string().optional().nullable()
}).strict();

export const RoleUpdateManyMutationInputSchema: z.ZodType<Prisma.RoleUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  description: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const RoleUncheckedUpdateManyInputSchema: z.ZodType<Prisma.RoleUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  description: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const UserRoleCreateInputSchema: z.ZodType<Prisma.UserRoleCreateInput> = z.object({
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  user: z.lazy(() => UserCreateNestedOneWithoutUserRoleInputSchema),
  role: z.lazy(() => RoleCreateNestedOneWithoutUsersInputSchema)
}).strict();

export const UserRoleUncheckedCreateInputSchema: z.ZodType<Prisma.UserRoleUncheckedCreateInput> = z.object({
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  userId: z.string(),
  roleId: z.string()
}).strict();

export const UserRoleUpdateInputSchema: z.ZodType<Prisma.UserRoleUpdateInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutUserRoleNestedInputSchema).optional(),
  role: z.lazy(() => RoleUpdateOneRequiredWithoutUsersNestedInputSchema).optional()
}).strict();

export const UserRoleUncheckedUpdateInputSchema: z.ZodType<Prisma.UserRoleUncheckedUpdateInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  roleId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const UserRoleCreateManyInputSchema: z.ZodType<Prisma.UserRoleCreateManyInput> = z.object({
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  userId: z.string(),
  roleId: z.string()
}).strict();

export const UserRoleUpdateManyMutationInputSchema: z.ZodType<Prisma.UserRoleUpdateManyMutationInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const UserRoleUncheckedUpdateManyInputSchema: z.ZodType<Prisma.UserRoleUncheckedUpdateManyInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  roleId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const TokenCreateInputSchema: z.ZodType<Prisma.TokenCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  symbol: z.string(),
  totalSupply: z.string().optional().nullable(),
  image: z.string().optional().nullable(),
  sales: z.lazy(() => SaleCreateNestedManyWithoutTokenInputSchema).optional(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsCreateNestedManyWithoutTokenInputSchema).optional()
}).strict();

export const TokenUncheckedCreateInputSchema: z.ZodType<Prisma.TokenUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  symbol: z.string(),
  totalSupply: z.string().optional().nullable(),
  image: z.string().optional().nullable(),
  sales: z.lazy(() => SaleUncheckedCreateNestedManyWithoutTokenInputSchema).optional(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsUncheckedCreateNestedManyWithoutTokenInputSchema).optional()
}).strict();

export const TokenUpdateInputSchema: z.ZodType<Prisma.TokenUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  symbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  totalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sales: z.lazy(() => SaleUpdateManyWithoutTokenNestedInputSchema).optional(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsUpdateManyWithoutTokenNestedInputSchema).optional()
}).strict();

export const TokenUncheckedUpdateInputSchema: z.ZodType<Prisma.TokenUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  symbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  totalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sales: z.lazy(() => SaleUncheckedUpdateManyWithoutTokenNestedInputSchema).optional(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsUncheckedUpdateManyWithoutTokenNestedInputSchema).optional()
}).strict();

export const TokenCreateManyInputSchema: z.ZodType<Prisma.TokenCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  symbol: z.string(),
  totalSupply: z.string().optional().nullable(),
  image: z.string().optional().nullable()
}).strict();

export const TokenUpdateManyMutationInputSchema: z.ZodType<Prisma.TokenUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  symbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  totalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const TokenUncheckedUpdateManyInputSchema: z.ZodType<Prisma.TokenUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  symbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  totalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const TokensOnBlockchainsCreateInputSchema: z.ZodType<Prisma.TokensOnBlockchainsCreateInput> = z.object({
  id: z.string().cuid().optional(),
  tokenSymbol: z.string(),
  name: z.string(),
  isNative: z.boolean().optional(),
  decimals: z.number().int(),
  contractAddress: z.string().optional().nullable(),
  token: z.lazy(() => TokenCreateNestedOneWithoutTokensOnBlockchainsInputSchema),
  blockchain: z.lazy(() => BlockchainCreateNestedOneWithoutTokensOnBlockchainsInputSchema)
}).strict();

export const TokensOnBlockchainsUncheckedCreateInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUncheckedCreateInput> = z.object({
  id: z.string().cuid().optional(),
  tokenId: z.string(),
  tokenSymbol: z.string(),
  blockchainId: z.string(),
  name: z.string(),
  isNative: z.boolean().optional(),
  decimals: z.number().int(),
  contractAddress: z.string().optional().nullable()
}).strict();

export const TokensOnBlockchainsUpdateInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  isNative: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  decimals: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  contractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  token: z.lazy(() => TokenUpdateOneRequiredWithoutTokensOnBlockchainsNestedInputSchema).optional(),
  blockchain: z.lazy(() => BlockchainUpdateOneRequiredWithoutTokensOnBlockchainsNestedInputSchema).optional()
}).strict();

export const TokensOnBlockchainsUncheckedUpdateInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUncheckedUpdateInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  blockchainId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  isNative: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  decimals: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  contractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const TokensOnBlockchainsCreateManyInputSchema: z.ZodType<Prisma.TokensOnBlockchainsCreateManyInput> = z.object({
  id: z.string().cuid().optional(),
  tokenId: z.string(),
  tokenSymbol: z.string(),
  blockchainId: z.string(),
  name: z.string(),
  isNative: z.boolean().optional(),
  decimals: z.number().int(),
  contractAddress: z.string().optional().nullable()
}).strict();

export const TokensOnBlockchainsUpdateManyMutationInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUpdateManyMutationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  isNative: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  decimals: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  contractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const TokensOnBlockchainsUncheckedUpdateManyInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUncheckedUpdateManyInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  blockchainId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  isNative: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  decimals: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  contractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const StringFilterSchema: z.ZodType<Prisma.StringFilter> = z.object({
  equals: z.string().optional(),
  in: z.string().array().optional(),
  notIn: z.string().array().optional(),
  lt: z.string().optional(),
  lte: z.string().optional(),
  gt: z.string().optional(),
  gte: z.string().optional(),
  contains: z.string().optional(),
  startsWith: z.string().optional(),
  endsWith: z.string().optional(),
  mode: z.lazy(() => QueryModeSchema).optional(),
  not: z.union([ z.string(),z.lazy(() => NestedStringFilterSchema) ]).optional(),
}).strict();

export const StringNullableFilterSchema: z.ZodType<Prisma.StringNullableFilter> = z.object({
  equals: z.string().optional().nullable(),
  in: z.string().array().optional().nullable(),
  notIn: z.string().array().optional().nullable(),
  lt: z.string().optional(),
  lte: z.string().optional(),
  gt: z.string().optional(),
  gte: z.string().optional(),
  contains: z.string().optional(),
  startsWith: z.string().optional(),
  endsWith: z.string().optional(),
  mode: z.lazy(() => QueryModeSchema).optional(),
  not: z.union([ z.string(),z.lazy(() => NestedStringNullableFilterSchema) ]).optional().nullable(),
}).strict();

export const DateTimeFilterSchema: z.ZodType<Prisma.DateTimeFilter> = z.object({
  equals: z.coerce.date().optional(),
  in: z.coerce.date().array().optional(),
  notIn: z.coerce.date().array().optional(),
  lt: z.coerce.date().optional(),
  lte: z.coerce.date().optional(),
  gt: z.coerce.date().optional(),
  gte: z.coerce.date().optional(),
  not: z.union([ z.coerce.date(),z.lazy(() => NestedDateTimeFilterSchema) ]).optional(),
}).strict();

export const DateTimeNullableFilterSchema: z.ZodType<Prisma.DateTimeNullableFilter> = z.object({
  equals: z.coerce.date().optional().nullable(),
  in: z.coerce.date().array().optional().nullable(),
  notIn: z.coerce.date().array().optional().nullable(),
  lt: z.coerce.date().optional(),
  lte: z.coerce.date().optional(),
  gt: z.coerce.date().optional(),
  gte: z.coerce.date().optional(),
  not: z.union([ z.coerce.date(),z.lazy(() => NestedDateTimeNullableFilterSchema) ]).optional().nullable(),
}).strict();

export const BoolFilterSchema: z.ZodType<Prisma.BoolFilter> = z.object({
  equals: z.boolean().optional(),
  not: z.union([ z.boolean(),z.lazy(() => NestedBoolFilterSchema) ]).optional(),
}).strict();

export const BoolNullableFilterSchema: z.ZodType<Prisma.BoolNullableFilter> = z.object({
  equals: z.boolean().optional().nullable(),
  not: z.union([ z.boolean(),z.lazy(() => NestedBoolNullableFilterSchema) ]).optional().nullable(),
}).strict();

export const ProfileNullableScalarRelationFilterSchema: z.ZodType<Prisma.ProfileNullableScalarRelationFilter> = z.object({
  is: z.lazy(() => ProfileWhereInputSchema).optional().nullable(),
  isNot: z.lazy(() => ProfileWhereInputSchema).optional().nullable()
}).strict();

export const SaleListRelationFilterSchema: z.ZodType<Prisma.SaleListRelationFilter> = z.object({
  every: z.lazy(() => SaleWhereInputSchema).optional(),
  some: z.lazy(() => SaleWhereInputSchema).optional(),
  none: z.lazy(() => SaleWhereInputSchema).optional()
}).strict();

export const UserRoleListRelationFilterSchema: z.ZodType<Prisma.UserRoleListRelationFilter> = z.object({
  every: z.lazy(() => UserRoleWhereInputSchema).optional(),
  some: z.lazy(() => UserRoleWhereInputSchema).optional(),
  none: z.lazy(() => UserRoleWhereInputSchema).optional()
}).strict();

export const TransactionAuditListRelationFilterSchema: z.ZodType<Prisma.TransactionAuditListRelationFilter> = z.object({
  every: z.lazy(() => TransactionAuditWhereInputSchema).optional(),
  some: z.lazy(() => TransactionAuditWhereInputSchema).optional(),
  none: z.lazy(() => TransactionAuditWhereInputSchema).optional()
}).strict();

export const KycVerificationNullableScalarRelationFilterSchema: z.ZodType<Prisma.KycVerificationNullableScalarRelationFilter> = z.object({
  is: z.lazy(() => KycVerificationWhereInputSchema).optional().nullable(),
  isNot: z.lazy(() => KycVerificationWhereInputSchema).optional().nullable()
}).strict();

export const SessionListRelationFilterSchema: z.ZodType<Prisma.SessionListRelationFilter> = z.object({
  every: z.lazy(() => SessionWhereInputSchema).optional(),
  some: z.lazy(() => SessionWhereInputSchema).optional(),
  none: z.lazy(() => SessionWhereInputSchema).optional()
}).strict();

export const SaleTransactionsListRelationFilterSchema: z.ZodType<Prisma.SaleTransactionsListRelationFilter> = z.object({
  every: z.lazy(() => SaleTransactionsWhereInputSchema).optional(),
  some: z.lazy(() => SaleTransactionsWhereInputSchema).optional(),
  none: z.lazy(() => SaleTransactionsWhereInputSchema).optional()
}).strict();

export const DocumentListRelationFilterSchema: z.ZodType<Prisma.DocumentListRelationFilter> = z.object({
  every: z.lazy(() => DocumentWhereInputSchema).optional(),
  some: z.lazy(() => DocumentWhereInputSchema).optional(),
  none: z.lazy(() => DocumentWhereInputSchema).optional()
}).strict();

export const WalletAddressListRelationFilterSchema: z.ZodType<Prisma.WalletAddressListRelationFilter> = z.object({
  every: z.lazy(() => WalletAddressWhereInputSchema).optional(),
  some: z.lazy(() => WalletAddressWhereInputSchema).optional(),
  none: z.lazy(() => WalletAddressWhereInputSchema).optional()
}).strict();

export const SortOrderInputSchema: z.ZodType<Prisma.SortOrderInput> = z.object({
  sort: z.lazy(() => SortOrderSchema),
  nulls: z.lazy(() => NullsOrderSchema).optional()
}).strict();

export const SaleOrderByRelationAggregateInputSchema: z.ZodType<Prisma.SaleOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const UserRoleOrderByRelationAggregateInputSchema: z.ZodType<Prisma.UserRoleOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TransactionAuditOrderByRelationAggregateInputSchema: z.ZodType<Prisma.TransactionAuditOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const SessionOrderByRelationAggregateInputSchema: z.ZodType<Prisma.SessionOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const SaleTransactionsOrderByRelationAggregateInputSchema: z.ZodType<Prisma.SaleTransactionsOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const DocumentOrderByRelationAggregateInputSchema: z.ZodType<Prisma.DocumentOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const WalletAddressOrderByRelationAggregateInputSchema: z.ZodType<Prisma.WalletAddressOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const UserCountOrderByAggregateInputSchema: z.ZodType<Prisma.UserCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  externalId: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  walletAddress: z.lazy(() => SortOrderSchema).optional(),
  email: z.lazy(() => SortOrderSchema).optional(),
  emailVerified: z.lazy(() => SortOrderSchema).optional(),
  image: z.lazy(() => SortOrderSchema).optional(),
  isSiwe: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const UserMaxOrderByAggregateInputSchema: z.ZodType<Prisma.UserMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  externalId: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  walletAddress: z.lazy(() => SortOrderSchema).optional(),
  email: z.lazy(() => SortOrderSchema).optional(),
  emailVerified: z.lazy(() => SortOrderSchema).optional(),
  image: z.lazy(() => SortOrderSchema).optional(),
  isSiwe: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const UserMinOrderByAggregateInputSchema: z.ZodType<Prisma.UserMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  externalId: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  walletAddress: z.lazy(() => SortOrderSchema).optional(),
  email: z.lazy(() => SortOrderSchema).optional(),
  emailVerified: z.lazy(() => SortOrderSchema).optional(),
  image: z.lazy(() => SortOrderSchema).optional(),
  isSiwe: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const StringWithAggregatesFilterSchema: z.ZodType<Prisma.StringWithAggregatesFilter> = z.object({
  equals: z.string().optional(),
  in: z.string().array().optional(),
  notIn: z.string().array().optional(),
  lt: z.string().optional(),
  lte: z.string().optional(),
  gt: z.string().optional(),
  gte: z.string().optional(),
  contains: z.string().optional(),
  startsWith: z.string().optional(),
  endsWith: z.string().optional(),
  mode: z.lazy(() => QueryModeSchema).optional(),
  not: z.union([ z.string(),z.lazy(() => NestedStringWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedStringFilterSchema).optional(),
  _max: z.lazy(() => NestedStringFilterSchema).optional()
}).strict();

export const StringNullableWithAggregatesFilterSchema: z.ZodType<Prisma.StringNullableWithAggregatesFilter> = z.object({
  equals: z.string().optional().nullable(),
  in: z.string().array().optional().nullable(),
  notIn: z.string().array().optional().nullable(),
  lt: z.string().optional(),
  lte: z.string().optional(),
  gt: z.string().optional(),
  gte: z.string().optional(),
  contains: z.string().optional(),
  startsWith: z.string().optional(),
  endsWith: z.string().optional(),
  mode: z.lazy(() => QueryModeSchema).optional(),
  not: z.union([ z.string(),z.lazy(() => NestedStringNullableWithAggregatesFilterSchema) ]).optional().nullable(),
  _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _min: z.lazy(() => NestedStringNullableFilterSchema).optional(),
  _max: z.lazy(() => NestedStringNullableFilterSchema).optional()
}).strict();

export const DateTimeWithAggregatesFilterSchema: z.ZodType<Prisma.DateTimeWithAggregatesFilter> = z.object({
  equals: z.coerce.date().optional(),
  in: z.coerce.date().array().optional(),
  notIn: z.coerce.date().array().optional(),
  lt: z.coerce.date().optional(),
  lte: z.coerce.date().optional(),
  gt: z.coerce.date().optional(),
  gte: z.coerce.date().optional(),
  not: z.union([ z.coerce.date(),z.lazy(() => NestedDateTimeWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedDateTimeFilterSchema).optional(),
  _max: z.lazy(() => NestedDateTimeFilterSchema).optional()
}).strict();

export const DateTimeNullableWithAggregatesFilterSchema: z.ZodType<Prisma.DateTimeNullableWithAggregatesFilter> = z.object({
  equals: z.coerce.date().optional().nullable(),
  in: z.coerce.date().array().optional().nullable(),
  notIn: z.coerce.date().array().optional().nullable(),
  lt: z.coerce.date().optional(),
  lte: z.coerce.date().optional(),
  gt: z.coerce.date().optional(),
  gte: z.coerce.date().optional(),
  not: z.union([ z.coerce.date(),z.lazy(() => NestedDateTimeNullableWithAggregatesFilterSchema) ]).optional().nullable(),
  _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _min: z.lazy(() => NestedDateTimeNullableFilterSchema).optional(),
  _max: z.lazy(() => NestedDateTimeNullableFilterSchema).optional()
}).strict();

export const BoolWithAggregatesFilterSchema: z.ZodType<Prisma.BoolWithAggregatesFilter> = z.object({
  equals: z.boolean().optional(),
  not: z.union([ z.boolean(),z.lazy(() => NestedBoolWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedBoolFilterSchema).optional(),
  _max: z.lazy(() => NestedBoolFilterSchema).optional()
}).strict();

export const BoolNullableWithAggregatesFilterSchema: z.ZodType<Prisma.BoolNullableWithAggregatesFilter> = z.object({
  equals: z.boolean().optional().nullable(),
  not: z.union([ z.boolean(),z.lazy(() => NestedBoolNullableWithAggregatesFilterSchema) ]).optional().nullable(),
  _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _min: z.lazy(() => NestedBoolNullableFilterSchema).optional(),
  _max: z.lazy(() => NestedBoolNullableFilterSchema).optional()
}).strict();

export const IntFilterSchema: z.ZodType<Prisma.IntFilter> = z.object({
  equals: z.number().optional(),
  in: z.number().array().optional(),
  notIn: z.number().array().optional(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedIntFilterSchema) ]).optional(),
}).strict();

export const UserScalarRelationFilterSchema: z.ZodType<Prisma.UserScalarRelationFilter> = z.object({
  is: z.lazy(() => UserWhereInputSchema).optional(),
  isNot: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const WalletAddressWalletAddressChainIdCompoundUniqueInputSchema: z.ZodType<Prisma.WalletAddressWalletAddressChainIdCompoundUniqueInput> = z.object({
  walletAddress: z.string(),
  chainId: z.number()
}).strict();

export const WalletAddressCountOrderByAggregateInputSchema: z.ZodType<Prisma.WalletAddressCountOrderByAggregateInput> = z.object({
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  walletAddress: z.lazy(() => SortOrderSchema).optional(),
  chainId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const WalletAddressAvgOrderByAggregateInputSchema: z.ZodType<Prisma.WalletAddressAvgOrderByAggregateInput> = z.object({
  chainId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const WalletAddressMaxOrderByAggregateInputSchema: z.ZodType<Prisma.WalletAddressMaxOrderByAggregateInput> = z.object({
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  walletAddress: z.lazy(() => SortOrderSchema).optional(),
  chainId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const WalletAddressMinOrderByAggregateInputSchema: z.ZodType<Prisma.WalletAddressMinOrderByAggregateInput> = z.object({
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  walletAddress: z.lazy(() => SortOrderSchema).optional(),
  chainId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const WalletAddressSumOrderByAggregateInputSchema: z.ZodType<Prisma.WalletAddressSumOrderByAggregateInput> = z.object({
  chainId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const IntWithAggregatesFilterSchema: z.ZodType<Prisma.IntWithAggregatesFilter> = z.object({
  equals: z.number().optional(),
  in: z.number().array().optional(),
  notIn: z.number().array().optional(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedIntWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _avg: z.lazy(() => NestedFloatFilterSchema).optional(),
  _sum: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedIntFilterSchema).optional(),
  _max: z.lazy(() => NestedIntFilterSchema).optional()
}).strict();

export const SessionTokenUserIdCompoundUniqueInputSchema: z.ZodType<Prisma.SessionTokenUserIdCompoundUniqueInput> = z.object({
  token: z.string(),
  userId: z.string()
}).strict();

export const SessionCountOrderByAggregateInputSchema: z.ZodType<Prisma.SessionCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  expiresAt: z.lazy(() => SortOrderSchema).optional(),
  token: z.lazy(() => SortOrderSchema).optional(),
  ipAddress: z.lazy(() => SortOrderSchema).optional(),
  userAgent: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const SessionMaxOrderByAggregateInputSchema: z.ZodType<Prisma.SessionMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  expiresAt: z.lazy(() => SortOrderSchema).optional(),
  token: z.lazy(() => SortOrderSchema).optional(),
  ipAddress: z.lazy(() => SortOrderSchema).optional(),
  userAgent: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const SessionMinOrderByAggregateInputSchema: z.ZodType<Prisma.SessionMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  expiresAt: z.lazy(() => SortOrderSchema).optional(),
  token: z.lazy(() => SortOrderSchema).optional(),
  ipAddress: z.lazy(() => SortOrderSchema).optional(),
  userAgent: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const VerificationCountOrderByAggregateInputSchema: z.ZodType<Prisma.VerificationCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  expiresAt: z.lazy(() => SortOrderSchema).optional(),
  identifier: z.lazy(() => SortOrderSchema).optional(),
  value: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const VerificationMaxOrderByAggregateInputSchema: z.ZodType<Prisma.VerificationMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  expiresAt: z.lazy(() => SortOrderSchema).optional(),
  identifier: z.lazy(() => SortOrderSchema).optional(),
  value: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const VerificationMinOrderByAggregateInputSchema: z.ZodType<Prisma.VerificationMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  expiresAt: z.lazy(() => SortOrderSchema).optional(),
  identifier: z.lazy(() => SortOrderSchema).optional(),
  value: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const AddressNullableScalarRelationFilterSchema: z.ZodType<Prisma.AddressNullableScalarRelationFilter> = z.object({
  is: z.lazy(() => AddressWhereInputSchema).optional().nullable(),
  isNot: z.lazy(() => AddressWhereInputSchema).optional().nullable()
}).strict();

export const ProfileCountOrderByAggregateInputSchema: z.ZodType<Prisma.ProfileCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  firstName: z.lazy(() => SortOrderSchema).optional(),
  lastName: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  email: z.lazy(() => SortOrderSchema).optional(),
  phoneNumber: z.lazy(() => SortOrderSchema).optional(),
  dateOfBirth: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const ProfileMaxOrderByAggregateInputSchema: z.ZodType<Prisma.ProfileMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  firstName: z.lazy(() => SortOrderSchema).optional(),
  lastName: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  email: z.lazy(() => SortOrderSchema).optional(),
  phoneNumber: z.lazy(() => SortOrderSchema).optional(),
  dateOfBirth: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const ProfileMinOrderByAggregateInputSchema: z.ZodType<Prisma.ProfileMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  firstName: z.lazy(() => SortOrderSchema).optional(),
  lastName: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  email: z.lazy(() => SortOrderSchema).optional(),
  phoneNumber: z.lazy(() => SortOrderSchema).optional(),
  dateOfBirth: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const FloatNullableFilterSchema: z.ZodType<Prisma.FloatNullableFilter> = z.object({
  equals: z.number().optional().nullable(),
  in: z.number().array().optional().nullable(),
  notIn: z.number().array().optional().nullable(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedFloatNullableFilterSchema) ]).optional().nullable(),
}).strict();

export const AddressCountOrderByAggregateInputSchema: z.ZodType<Prisma.AddressCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  city: z.lazy(() => SortOrderSchema).optional(),
  zipCode: z.lazy(() => SortOrderSchema).optional(),
  country: z.lazy(() => SortOrderSchema).optional(),
  state: z.lazy(() => SortOrderSchema).optional(),
  street: z.lazy(() => SortOrderSchema).optional(),
  formattedAddress: z.lazy(() => SortOrderSchema).optional(),
  latitude: z.lazy(() => SortOrderSchema).optional(),
  longitude: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const AddressAvgOrderByAggregateInputSchema: z.ZodType<Prisma.AddressAvgOrderByAggregateInput> = z.object({
  latitude: z.lazy(() => SortOrderSchema).optional(),
  longitude: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const AddressMaxOrderByAggregateInputSchema: z.ZodType<Prisma.AddressMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  city: z.lazy(() => SortOrderSchema).optional(),
  zipCode: z.lazy(() => SortOrderSchema).optional(),
  country: z.lazy(() => SortOrderSchema).optional(),
  state: z.lazy(() => SortOrderSchema).optional(),
  street: z.lazy(() => SortOrderSchema).optional(),
  formattedAddress: z.lazy(() => SortOrderSchema).optional(),
  latitude: z.lazy(() => SortOrderSchema).optional(),
  longitude: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const AddressMinOrderByAggregateInputSchema: z.ZodType<Prisma.AddressMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  city: z.lazy(() => SortOrderSchema).optional(),
  zipCode: z.lazy(() => SortOrderSchema).optional(),
  country: z.lazy(() => SortOrderSchema).optional(),
  state: z.lazy(() => SortOrderSchema).optional(),
  street: z.lazy(() => SortOrderSchema).optional(),
  formattedAddress: z.lazy(() => SortOrderSchema).optional(),
  latitude: z.lazy(() => SortOrderSchema).optional(),
  longitude: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const AddressSumOrderByAggregateInputSchema: z.ZodType<Prisma.AddressSumOrderByAggregateInput> = z.object({
  latitude: z.lazy(() => SortOrderSchema).optional(),
  longitude: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const FloatNullableWithAggregatesFilterSchema: z.ZodType<Prisma.FloatNullableWithAggregatesFilter> = z.object({
  equals: z.number().optional().nullable(),
  in: z.number().array().optional().nullable(),
  notIn: z.number().array().optional().nullable(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedFloatNullableWithAggregatesFilterSchema) ]).optional().nullable(),
  _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _avg: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
  _sum: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
  _min: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
  _max: z.lazy(() => NestedFloatNullableFilterSchema).optional()
}).strict();

export const EnumSaleStatusFilterSchema: z.ZodType<Prisma.EnumSaleStatusFilter> = z.object({
  equals: z.lazy(() => SaleStatusSchema).optional(),
  in: z.lazy(() => SaleStatusSchema).array().optional(),
  notIn: z.lazy(() => SaleStatusSchema).array().optional(),
  not: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => NestedEnumSaleStatusFilterSchema) ]).optional(),
}).strict();

export const EnumCurrencyFilterSchema: z.ZodType<Prisma.EnumCurrencyFilter> = z.object({
  equals: z.lazy(() => CurrencySchema).optional(),
  in: z.lazy(() => CurrencySchema).array().optional(),
  notIn: z.lazy(() => CurrencySchema).array().optional(),
  not: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => NestedEnumCurrencyFilterSchema) ]).optional(),
}).strict();

export const IntNullableFilterSchema: z.ZodType<Prisma.IntNullableFilter> = z.object({
  equals: z.number().optional().nullable(),
  in: z.number().array().optional().nullable(),
  notIn: z.number().array().optional().nullable(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedIntNullableFilterSchema) ]).optional().nullable(),
}).strict();

export const DecimalFilterSchema: z.ZodType<Prisma.DecimalFilter> = z.object({
  equals: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  in: z.union([z.number().array(),z.string().array(),z.instanceof(Decimal).array(),z.instanceof(Prisma.Decimal).array(),DecimalJsLikeSchema.array(),]).refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), { message: 'Must be a Decimal' }).optional(),
  notIn: z.union([z.number().array(),z.string().array(),z.instanceof(Decimal).array(),z.instanceof(Prisma.Decimal).array(),DecimalJsLikeSchema.array(),]).refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), { message: 'Must be a Decimal' }).optional(),
  lt: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  lte: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  gt: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  gte: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  not: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NestedDecimalFilterSchema) ]).optional(),
}).strict();

export const BlockchainNullableScalarRelationFilterSchema: z.ZodType<Prisma.BlockchainNullableScalarRelationFilter> = z.object({
  is: z.lazy(() => BlockchainWhereInputSchema).optional().nullable(),
  isNot: z.lazy(() => BlockchainWhereInputSchema).optional().nullable()
}).strict();

export const SaleInformationNullableScalarRelationFilterSchema: z.ZodType<Prisma.SaleInformationNullableScalarRelationFilter> = z.object({
  is: z.lazy(() => SaleInformationWhereInputSchema).optional().nullable(),
  isNot: z.lazy(() => SaleInformationWhereInputSchema).optional().nullable()
}).strict();

export const TokenScalarRelationFilterSchema: z.ZodType<Prisma.TokenScalarRelationFilter> = z.object({
  is: z.lazy(() => TokenWhereInputSchema).optional(),
  isNot: z.lazy(() => TokenWhereInputSchema).optional()
}).strict();

export const VestingScheduleListRelationFilterSchema: z.ZodType<Prisma.VestingScheduleListRelationFilter> = z.object({
  every: z.lazy(() => VestingScheduleWhereInputSchema).optional(),
  some: z.lazy(() => VestingScheduleWhereInputSchema).optional(),
  none: z.lazy(() => VestingScheduleWhereInputSchema).optional()
}).strict();

export const VestingScheduleOrderByRelationAggregateInputSchema: z.ZodType<Prisma.VestingScheduleOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const SaleCountOrderByAggregateInputSchema: z.ZodType<Prisma.SaleCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  status: z.lazy(() => SortOrderSchema).optional(),
  saleCurrency: z.lazy(() => SortOrderSchema).optional(),
  initialTokenQuantity: z.lazy(() => SortOrderSchema).optional(),
  availableTokenQuantity: z.lazy(() => SortOrderSchema).optional(),
  maximumTokenBuyPerUser: z.lazy(() => SortOrderSchema).optional(),
  minimumTokenBuyPerUser: z.lazy(() => SortOrderSchema).optional(),
  saleStartDate: z.lazy(() => SortOrderSchema).optional(),
  tokenContractAddress: z.lazy(() => SortOrderSchema).optional(),
  tokenContractChainId: z.lazy(() => SortOrderSchema).optional(),
  tokenName: z.lazy(() => SortOrderSchema).optional(),
  tokenTotalSupply: z.lazy(() => SortOrderSchema).optional(),
  tokenPricePerUnit: z.lazy(() => SortOrderSchema).optional(),
  tokenSymbol: z.lazy(() => SortOrderSchema).optional(),
  toWalletsAddress: z.lazy(() => SortOrderSchema).optional(),
  saleClosingDate: z.lazy(() => SortOrderSchema).optional(),
  createdBy: z.lazy(() => SortOrderSchema).optional(),
  saftCheckbox: z.lazy(() => SortOrderSchema).optional(),
  saftContract: z.lazy(() => SortOrderSchema).optional(),
  tokenId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const SaleAvgOrderByAggregateInputSchema: z.ZodType<Prisma.SaleAvgOrderByAggregateInput> = z.object({
  initialTokenQuantity: z.lazy(() => SortOrderSchema).optional(),
  availableTokenQuantity: z.lazy(() => SortOrderSchema).optional(),
  maximumTokenBuyPerUser: z.lazy(() => SortOrderSchema).optional(),
  minimumTokenBuyPerUser: z.lazy(() => SortOrderSchema).optional(),
  tokenContractChainId: z.lazy(() => SortOrderSchema).optional(),
  tokenPricePerUnit: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const SaleMaxOrderByAggregateInputSchema: z.ZodType<Prisma.SaleMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  status: z.lazy(() => SortOrderSchema).optional(),
  saleCurrency: z.lazy(() => SortOrderSchema).optional(),
  initialTokenQuantity: z.lazy(() => SortOrderSchema).optional(),
  availableTokenQuantity: z.lazy(() => SortOrderSchema).optional(),
  maximumTokenBuyPerUser: z.lazy(() => SortOrderSchema).optional(),
  minimumTokenBuyPerUser: z.lazy(() => SortOrderSchema).optional(),
  saleStartDate: z.lazy(() => SortOrderSchema).optional(),
  tokenContractAddress: z.lazy(() => SortOrderSchema).optional(),
  tokenContractChainId: z.lazy(() => SortOrderSchema).optional(),
  tokenName: z.lazy(() => SortOrderSchema).optional(),
  tokenTotalSupply: z.lazy(() => SortOrderSchema).optional(),
  tokenPricePerUnit: z.lazy(() => SortOrderSchema).optional(),
  tokenSymbol: z.lazy(() => SortOrderSchema).optional(),
  toWalletsAddress: z.lazy(() => SortOrderSchema).optional(),
  saleClosingDate: z.lazy(() => SortOrderSchema).optional(),
  createdBy: z.lazy(() => SortOrderSchema).optional(),
  saftCheckbox: z.lazy(() => SortOrderSchema).optional(),
  saftContract: z.lazy(() => SortOrderSchema).optional(),
  tokenId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const SaleMinOrderByAggregateInputSchema: z.ZodType<Prisma.SaleMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  status: z.lazy(() => SortOrderSchema).optional(),
  saleCurrency: z.lazy(() => SortOrderSchema).optional(),
  initialTokenQuantity: z.lazy(() => SortOrderSchema).optional(),
  availableTokenQuantity: z.lazy(() => SortOrderSchema).optional(),
  maximumTokenBuyPerUser: z.lazy(() => SortOrderSchema).optional(),
  minimumTokenBuyPerUser: z.lazy(() => SortOrderSchema).optional(),
  saleStartDate: z.lazy(() => SortOrderSchema).optional(),
  tokenContractAddress: z.lazy(() => SortOrderSchema).optional(),
  tokenContractChainId: z.lazy(() => SortOrderSchema).optional(),
  tokenName: z.lazy(() => SortOrderSchema).optional(),
  tokenTotalSupply: z.lazy(() => SortOrderSchema).optional(),
  tokenPricePerUnit: z.lazy(() => SortOrderSchema).optional(),
  tokenSymbol: z.lazy(() => SortOrderSchema).optional(),
  toWalletsAddress: z.lazy(() => SortOrderSchema).optional(),
  saleClosingDate: z.lazy(() => SortOrderSchema).optional(),
  createdBy: z.lazy(() => SortOrderSchema).optional(),
  saftCheckbox: z.lazy(() => SortOrderSchema).optional(),
  saftContract: z.lazy(() => SortOrderSchema).optional(),
  tokenId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const SaleSumOrderByAggregateInputSchema: z.ZodType<Prisma.SaleSumOrderByAggregateInput> = z.object({
  initialTokenQuantity: z.lazy(() => SortOrderSchema).optional(),
  availableTokenQuantity: z.lazy(() => SortOrderSchema).optional(),
  maximumTokenBuyPerUser: z.lazy(() => SortOrderSchema).optional(),
  minimumTokenBuyPerUser: z.lazy(() => SortOrderSchema).optional(),
  tokenContractChainId: z.lazy(() => SortOrderSchema).optional(),
  tokenPricePerUnit: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const EnumSaleStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumSaleStatusWithAggregatesFilter> = z.object({
  equals: z.lazy(() => SaleStatusSchema).optional(),
  in: z.lazy(() => SaleStatusSchema).array().optional(),
  notIn: z.lazy(() => SaleStatusSchema).array().optional(),
  not: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => NestedEnumSaleStatusWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedEnumSaleStatusFilterSchema).optional(),
  _max: z.lazy(() => NestedEnumSaleStatusFilterSchema).optional()
}).strict();

export const EnumCurrencyWithAggregatesFilterSchema: z.ZodType<Prisma.EnumCurrencyWithAggregatesFilter> = z.object({
  equals: z.lazy(() => CurrencySchema).optional(),
  in: z.lazy(() => CurrencySchema).array().optional(),
  notIn: z.lazy(() => CurrencySchema).array().optional(),
  not: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => NestedEnumCurrencyWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedEnumCurrencyFilterSchema).optional(),
  _max: z.lazy(() => NestedEnumCurrencyFilterSchema).optional()
}).strict();

export const IntNullableWithAggregatesFilterSchema: z.ZodType<Prisma.IntNullableWithAggregatesFilter> = z.object({
  equals: z.number().optional().nullable(),
  in: z.number().array().optional().nullable(),
  notIn: z.number().array().optional().nullable(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedIntNullableWithAggregatesFilterSchema) ]).optional().nullable(),
  _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _avg: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
  _sum: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _min: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _max: z.lazy(() => NestedIntNullableFilterSchema).optional()
}).strict();

export const DecimalWithAggregatesFilterSchema: z.ZodType<Prisma.DecimalWithAggregatesFilter> = z.object({
  equals: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  in: z.union([z.number().array(),z.string().array(),z.instanceof(Decimal).array(),z.instanceof(Prisma.Decimal).array(),DecimalJsLikeSchema.array(),]).refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), { message: 'Must be a Decimal' }).optional(),
  notIn: z.union([z.number().array(),z.string().array(),z.instanceof(Decimal).array(),z.instanceof(Prisma.Decimal).array(),DecimalJsLikeSchema.array(),]).refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), { message: 'Must be a Decimal' }).optional(),
  lt: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  lte: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  gt: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  gte: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  not: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NestedDecimalWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _avg: z.lazy(() => NestedDecimalFilterSchema).optional(),
  _sum: z.lazy(() => NestedDecimalFilterSchema).optional(),
  _min: z.lazy(() => NestedDecimalFilterSchema).optional(),
  _max: z.lazy(() => NestedDecimalFilterSchema).optional()
}).strict();

export const SaleNullableScalarRelationFilterSchema: z.ZodType<Prisma.SaleNullableScalarRelationFilter> = z.object({
  is: z.lazy(() => SaleWhereInputSchema).optional().nullable(),
  isNot: z.lazy(() => SaleWhereInputSchema).optional().nullable()
}).strict();

export const UserNullableScalarRelationFilterSchema: z.ZodType<Prisma.UserNullableScalarRelationFilter> = z.object({
  is: z.lazy(() => UserWhereInputSchema).optional().nullable(),
  isNot: z.lazy(() => UserWhereInputSchema).optional().nullable()
}).strict();

export const DocumentCountOrderByAggregateInputSchema: z.ZodType<Prisma.DocumentCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  fileName: z.lazy(() => SortOrderSchema).optional(),
  url: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  saleId: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const DocumentMaxOrderByAggregateInputSchema: z.ZodType<Prisma.DocumentMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  fileName: z.lazy(() => SortOrderSchema).optional(),
  url: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  saleId: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const DocumentMinOrderByAggregateInputSchema: z.ZodType<Prisma.DocumentMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  fileName: z.lazy(() => SortOrderSchema).optional(),
  url: z.lazy(() => SortOrderSchema).optional(),
  type: z.lazy(() => SortOrderSchema).optional(),
  saleId: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const FloatFilterSchema: z.ZodType<Prisma.FloatFilter> = z.object({
  equals: z.number().optional(),
  in: z.number().array().optional(),
  notIn: z.number().array().optional(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedFloatFilterSchema) ]).optional(),
}).strict();

export const SaleScalarRelationFilterSchema: z.ZodType<Prisma.SaleScalarRelationFilter> = z.object({
  is: z.lazy(() => SaleWhereInputSchema).optional(),
  isNot: z.lazy(() => SaleWhereInputSchema).optional()
}).strict();

export const VestingScheduleCountOrderByAggregateInputSchema: z.ZodType<Prisma.VestingScheduleCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  saleId: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  cliffPeriod: z.lazy(() => SortOrderSchema).optional(),
  vestingPeriod: z.lazy(() => SortOrderSchema).optional(),
  releaseFrequency: z.lazy(() => SortOrderSchema).optional(),
  initialRelease: z.lazy(() => SortOrderSchema).optional(),
  isEnabled: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const VestingScheduleAvgOrderByAggregateInputSchema: z.ZodType<Prisma.VestingScheduleAvgOrderByAggregateInput> = z.object({
  cliffPeriod: z.lazy(() => SortOrderSchema).optional(),
  vestingPeriod: z.lazy(() => SortOrderSchema).optional(),
  releaseFrequency: z.lazy(() => SortOrderSchema).optional(),
  initialRelease: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const VestingScheduleMaxOrderByAggregateInputSchema: z.ZodType<Prisma.VestingScheduleMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  saleId: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  cliffPeriod: z.lazy(() => SortOrderSchema).optional(),
  vestingPeriod: z.lazy(() => SortOrderSchema).optional(),
  releaseFrequency: z.lazy(() => SortOrderSchema).optional(),
  initialRelease: z.lazy(() => SortOrderSchema).optional(),
  isEnabled: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const VestingScheduleMinOrderByAggregateInputSchema: z.ZodType<Prisma.VestingScheduleMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  saleId: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  cliffPeriod: z.lazy(() => SortOrderSchema).optional(),
  vestingPeriod: z.lazy(() => SortOrderSchema).optional(),
  releaseFrequency: z.lazy(() => SortOrderSchema).optional(),
  initialRelease: z.lazy(() => SortOrderSchema).optional(),
  isEnabled: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const VestingScheduleSumOrderByAggregateInputSchema: z.ZodType<Prisma.VestingScheduleSumOrderByAggregateInput> = z.object({
  cliffPeriod: z.lazy(() => SortOrderSchema).optional(),
  vestingPeriod: z.lazy(() => SortOrderSchema).optional(),
  releaseFrequency: z.lazy(() => SortOrderSchema).optional(),
  initialRelease: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const FloatWithAggregatesFilterSchema: z.ZodType<Prisma.FloatWithAggregatesFilter> = z.object({
  equals: z.number().optional(),
  in: z.number().array().optional(),
  notIn: z.number().array().optional(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedFloatWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _avg: z.lazy(() => NestedFloatFilterSchema).optional(),
  _sum: z.lazy(() => NestedFloatFilterSchema).optional(),
  _min: z.lazy(() => NestedFloatFilterSchema).optional(),
  _max: z.lazy(() => NestedFloatFilterSchema).optional()
}).strict();

export const SaleTransactionsScalarRelationFilterSchema: z.ZodType<Prisma.SaleTransactionsScalarRelationFilter> = z.object({
  is: z.lazy(() => SaleTransactionsWhereInputSchema).optional(),
  isNot: z.lazy(() => SaleTransactionsWhereInputSchema).optional()
}).strict();

export const TokenDistributionCountOrderByAggregateInputSchema: z.ZodType<Prisma.TokenDistributionCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  transactionId: z.lazy(() => SortOrderSchema).optional(),
  amount: z.lazy(() => SortOrderSchema).optional(),
  distributionDate: z.lazy(() => SortOrderSchema).optional(),
  txHash: z.lazy(() => SortOrderSchema).optional(),
  status: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TokenDistributionMaxOrderByAggregateInputSchema: z.ZodType<Prisma.TokenDistributionMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  transactionId: z.lazy(() => SortOrderSchema).optional(),
  amount: z.lazy(() => SortOrderSchema).optional(),
  distributionDate: z.lazy(() => SortOrderSchema).optional(),
  txHash: z.lazy(() => SortOrderSchema).optional(),
  status: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TokenDistributionMinOrderByAggregateInputSchema: z.ZodType<Prisma.TokenDistributionMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  transactionId: z.lazy(() => SortOrderSchema).optional(),
  amount: z.lazy(() => SortOrderSchema).optional(),
  distributionDate: z.lazy(() => SortOrderSchema).optional(),
  txHash: z.lazy(() => SortOrderSchema).optional(),
  status: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const SaleInformationCountOrderByAggregateInputSchema: z.ZodType<Prisma.SaleInformationCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  summary: z.lazy(() => SortOrderSchema).optional(),
  tokenUtility: z.lazy(() => SortOrderSchema).optional(),
  tokenDistribution: z.lazy(() => SortOrderSchema).optional(),
  otherInformation: z.lazy(() => SortOrderSchema).optional(),
  tokenLifecycle: z.lazy(() => SortOrderSchema).optional(),
  liquidityPool: z.lazy(() => SortOrderSchema).optional(),
  futurePlans: z.lazy(() => SortOrderSchema).optional(),
  useOfProceeds: z.lazy(() => SortOrderSchema).optional(),
  imageSale: z.lazy(() => SortOrderSchema).optional(),
  imageToken: z.lazy(() => SortOrderSchema).optional(),
  contactEmail: z.lazy(() => SortOrderSchema).optional(),
  saleId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const SaleInformationMaxOrderByAggregateInputSchema: z.ZodType<Prisma.SaleInformationMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  summary: z.lazy(() => SortOrderSchema).optional(),
  tokenUtility: z.lazy(() => SortOrderSchema).optional(),
  tokenDistribution: z.lazy(() => SortOrderSchema).optional(),
  otherInformation: z.lazy(() => SortOrderSchema).optional(),
  tokenLifecycle: z.lazy(() => SortOrderSchema).optional(),
  liquidityPool: z.lazy(() => SortOrderSchema).optional(),
  futurePlans: z.lazy(() => SortOrderSchema).optional(),
  useOfProceeds: z.lazy(() => SortOrderSchema).optional(),
  imageSale: z.lazy(() => SortOrderSchema).optional(),
  imageToken: z.lazy(() => SortOrderSchema).optional(),
  contactEmail: z.lazy(() => SortOrderSchema).optional(),
  saleId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const SaleInformationMinOrderByAggregateInputSchema: z.ZodType<Prisma.SaleInformationMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  summary: z.lazy(() => SortOrderSchema).optional(),
  tokenUtility: z.lazy(() => SortOrderSchema).optional(),
  tokenDistribution: z.lazy(() => SortOrderSchema).optional(),
  otherInformation: z.lazy(() => SortOrderSchema).optional(),
  tokenLifecycle: z.lazy(() => SortOrderSchema).optional(),
  liquidityPool: z.lazy(() => SortOrderSchema).optional(),
  futurePlans: z.lazy(() => SortOrderSchema).optional(),
  useOfProceeds: z.lazy(() => SortOrderSchema).optional(),
  imageSale: z.lazy(() => SortOrderSchema).optional(),
  imageToken: z.lazy(() => SortOrderSchema).optional(),
  contactEmail: z.lazy(() => SortOrderSchema).optional(),
  saleId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const EnumFOPFilterSchema: z.ZodType<Prisma.EnumFOPFilter> = z.object({
  equals: z.lazy(() => FOPSchema).optional(),
  in: z.lazy(() => FOPSchema).array().optional(),
  notIn: z.lazy(() => FOPSchema).array().optional(),
  not: z.union([ z.lazy(() => FOPSchema),z.lazy(() => NestedEnumFOPFilterSchema) ]).optional(),
}).strict();

export const EnumTransactionStatusFilterSchema: z.ZodType<Prisma.EnumTransactionStatusFilter> = z.object({
  equals: z.lazy(() => TransactionStatusSchema).optional(),
  in: z.lazy(() => TransactionStatusSchema).array().optional(),
  notIn: z.lazy(() => TransactionStatusSchema).array().optional(),
  not: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => NestedEnumTransactionStatusFilterSchema) ]).optional(),
}).strict();

export const TokenDistributionListRelationFilterSchema: z.ZodType<Prisma.TokenDistributionListRelationFilter> = z.object({
  every: z.lazy(() => TokenDistributionWhereInputSchema).optional(),
  some: z.lazy(() => TokenDistributionWhereInputSchema).optional(),
  none: z.lazy(() => TokenDistributionWhereInputSchema).optional()
}).strict();

export const TokenDistributionOrderByRelationAggregateInputSchema: z.ZodType<Prisma.TokenDistributionOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const SaleTransactionsCountOrderByAggregateInputSchema: z.ZodType<Prisma.SaleTransactionsCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  tokenSymbol: z.lazy(() => SortOrderSchema).optional(),
  quantity: z.lazy(() => SortOrderSchema).optional(),
  rawPrice: z.lazy(() => SortOrderSchema).optional(),
  price: z.lazy(() => SortOrderSchema).optional(),
  totalAmount: z.lazy(() => SortOrderSchema).optional(),
  formOfPayment: z.lazy(() => SortOrderSchema).optional(),
  confirmationId: z.lazy(() => SortOrderSchema).optional(),
  receivingWallet: z.lazy(() => SortOrderSchema).optional(),
  status: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  saleId: z.lazy(() => SortOrderSchema).optional(),
  comment: z.lazy(() => SortOrderSchema).optional(),
  amountPaid: z.lazy(() => SortOrderSchema).optional(),
  amountPaidCurrency: z.lazy(() => SortOrderSchema).optional(),
  txHash: z.lazy(() => SortOrderSchema).optional(),
  blockchainId: z.lazy(() => SortOrderSchema).optional(),
  agreementId: z.lazy(() => SortOrderSchema).optional(),
  approvedBy: z.lazy(() => SortOrderSchema).optional(),
  rejectionReason: z.lazy(() => SortOrderSchema).optional(),
  paymentEvidence: z.lazy(() => SortOrderSchema).optional(),
  paymentDate: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const SaleTransactionsAvgOrderByAggregateInputSchema: z.ZodType<Prisma.SaleTransactionsAvgOrderByAggregateInput> = z.object({
  quantity: z.lazy(() => SortOrderSchema).optional(),
  price: z.lazy(() => SortOrderSchema).optional(),
  totalAmount: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const SaleTransactionsMaxOrderByAggregateInputSchema: z.ZodType<Prisma.SaleTransactionsMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  tokenSymbol: z.lazy(() => SortOrderSchema).optional(),
  quantity: z.lazy(() => SortOrderSchema).optional(),
  rawPrice: z.lazy(() => SortOrderSchema).optional(),
  price: z.lazy(() => SortOrderSchema).optional(),
  totalAmount: z.lazy(() => SortOrderSchema).optional(),
  formOfPayment: z.lazy(() => SortOrderSchema).optional(),
  confirmationId: z.lazy(() => SortOrderSchema).optional(),
  receivingWallet: z.lazy(() => SortOrderSchema).optional(),
  status: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  saleId: z.lazy(() => SortOrderSchema).optional(),
  comment: z.lazy(() => SortOrderSchema).optional(),
  amountPaid: z.lazy(() => SortOrderSchema).optional(),
  amountPaidCurrency: z.lazy(() => SortOrderSchema).optional(),
  txHash: z.lazy(() => SortOrderSchema).optional(),
  blockchainId: z.lazy(() => SortOrderSchema).optional(),
  agreementId: z.lazy(() => SortOrderSchema).optional(),
  approvedBy: z.lazy(() => SortOrderSchema).optional(),
  rejectionReason: z.lazy(() => SortOrderSchema).optional(),
  paymentEvidence: z.lazy(() => SortOrderSchema).optional(),
  paymentDate: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const SaleTransactionsMinOrderByAggregateInputSchema: z.ZodType<Prisma.SaleTransactionsMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  tokenSymbol: z.lazy(() => SortOrderSchema).optional(),
  quantity: z.lazy(() => SortOrderSchema).optional(),
  rawPrice: z.lazy(() => SortOrderSchema).optional(),
  price: z.lazy(() => SortOrderSchema).optional(),
  totalAmount: z.lazy(() => SortOrderSchema).optional(),
  formOfPayment: z.lazy(() => SortOrderSchema).optional(),
  confirmationId: z.lazy(() => SortOrderSchema).optional(),
  receivingWallet: z.lazy(() => SortOrderSchema).optional(),
  status: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  saleId: z.lazy(() => SortOrderSchema).optional(),
  comment: z.lazy(() => SortOrderSchema).optional(),
  amountPaid: z.lazy(() => SortOrderSchema).optional(),
  amountPaidCurrency: z.lazy(() => SortOrderSchema).optional(),
  txHash: z.lazy(() => SortOrderSchema).optional(),
  blockchainId: z.lazy(() => SortOrderSchema).optional(),
  agreementId: z.lazy(() => SortOrderSchema).optional(),
  approvedBy: z.lazy(() => SortOrderSchema).optional(),
  rejectionReason: z.lazy(() => SortOrderSchema).optional(),
  paymentEvidence: z.lazy(() => SortOrderSchema).optional(),
  paymentDate: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const SaleTransactionsSumOrderByAggregateInputSchema: z.ZodType<Prisma.SaleTransactionsSumOrderByAggregateInput> = z.object({
  quantity: z.lazy(() => SortOrderSchema).optional(),
  price: z.lazy(() => SortOrderSchema).optional(),
  totalAmount: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const EnumFOPWithAggregatesFilterSchema: z.ZodType<Prisma.EnumFOPWithAggregatesFilter> = z.object({
  equals: z.lazy(() => FOPSchema).optional(),
  in: z.lazy(() => FOPSchema).array().optional(),
  notIn: z.lazy(() => FOPSchema).array().optional(),
  not: z.union([ z.lazy(() => FOPSchema),z.lazy(() => NestedEnumFOPWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedEnumFOPFilterSchema).optional(),
  _max: z.lazy(() => NestedEnumFOPFilterSchema).optional()
}).strict();

export const EnumTransactionStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumTransactionStatusWithAggregatesFilter> = z.object({
  equals: z.lazy(() => TransactionStatusSchema).optional(),
  in: z.lazy(() => TransactionStatusSchema).array().optional(),
  notIn: z.lazy(() => TransactionStatusSchema).array().optional(),
  not: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => NestedEnumTransactionStatusWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedEnumTransactionStatusFilterSchema).optional(),
  _max: z.lazy(() => NestedEnumTransactionStatusFilterSchema).optional()
}).strict();

export const TokensOnBlockchainsListRelationFilterSchema: z.ZodType<Prisma.TokensOnBlockchainsListRelationFilter> = z.object({
  every: z.lazy(() => TokensOnBlockchainsWhereInputSchema).optional(),
  some: z.lazy(() => TokensOnBlockchainsWhereInputSchema).optional(),
  none: z.lazy(() => TokensOnBlockchainsWhereInputSchema).optional()
}).strict();

export const TokensOnBlockchainsOrderByRelationAggregateInputSchema: z.ZodType<Prisma.TokensOnBlockchainsOrderByRelationAggregateInput> = z.object({
  _count: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const BlockchainCountOrderByAggregateInputSchema: z.ZodType<Prisma.BlockchainCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  chainId: z.lazy(() => SortOrderSchema).optional(),
  rpcUrl: z.lazy(() => SortOrderSchema).optional(),
  explorerUrl: z.lazy(() => SortOrderSchema).optional(),
  isTestnet: z.lazy(() => SortOrderSchema).optional(),
  isEnabled: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const BlockchainAvgOrderByAggregateInputSchema: z.ZodType<Prisma.BlockchainAvgOrderByAggregateInput> = z.object({
  chainId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const BlockchainMaxOrderByAggregateInputSchema: z.ZodType<Prisma.BlockchainMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  chainId: z.lazy(() => SortOrderSchema).optional(),
  rpcUrl: z.lazy(() => SortOrderSchema).optional(),
  explorerUrl: z.lazy(() => SortOrderSchema).optional(),
  isTestnet: z.lazy(() => SortOrderSchema).optional(),
  isEnabled: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const BlockchainMinOrderByAggregateInputSchema: z.ZodType<Prisma.BlockchainMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  chainId: z.lazy(() => SortOrderSchema).optional(),
  rpcUrl: z.lazy(() => SortOrderSchema).optional(),
  explorerUrl: z.lazy(() => SortOrderSchema).optional(),
  isTestnet: z.lazy(() => SortOrderSchema).optional(),
  isEnabled: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const BlockchainSumOrderByAggregateInputSchema: z.ZodType<Prisma.BlockchainSumOrderByAggregateInput> = z.object({
  chainId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const EnumContractSignatureStatusFilterSchema: z.ZodType<Prisma.EnumContractSignatureStatusFilter> = z.object({
  equals: z.lazy(() => ContractSignatureStatusSchema).optional(),
  in: z.lazy(() => ContractSignatureStatusSchema).array().optional(),
  notIn: z.lazy(() => ContractSignatureStatusSchema).array().optional(),
  not: z.union([ z.lazy(() => ContractSignatureStatusSchema),z.lazy(() => NestedEnumContractSignatureStatusFilterSchema) ]).optional(),
}).strict();

export const ContractStatusCountOrderByAggregateInputSchema: z.ZodType<Prisma.ContractStatusCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  saleId: z.lazy(() => SortOrderSchema).optional(),
  contractId: z.lazy(() => SortOrderSchema).optional(),
  status: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const ContractStatusMaxOrderByAggregateInputSchema: z.ZodType<Prisma.ContractStatusMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  saleId: z.lazy(() => SortOrderSchema).optional(),
  contractId: z.lazy(() => SortOrderSchema).optional(),
  status: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const ContractStatusMinOrderByAggregateInputSchema: z.ZodType<Prisma.ContractStatusMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  saleId: z.lazy(() => SortOrderSchema).optional(),
  contractId: z.lazy(() => SortOrderSchema).optional(),
  status: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const EnumContractSignatureStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumContractSignatureStatusWithAggregatesFilter> = z.object({
  equals: z.lazy(() => ContractSignatureStatusSchema).optional(),
  in: z.lazy(() => ContractSignatureStatusSchema).array().optional(),
  notIn: z.lazy(() => ContractSignatureStatusSchema).array().optional(),
  not: z.union([ z.lazy(() => ContractSignatureStatusSchema),z.lazy(() => NestedEnumContractSignatureStatusWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedEnumContractSignatureStatusFilterSchema).optional(),
  _max: z.lazy(() => NestedEnumContractSignatureStatusFilterSchema).optional()
}).strict();

export const TransactionAuditCountOrderByAggregateInputSchema: z.ZodType<Prisma.TransactionAuditCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  transactionId: z.lazy(() => SortOrderSchema).optional(),
  actionType: z.lazy(() => SortOrderSchema).optional(),
  fromStatus: z.lazy(() => SortOrderSchema).optional(),
  toStatus: z.lazy(() => SortOrderSchema).optional(),
  performedBy: z.lazy(() => SortOrderSchema).optional(),
  comment: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TransactionAuditMaxOrderByAggregateInputSchema: z.ZodType<Prisma.TransactionAuditMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  transactionId: z.lazy(() => SortOrderSchema).optional(),
  actionType: z.lazy(() => SortOrderSchema).optional(),
  fromStatus: z.lazy(() => SortOrderSchema).optional(),
  toStatus: z.lazy(() => SortOrderSchema).optional(),
  performedBy: z.lazy(() => SortOrderSchema).optional(),
  comment: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TransactionAuditMinOrderByAggregateInputSchema: z.ZodType<Prisma.TransactionAuditMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  transactionId: z.lazy(() => SortOrderSchema).optional(),
  actionType: z.lazy(() => SortOrderSchema).optional(),
  fromStatus: z.lazy(() => SortOrderSchema).optional(),
  toStatus: z.lazy(() => SortOrderSchema).optional(),
  performedBy: z.lazy(() => SortOrderSchema).optional(),
  comment: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const EnumKycStatusFilterSchema: z.ZodType<Prisma.EnumKycStatusFilter> = z.object({
  equals: z.lazy(() => KycStatusSchema).optional(),
  in: z.lazy(() => KycStatusSchema).array().optional(),
  notIn: z.lazy(() => KycStatusSchema).array().optional(),
  not: z.union([ z.lazy(() => KycStatusSchema),z.lazy(() => NestedEnumKycStatusFilterSchema) ]).optional(),
}).strict();

export const KycVerificationCountOrderByAggregateInputSchema: z.ZodType<Prisma.KycVerificationCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  status: z.lazy(() => SortOrderSchema).optional(),
  documentType: z.lazy(() => SortOrderSchema).optional(),
  documentNumber: z.lazy(() => SortOrderSchema).optional(),
  verifiedAt: z.lazy(() => SortOrderSchema).optional(),
  rejectionReason: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const KycVerificationMaxOrderByAggregateInputSchema: z.ZodType<Prisma.KycVerificationMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  status: z.lazy(() => SortOrderSchema).optional(),
  documentType: z.lazy(() => SortOrderSchema).optional(),
  documentNumber: z.lazy(() => SortOrderSchema).optional(),
  verifiedAt: z.lazy(() => SortOrderSchema).optional(),
  rejectionReason: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const KycVerificationMinOrderByAggregateInputSchema: z.ZodType<Prisma.KycVerificationMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  status: z.lazy(() => SortOrderSchema).optional(),
  documentType: z.lazy(() => SortOrderSchema).optional(),
  documentNumber: z.lazy(() => SortOrderSchema).optional(),
  verifiedAt: z.lazy(() => SortOrderSchema).optional(),
  rejectionReason: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const EnumKycStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumKycStatusWithAggregatesFilter> = z.object({
  equals: z.lazy(() => KycStatusSchema).optional(),
  in: z.lazy(() => KycStatusSchema).array().optional(),
  notIn: z.lazy(() => KycStatusSchema).array().optional(),
  not: z.union([ z.lazy(() => KycStatusSchema),z.lazy(() => NestedEnumKycStatusWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedEnumKycStatusFilterSchema).optional(),
  _max: z.lazy(() => NestedEnumKycStatusFilterSchema).optional()
}).strict();

export const RoleCountOrderByAggregateInputSchema: z.ZodType<Prisma.RoleCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  description: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const RoleMaxOrderByAggregateInputSchema: z.ZodType<Prisma.RoleMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  description: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const RoleMinOrderByAggregateInputSchema: z.ZodType<Prisma.RoleMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  description: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const RoleScalarRelationFilterSchema: z.ZodType<Prisma.RoleScalarRelationFilter> = z.object({
  is: z.lazy(() => RoleWhereInputSchema).optional(),
  isNot: z.lazy(() => RoleWhereInputSchema).optional()
}).strict();

export const UserRoleUserIdRoleIdCompoundUniqueInputSchema: z.ZodType<Prisma.UserRoleUserIdRoleIdCompoundUniqueInput> = z.object({
  userId: z.string(),
  roleId: z.string()
}).strict();

export const UserRoleCountOrderByAggregateInputSchema: z.ZodType<Prisma.UserRoleCountOrderByAggregateInput> = z.object({
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  roleId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const UserRoleMaxOrderByAggregateInputSchema: z.ZodType<Prisma.UserRoleMaxOrderByAggregateInput> = z.object({
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  roleId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const UserRoleMinOrderByAggregateInputSchema: z.ZodType<Prisma.UserRoleMinOrderByAggregateInput> = z.object({
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  userId: z.lazy(() => SortOrderSchema).optional(),
  roleId: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TokenCountOrderByAggregateInputSchema: z.ZodType<Prisma.TokenCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  symbol: z.lazy(() => SortOrderSchema).optional(),
  totalSupply: z.lazy(() => SortOrderSchema).optional(),
  image: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TokenMaxOrderByAggregateInputSchema: z.ZodType<Prisma.TokenMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  symbol: z.lazy(() => SortOrderSchema).optional(),
  totalSupply: z.lazy(() => SortOrderSchema).optional(),
  image: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TokenMinOrderByAggregateInputSchema: z.ZodType<Prisma.TokenMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  createdAt: z.lazy(() => SortOrderSchema).optional(),
  updatedAt: z.lazy(() => SortOrderSchema).optional(),
  deletedAt: z.lazy(() => SortOrderSchema).optional(),
  symbol: z.lazy(() => SortOrderSchema).optional(),
  totalSupply: z.lazy(() => SortOrderSchema).optional(),
  image: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const BlockchainScalarRelationFilterSchema: z.ZodType<Prisma.BlockchainScalarRelationFilter> = z.object({
  is: z.lazy(() => BlockchainWhereInputSchema).optional(),
  isNot: z.lazy(() => BlockchainWhereInputSchema).optional()
}).strict();

export const TokensOnBlockchainsTokenIdBlockchainIdCompoundUniqueInputSchema: z.ZodType<Prisma.TokensOnBlockchainsTokenIdBlockchainIdCompoundUniqueInput> = z.object({
  tokenId: z.string(),
  blockchainId: z.string()
}).strict();

export const TokensOnBlockchainsTokenSymbolBlockchainIdCompoundUniqueInputSchema: z.ZodType<Prisma.TokensOnBlockchainsTokenSymbolBlockchainIdCompoundUniqueInput> = z.object({
  tokenSymbol: z.string(),
  blockchainId: z.string()
}).strict();

export const TokensOnBlockchainsCountOrderByAggregateInputSchema: z.ZodType<Prisma.TokensOnBlockchainsCountOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  tokenId: z.lazy(() => SortOrderSchema).optional(),
  tokenSymbol: z.lazy(() => SortOrderSchema).optional(),
  blockchainId: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  isNative: z.lazy(() => SortOrderSchema).optional(),
  decimals: z.lazy(() => SortOrderSchema).optional(),
  contractAddress: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TokensOnBlockchainsAvgOrderByAggregateInputSchema: z.ZodType<Prisma.TokensOnBlockchainsAvgOrderByAggregateInput> = z.object({
  decimals: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TokensOnBlockchainsMaxOrderByAggregateInputSchema: z.ZodType<Prisma.TokensOnBlockchainsMaxOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  tokenId: z.lazy(() => SortOrderSchema).optional(),
  tokenSymbol: z.lazy(() => SortOrderSchema).optional(),
  blockchainId: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  isNative: z.lazy(() => SortOrderSchema).optional(),
  decimals: z.lazy(() => SortOrderSchema).optional(),
  contractAddress: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TokensOnBlockchainsMinOrderByAggregateInputSchema: z.ZodType<Prisma.TokensOnBlockchainsMinOrderByAggregateInput> = z.object({
  id: z.lazy(() => SortOrderSchema).optional(),
  tokenId: z.lazy(() => SortOrderSchema).optional(),
  tokenSymbol: z.lazy(() => SortOrderSchema).optional(),
  blockchainId: z.lazy(() => SortOrderSchema).optional(),
  name: z.lazy(() => SortOrderSchema).optional(),
  isNative: z.lazy(() => SortOrderSchema).optional(),
  decimals: z.lazy(() => SortOrderSchema).optional(),
  contractAddress: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const TokensOnBlockchainsSumOrderByAggregateInputSchema: z.ZodType<Prisma.TokensOnBlockchainsSumOrderByAggregateInput> = z.object({
  decimals: z.lazy(() => SortOrderSchema).optional()
}).strict();

export const ProfileCreateNestedOneWithoutUserInputSchema: z.ZodType<Prisma.ProfileCreateNestedOneWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => ProfileCreateWithoutUserInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutUserInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => ProfileCreateOrConnectWithoutUserInputSchema).optional(),
  connect: z.lazy(() => ProfileWhereUniqueInputSchema).optional()
}).strict();

export const SaleCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.SaleCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => SaleCreateWithoutUserInputSchema),z.lazy(() => SaleCreateWithoutUserInputSchema).array(),z.lazy(() => SaleUncheckedCreateWithoutUserInputSchema),z.lazy(() => SaleUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleCreateOrConnectWithoutUserInputSchema),z.lazy(() => SaleCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const UserRoleCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.UserRoleCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => UserRoleCreateWithoutUserInputSchema),z.lazy(() => UserRoleCreateWithoutUserInputSchema).array(),z.lazy(() => UserRoleUncheckedCreateWithoutUserInputSchema),z.lazy(() => UserRoleUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserRoleCreateOrConnectWithoutUserInputSchema),z.lazy(() => UserRoleCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => UserRoleCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => UserRoleWhereUniqueInputSchema),z.lazy(() => UserRoleWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const TransactionAuditCreateNestedManyWithoutAdminInputSchema: z.ZodType<Prisma.TransactionAuditCreateNestedManyWithoutAdminInput> = z.object({
  create: z.union([ z.lazy(() => TransactionAuditCreateWithoutAdminInputSchema),z.lazy(() => TransactionAuditCreateWithoutAdminInputSchema).array(),z.lazy(() => TransactionAuditUncheckedCreateWithoutAdminInputSchema),z.lazy(() => TransactionAuditUncheckedCreateWithoutAdminInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TransactionAuditCreateOrConnectWithoutAdminInputSchema),z.lazy(() => TransactionAuditCreateOrConnectWithoutAdminInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TransactionAuditCreateManyAdminInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => TransactionAuditWhereUniqueInputSchema),z.lazy(() => TransactionAuditWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const KycVerificationCreateNestedOneWithoutUserInputSchema: z.ZodType<Prisma.KycVerificationCreateNestedOneWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => KycVerificationCreateWithoutUserInputSchema),z.lazy(() => KycVerificationUncheckedCreateWithoutUserInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => KycVerificationCreateOrConnectWithoutUserInputSchema).optional(),
  connect: z.lazy(() => KycVerificationWhereUniqueInputSchema).optional()
}).strict();

export const SessionCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.SessionCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => SessionCreateWithoutUserInputSchema),z.lazy(() => SessionCreateWithoutUserInputSchema).array(),z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema),z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SessionCreateOrConnectWithoutUserInputSchema),z.lazy(() => SessionCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SessionCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => SessionWhereUniqueInputSchema),z.lazy(() => SessionWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const SaleTransactionsCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.SaleTransactionsCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutUserInputSchema),z.lazy(() => SaleTransactionsCreateWithoutUserInputSchema).array(),z.lazy(() => SaleTransactionsUncheckedCreateWithoutUserInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleTransactionsCreateOrConnectWithoutUserInputSchema),z.lazy(() => SaleTransactionsCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleTransactionsCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const SaleTransactionsCreateNestedManyWithoutApproverInputSchema: z.ZodType<Prisma.SaleTransactionsCreateNestedManyWithoutApproverInput> = z.object({
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutApproverInputSchema),z.lazy(() => SaleTransactionsCreateWithoutApproverInputSchema).array(),z.lazy(() => SaleTransactionsUncheckedCreateWithoutApproverInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutApproverInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleTransactionsCreateOrConnectWithoutApproverInputSchema),z.lazy(() => SaleTransactionsCreateOrConnectWithoutApproverInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleTransactionsCreateManyApproverInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const DocumentCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.DocumentCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => DocumentCreateWithoutUserInputSchema),z.lazy(() => DocumentCreateWithoutUserInputSchema).array(),z.lazy(() => DocumentUncheckedCreateWithoutUserInputSchema),z.lazy(() => DocumentUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => DocumentCreateOrConnectWithoutUserInputSchema),z.lazy(() => DocumentCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => DocumentCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => DocumentWhereUniqueInputSchema),z.lazy(() => DocumentWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const WalletAddressCreateNestedManyWithoutAddressInputSchema: z.ZodType<Prisma.WalletAddressCreateNestedManyWithoutAddressInput> = z.object({
  create: z.union([ z.lazy(() => WalletAddressCreateWithoutAddressInputSchema),z.lazy(() => WalletAddressCreateWithoutAddressInputSchema).array(),z.lazy(() => WalletAddressUncheckedCreateWithoutAddressInputSchema),z.lazy(() => WalletAddressUncheckedCreateWithoutAddressInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => WalletAddressCreateOrConnectWithoutAddressInputSchema),z.lazy(() => WalletAddressCreateOrConnectWithoutAddressInputSchema).array() ]).optional(),
  createMany: z.lazy(() => WalletAddressCreateManyAddressInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => WalletAddressWhereUniqueInputSchema),z.lazy(() => WalletAddressWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const ProfileUncheckedCreateNestedOneWithoutUserInputSchema: z.ZodType<Prisma.ProfileUncheckedCreateNestedOneWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => ProfileCreateWithoutUserInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutUserInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => ProfileCreateOrConnectWithoutUserInputSchema).optional(),
  connect: z.lazy(() => ProfileWhereUniqueInputSchema).optional()
}).strict();

export const SaleUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.SaleUncheckedCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => SaleCreateWithoutUserInputSchema),z.lazy(() => SaleCreateWithoutUserInputSchema).array(),z.lazy(() => SaleUncheckedCreateWithoutUserInputSchema),z.lazy(() => SaleUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleCreateOrConnectWithoutUserInputSchema),z.lazy(() => SaleCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const UserRoleUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.UserRoleUncheckedCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => UserRoleCreateWithoutUserInputSchema),z.lazy(() => UserRoleCreateWithoutUserInputSchema).array(),z.lazy(() => UserRoleUncheckedCreateWithoutUserInputSchema),z.lazy(() => UserRoleUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserRoleCreateOrConnectWithoutUserInputSchema),z.lazy(() => UserRoleCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => UserRoleCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => UserRoleWhereUniqueInputSchema),z.lazy(() => UserRoleWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const TransactionAuditUncheckedCreateNestedManyWithoutAdminInputSchema: z.ZodType<Prisma.TransactionAuditUncheckedCreateNestedManyWithoutAdminInput> = z.object({
  create: z.union([ z.lazy(() => TransactionAuditCreateWithoutAdminInputSchema),z.lazy(() => TransactionAuditCreateWithoutAdminInputSchema).array(),z.lazy(() => TransactionAuditUncheckedCreateWithoutAdminInputSchema),z.lazy(() => TransactionAuditUncheckedCreateWithoutAdminInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TransactionAuditCreateOrConnectWithoutAdminInputSchema),z.lazy(() => TransactionAuditCreateOrConnectWithoutAdminInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TransactionAuditCreateManyAdminInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => TransactionAuditWhereUniqueInputSchema),z.lazy(() => TransactionAuditWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const KycVerificationUncheckedCreateNestedOneWithoutUserInputSchema: z.ZodType<Prisma.KycVerificationUncheckedCreateNestedOneWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => KycVerificationCreateWithoutUserInputSchema),z.lazy(() => KycVerificationUncheckedCreateWithoutUserInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => KycVerificationCreateOrConnectWithoutUserInputSchema).optional(),
  connect: z.lazy(() => KycVerificationWhereUniqueInputSchema).optional()
}).strict();

export const SessionUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.SessionUncheckedCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => SessionCreateWithoutUserInputSchema),z.lazy(() => SessionCreateWithoutUserInputSchema).array(),z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema),z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SessionCreateOrConnectWithoutUserInputSchema),z.lazy(() => SessionCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SessionCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => SessionWhereUniqueInputSchema),z.lazy(() => SessionWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const SaleTransactionsUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutUserInputSchema),z.lazy(() => SaleTransactionsCreateWithoutUserInputSchema).array(),z.lazy(() => SaleTransactionsUncheckedCreateWithoutUserInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleTransactionsCreateOrConnectWithoutUserInputSchema),z.lazy(() => SaleTransactionsCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleTransactionsCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const SaleTransactionsUncheckedCreateNestedManyWithoutApproverInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedCreateNestedManyWithoutApproverInput> = z.object({
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutApproverInputSchema),z.lazy(() => SaleTransactionsCreateWithoutApproverInputSchema).array(),z.lazy(() => SaleTransactionsUncheckedCreateWithoutApproverInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutApproverInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleTransactionsCreateOrConnectWithoutApproverInputSchema),z.lazy(() => SaleTransactionsCreateOrConnectWithoutApproverInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleTransactionsCreateManyApproverInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const DocumentUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.DocumentUncheckedCreateNestedManyWithoutUserInput> = z.object({
  create: z.union([ z.lazy(() => DocumentCreateWithoutUserInputSchema),z.lazy(() => DocumentCreateWithoutUserInputSchema).array(),z.lazy(() => DocumentUncheckedCreateWithoutUserInputSchema),z.lazy(() => DocumentUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => DocumentCreateOrConnectWithoutUserInputSchema),z.lazy(() => DocumentCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => DocumentCreateManyUserInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => DocumentWhereUniqueInputSchema),z.lazy(() => DocumentWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const WalletAddressUncheckedCreateNestedManyWithoutAddressInputSchema: z.ZodType<Prisma.WalletAddressUncheckedCreateNestedManyWithoutAddressInput> = z.object({
  create: z.union([ z.lazy(() => WalletAddressCreateWithoutAddressInputSchema),z.lazy(() => WalletAddressCreateWithoutAddressInputSchema).array(),z.lazy(() => WalletAddressUncheckedCreateWithoutAddressInputSchema),z.lazy(() => WalletAddressUncheckedCreateWithoutAddressInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => WalletAddressCreateOrConnectWithoutAddressInputSchema),z.lazy(() => WalletAddressCreateOrConnectWithoutAddressInputSchema).array() ]).optional(),
  createMany: z.lazy(() => WalletAddressCreateManyAddressInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => WalletAddressWhereUniqueInputSchema),z.lazy(() => WalletAddressWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const StringFieldUpdateOperationsInputSchema: z.ZodType<Prisma.StringFieldUpdateOperationsInput> = z.object({
  set: z.string().optional()
}).strict();

export const NullableStringFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableStringFieldUpdateOperationsInput> = z.object({
  set: z.string().optional().nullable()
}).strict();

export const DateTimeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.DateTimeFieldUpdateOperationsInput> = z.object({
  set: z.coerce.date().optional()
}).strict();

export const NullableDateTimeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableDateTimeFieldUpdateOperationsInput> = z.object({
  set: z.coerce.date().optional().nullable()
}).strict();

export const BoolFieldUpdateOperationsInputSchema: z.ZodType<Prisma.BoolFieldUpdateOperationsInput> = z.object({
  set: z.boolean().optional()
}).strict();

export const NullableBoolFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableBoolFieldUpdateOperationsInput> = z.object({
  set: z.boolean().optional().nullable()
}).strict();

export const ProfileUpdateOneWithoutUserNestedInputSchema: z.ZodType<Prisma.ProfileUpdateOneWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => ProfileCreateWithoutUserInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutUserInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => ProfileCreateOrConnectWithoutUserInputSchema).optional(),
  upsert: z.lazy(() => ProfileUpsertWithoutUserInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => ProfileWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => ProfileWhereInputSchema) ]).optional(),
  connect: z.lazy(() => ProfileWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => ProfileUpdateToOneWithWhereWithoutUserInputSchema),z.lazy(() => ProfileUpdateWithoutUserInputSchema),z.lazy(() => ProfileUncheckedUpdateWithoutUserInputSchema) ]).optional(),
}).strict();

export const SaleUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.SaleUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => SaleCreateWithoutUserInputSchema),z.lazy(() => SaleCreateWithoutUserInputSchema).array(),z.lazy(() => SaleUncheckedCreateWithoutUserInputSchema),z.lazy(() => SaleUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleCreateOrConnectWithoutUserInputSchema),z.lazy(() => SaleCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => SaleUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => SaleUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => SaleUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => SaleUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => SaleUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => SaleUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => SaleScalarWhereInputSchema),z.lazy(() => SaleScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const UserRoleUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.UserRoleUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserRoleCreateWithoutUserInputSchema),z.lazy(() => UserRoleCreateWithoutUserInputSchema).array(),z.lazy(() => UserRoleUncheckedCreateWithoutUserInputSchema),z.lazy(() => UserRoleUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserRoleCreateOrConnectWithoutUserInputSchema),z.lazy(() => UserRoleCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => UserRoleUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => UserRoleUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => UserRoleCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => UserRoleWhereUniqueInputSchema),z.lazy(() => UserRoleWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => UserRoleWhereUniqueInputSchema),z.lazy(() => UserRoleWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => UserRoleWhereUniqueInputSchema),z.lazy(() => UserRoleWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => UserRoleWhereUniqueInputSchema),z.lazy(() => UserRoleWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => UserRoleUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => UserRoleUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => UserRoleUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => UserRoleUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => UserRoleScalarWhereInputSchema),z.lazy(() => UserRoleScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TransactionAuditUpdateManyWithoutAdminNestedInputSchema: z.ZodType<Prisma.TransactionAuditUpdateManyWithoutAdminNestedInput> = z.object({
  create: z.union([ z.lazy(() => TransactionAuditCreateWithoutAdminInputSchema),z.lazy(() => TransactionAuditCreateWithoutAdminInputSchema).array(),z.lazy(() => TransactionAuditUncheckedCreateWithoutAdminInputSchema),z.lazy(() => TransactionAuditUncheckedCreateWithoutAdminInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TransactionAuditCreateOrConnectWithoutAdminInputSchema),z.lazy(() => TransactionAuditCreateOrConnectWithoutAdminInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => TransactionAuditUpsertWithWhereUniqueWithoutAdminInputSchema),z.lazy(() => TransactionAuditUpsertWithWhereUniqueWithoutAdminInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TransactionAuditCreateManyAdminInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => TransactionAuditWhereUniqueInputSchema),z.lazy(() => TransactionAuditWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => TransactionAuditWhereUniqueInputSchema),z.lazy(() => TransactionAuditWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => TransactionAuditWhereUniqueInputSchema),z.lazy(() => TransactionAuditWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => TransactionAuditWhereUniqueInputSchema),z.lazy(() => TransactionAuditWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => TransactionAuditUpdateWithWhereUniqueWithoutAdminInputSchema),z.lazy(() => TransactionAuditUpdateWithWhereUniqueWithoutAdminInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => TransactionAuditUpdateManyWithWhereWithoutAdminInputSchema),z.lazy(() => TransactionAuditUpdateManyWithWhereWithoutAdminInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => TransactionAuditScalarWhereInputSchema),z.lazy(() => TransactionAuditScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const KycVerificationUpdateOneWithoutUserNestedInputSchema: z.ZodType<Prisma.KycVerificationUpdateOneWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => KycVerificationCreateWithoutUserInputSchema),z.lazy(() => KycVerificationUncheckedCreateWithoutUserInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => KycVerificationCreateOrConnectWithoutUserInputSchema).optional(),
  upsert: z.lazy(() => KycVerificationUpsertWithoutUserInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => KycVerificationWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => KycVerificationWhereInputSchema) ]).optional(),
  connect: z.lazy(() => KycVerificationWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => KycVerificationUpdateToOneWithWhereWithoutUserInputSchema),z.lazy(() => KycVerificationUpdateWithoutUserInputSchema),z.lazy(() => KycVerificationUncheckedUpdateWithoutUserInputSchema) ]).optional(),
}).strict();

export const SessionUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.SessionUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => SessionCreateWithoutUserInputSchema),z.lazy(() => SessionCreateWithoutUserInputSchema).array(),z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema),z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SessionCreateOrConnectWithoutUserInputSchema),z.lazy(() => SessionCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => SessionUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => SessionUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SessionCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => SessionWhereUniqueInputSchema),z.lazy(() => SessionWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => SessionWhereUniqueInputSchema),z.lazy(() => SessionWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => SessionWhereUniqueInputSchema),z.lazy(() => SessionWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => SessionWhereUniqueInputSchema),z.lazy(() => SessionWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => SessionUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => SessionUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => SessionUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => SessionUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => SessionScalarWhereInputSchema),z.lazy(() => SessionScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const SaleTransactionsUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.SaleTransactionsUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutUserInputSchema),z.lazy(() => SaleTransactionsCreateWithoutUserInputSchema).array(),z.lazy(() => SaleTransactionsUncheckedCreateWithoutUserInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleTransactionsCreateOrConnectWithoutUserInputSchema),z.lazy(() => SaleTransactionsCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => SaleTransactionsUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => SaleTransactionsUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleTransactionsCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => SaleTransactionsUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => SaleTransactionsUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => SaleTransactionsUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => SaleTransactionsUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => SaleTransactionsScalarWhereInputSchema),z.lazy(() => SaleTransactionsScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const SaleTransactionsUpdateManyWithoutApproverNestedInputSchema: z.ZodType<Prisma.SaleTransactionsUpdateManyWithoutApproverNestedInput> = z.object({
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutApproverInputSchema),z.lazy(() => SaleTransactionsCreateWithoutApproverInputSchema).array(),z.lazy(() => SaleTransactionsUncheckedCreateWithoutApproverInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutApproverInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleTransactionsCreateOrConnectWithoutApproverInputSchema),z.lazy(() => SaleTransactionsCreateOrConnectWithoutApproverInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => SaleTransactionsUpsertWithWhereUniqueWithoutApproverInputSchema),z.lazy(() => SaleTransactionsUpsertWithWhereUniqueWithoutApproverInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleTransactionsCreateManyApproverInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => SaleTransactionsUpdateWithWhereUniqueWithoutApproverInputSchema),z.lazy(() => SaleTransactionsUpdateWithWhereUniqueWithoutApproverInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => SaleTransactionsUpdateManyWithWhereWithoutApproverInputSchema),z.lazy(() => SaleTransactionsUpdateManyWithWhereWithoutApproverInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => SaleTransactionsScalarWhereInputSchema),z.lazy(() => SaleTransactionsScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const DocumentUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.DocumentUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => DocumentCreateWithoutUserInputSchema),z.lazy(() => DocumentCreateWithoutUserInputSchema).array(),z.lazy(() => DocumentUncheckedCreateWithoutUserInputSchema),z.lazy(() => DocumentUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => DocumentCreateOrConnectWithoutUserInputSchema),z.lazy(() => DocumentCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => DocumentUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => DocumentUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => DocumentCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => DocumentWhereUniqueInputSchema),z.lazy(() => DocumentWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => DocumentWhereUniqueInputSchema),z.lazy(() => DocumentWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => DocumentWhereUniqueInputSchema),z.lazy(() => DocumentWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => DocumentWhereUniqueInputSchema),z.lazy(() => DocumentWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => DocumentUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => DocumentUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => DocumentUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => DocumentUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => DocumentScalarWhereInputSchema),z.lazy(() => DocumentScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const WalletAddressUpdateManyWithoutAddressNestedInputSchema: z.ZodType<Prisma.WalletAddressUpdateManyWithoutAddressNestedInput> = z.object({
  create: z.union([ z.lazy(() => WalletAddressCreateWithoutAddressInputSchema),z.lazy(() => WalletAddressCreateWithoutAddressInputSchema).array(),z.lazy(() => WalletAddressUncheckedCreateWithoutAddressInputSchema),z.lazy(() => WalletAddressUncheckedCreateWithoutAddressInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => WalletAddressCreateOrConnectWithoutAddressInputSchema),z.lazy(() => WalletAddressCreateOrConnectWithoutAddressInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => WalletAddressUpsertWithWhereUniqueWithoutAddressInputSchema),z.lazy(() => WalletAddressUpsertWithWhereUniqueWithoutAddressInputSchema).array() ]).optional(),
  createMany: z.lazy(() => WalletAddressCreateManyAddressInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => WalletAddressWhereUniqueInputSchema),z.lazy(() => WalletAddressWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => WalletAddressWhereUniqueInputSchema),z.lazy(() => WalletAddressWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => WalletAddressWhereUniqueInputSchema),z.lazy(() => WalletAddressWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => WalletAddressWhereUniqueInputSchema),z.lazy(() => WalletAddressWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => WalletAddressUpdateWithWhereUniqueWithoutAddressInputSchema),z.lazy(() => WalletAddressUpdateWithWhereUniqueWithoutAddressInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => WalletAddressUpdateManyWithWhereWithoutAddressInputSchema),z.lazy(() => WalletAddressUpdateManyWithWhereWithoutAddressInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => WalletAddressScalarWhereInputSchema),z.lazy(() => WalletAddressScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const ProfileUncheckedUpdateOneWithoutUserNestedInputSchema: z.ZodType<Prisma.ProfileUncheckedUpdateOneWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => ProfileCreateWithoutUserInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutUserInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => ProfileCreateOrConnectWithoutUserInputSchema).optional(),
  upsert: z.lazy(() => ProfileUpsertWithoutUserInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => ProfileWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => ProfileWhereInputSchema) ]).optional(),
  connect: z.lazy(() => ProfileWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => ProfileUpdateToOneWithWhereWithoutUserInputSchema),z.lazy(() => ProfileUpdateWithoutUserInputSchema),z.lazy(() => ProfileUncheckedUpdateWithoutUserInputSchema) ]).optional(),
}).strict();

export const SaleUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.SaleUncheckedUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => SaleCreateWithoutUserInputSchema),z.lazy(() => SaleCreateWithoutUserInputSchema).array(),z.lazy(() => SaleUncheckedCreateWithoutUserInputSchema),z.lazy(() => SaleUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleCreateOrConnectWithoutUserInputSchema),z.lazy(() => SaleCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => SaleUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => SaleUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => SaleUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => SaleUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => SaleUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => SaleUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => SaleScalarWhereInputSchema),z.lazy(() => SaleScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const UserRoleUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.UserRoleUncheckedUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserRoleCreateWithoutUserInputSchema),z.lazy(() => UserRoleCreateWithoutUserInputSchema).array(),z.lazy(() => UserRoleUncheckedCreateWithoutUserInputSchema),z.lazy(() => UserRoleUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserRoleCreateOrConnectWithoutUserInputSchema),z.lazy(() => UserRoleCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => UserRoleUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => UserRoleUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => UserRoleCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => UserRoleWhereUniqueInputSchema),z.lazy(() => UserRoleWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => UserRoleWhereUniqueInputSchema),z.lazy(() => UserRoleWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => UserRoleWhereUniqueInputSchema),z.lazy(() => UserRoleWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => UserRoleWhereUniqueInputSchema),z.lazy(() => UserRoleWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => UserRoleUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => UserRoleUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => UserRoleUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => UserRoleUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => UserRoleScalarWhereInputSchema),z.lazy(() => UserRoleScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TransactionAuditUncheckedUpdateManyWithoutAdminNestedInputSchema: z.ZodType<Prisma.TransactionAuditUncheckedUpdateManyWithoutAdminNestedInput> = z.object({
  create: z.union([ z.lazy(() => TransactionAuditCreateWithoutAdminInputSchema),z.lazy(() => TransactionAuditCreateWithoutAdminInputSchema).array(),z.lazy(() => TransactionAuditUncheckedCreateWithoutAdminInputSchema),z.lazy(() => TransactionAuditUncheckedCreateWithoutAdminInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TransactionAuditCreateOrConnectWithoutAdminInputSchema),z.lazy(() => TransactionAuditCreateOrConnectWithoutAdminInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => TransactionAuditUpsertWithWhereUniqueWithoutAdminInputSchema),z.lazy(() => TransactionAuditUpsertWithWhereUniqueWithoutAdminInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TransactionAuditCreateManyAdminInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => TransactionAuditWhereUniqueInputSchema),z.lazy(() => TransactionAuditWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => TransactionAuditWhereUniqueInputSchema),z.lazy(() => TransactionAuditWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => TransactionAuditWhereUniqueInputSchema),z.lazy(() => TransactionAuditWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => TransactionAuditWhereUniqueInputSchema),z.lazy(() => TransactionAuditWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => TransactionAuditUpdateWithWhereUniqueWithoutAdminInputSchema),z.lazy(() => TransactionAuditUpdateWithWhereUniqueWithoutAdminInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => TransactionAuditUpdateManyWithWhereWithoutAdminInputSchema),z.lazy(() => TransactionAuditUpdateManyWithWhereWithoutAdminInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => TransactionAuditScalarWhereInputSchema),z.lazy(() => TransactionAuditScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const KycVerificationUncheckedUpdateOneWithoutUserNestedInputSchema: z.ZodType<Prisma.KycVerificationUncheckedUpdateOneWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => KycVerificationCreateWithoutUserInputSchema),z.lazy(() => KycVerificationUncheckedCreateWithoutUserInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => KycVerificationCreateOrConnectWithoutUserInputSchema).optional(),
  upsert: z.lazy(() => KycVerificationUpsertWithoutUserInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => KycVerificationWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => KycVerificationWhereInputSchema) ]).optional(),
  connect: z.lazy(() => KycVerificationWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => KycVerificationUpdateToOneWithWhereWithoutUserInputSchema),z.lazy(() => KycVerificationUpdateWithoutUserInputSchema),z.lazy(() => KycVerificationUncheckedUpdateWithoutUserInputSchema) ]).optional(),
}).strict();

export const SessionUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.SessionUncheckedUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => SessionCreateWithoutUserInputSchema),z.lazy(() => SessionCreateWithoutUserInputSchema).array(),z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema),z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SessionCreateOrConnectWithoutUserInputSchema),z.lazy(() => SessionCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => SessionUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => SessionUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SessionCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => SessionWhereUniqueInputSchema),z.lazy(() => SessionWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => SessionWhereUniqueInputSchema),z.lazy(() => SessionWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => SessionWhereUniqueInputSchema),z.lazy(() => SessionWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => SessionWhereUniqueInputSchema),z.lazy(() => SessionWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => SessionUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => SessionUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => SessionUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => SessionUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => SessionScalarWhereInputSchema),z.lazy(() => SessionScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const SaleTransactionsUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutUserInputSchema),z.lazy(() => SaleTransactionsCreateWithoutUserInputSchema).array(),z.lazy(() => SaleTransactionsUncheckedCreateWithoutUserInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleTransactionsCreateOrConnectWithoutUserInputSchema),z.lazy(() => SaleTransactionsCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => SaleTransactionsUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => SaleTransactionsUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleTransactionsCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => SaleTransactionsUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => SaleTransactionsUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => SaleTransactionsUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => SaleTransactionsUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => SaleTransactionsScalarWhereInputSchema),z.lazy(() => SaleTransactionsScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const SaleTransactionsUncheckedUpdateManyWithoutApproverNestedInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedUpdateManyWithoutApproverNestedInput> = z.object({
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutApproverInputSchema),z.lazy(() => SaleTransactionsCreateWithoutApproverInputSchema).array(),z.lazy(() => SaleTransactionsUncheckedCreateWithoutApproverInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutApproverInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleTransactionsCreateOrConnectWithoutApproverInputSchema),z.lazy(() => SaleTransactionsCreateOrConnectWithoutApproverInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => SaleTransactionsUpsertWithWhereUniqueWithoutApproverInputSchema),z.lazy(() => SaleTransactionsUpsertWithWhereUniqueWithoutApproverInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleTransactionsCreateManyApproverInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => SaleTransactionsUpdateWithWhereUniqueWithoutApproverInputSchema),z.lazy(() => SaleTransactionsUpdateWithWhereUniqueWithoutApproverInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => SaleTransactionsUpdateManyWithWhereWithoutApproverInputSchema),z.lazy(() => SaleTransactionsUpdateManyWithWhereWithoutApproverInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => SaleTransactionsScalarWhereInputSchema),z.lazy(() => SaleTransactionsScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const DocumentUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.DocumentUncheckedUpdateManyWithoutUserNestedInput> = z.object({
  create: z.union([ z.lazy(() => DocumentCreateWithoutUserInputSchema),z.lazy(() => DocumentCreateWithoutUserInputSchema).array(),z.lazy(() => DocumentUncheckedCreateWithoutUserInputSchema),z.lazy(() => DocumentUncheckedCreateWithoutUserInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => DocumentCreateOrConnectWithoutUserInputSchema),z.lazy(() => DocumentCreateOrConnectWithoutUserInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => DocumentUpsertWithWhereUniqueWithoutUserInputSchema),z.lazy(() => DocumentUpsertWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  createMany: z.lazy(() => DocumentCreateManyUserInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => DocumentWhereUniqueInputSchema),z.lazy(() => DocumentWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => DocumentWhereUniqueInputSchema),z.lazy(() => DocumentWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => DocumentWhereUniqueInputSchema),z.lazy(() => DocumentWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => DocumentWhereUniqueInputSchema),z.lazy(() => DocumentWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => DocumentUpdateWithWhereUniqueWithoutUserInputSchema),z.lazy(() => DocumentUpdateWithWhereUniqueWithoutUserInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => DocumentUpdateManyWithWhereWithoutUserInputSchema),z.lazy(() => DocumentUpdateManyWithWhereWithoutUserInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => DocumentScalarWhereInputSchema),z.lazy(() => DocumentScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const WalletAddressUncheckedUpdateManyWithoutAddressNestedInputSchema: z.ZodType<Prisma.WalletAddressUncheckedUpdateManyWithoutAddressNestedInput> = z.object({
  create: z.union([ z.lazy(() => WalletAddressCreateWithoutAddressInputSchema),z.lazy(() => WalletAddressCreateWithoutAddressInputSchema).array(),z.lazy(() => WalletAddressUncheckedCreateWithoutAddressInputSchema),z.lazy(() => WalletAddressUncheckedCreateWithoutAddressInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => WalletAddressCreateOrConnectWithoutAddressInputSchema),z.lazy(() => WalletAddressCreateOrConnectWithoutAddressInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => WalletAddressUpsertWithWhereUniqueWithoutAddressInputSchema),z.lazy(() => WalletAddressUpsertWithWhereUniqueWithoutAddressInputSchema).array() ]).optional(),
  createMany: z.lazy(() => WalletAddressCreateManyAddressInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => WalletAddressWhereUniqueInputSchema),z.lazy(() => WalletAddressWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => WalletAddressWhereUniqueInputSchema),z.lazy(() => WalletAddressWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => WalletAddressWhereUniqueInputSchema),z.lazy(() => WalletAddressWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => WalletAddressWhereUniqueInputSchema),z.lazy(() => WalletAddressWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => WalletAddressUpdateWithWhereUniqueWithoutAddressInputSchema),z.lazy(() => WalletAddressUpdateWithWhereUniqueWithoutAddressInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => WalletAddressUpdateManyWithWhereWithoutAddressInputSchema),z.lazy(() => WalletAddressUpdateManyWithWhereWithoutAddressInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => WalletAddressScalarWhereInputSchema),z.lazy(() => WalletAddressScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const UserCreateNestedOneWithoutWalletAddressInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutWalletAddressInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutWalletAddressInputSchema),z.lazy(() => UserUncheckedCreateWithoutWalletAddressInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutWalletAddressInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
}).strict();

export const IntFieldUpdateOperationsInputSchema: z.ZodType<Prisma.IntFieldUpdateOperationsInput> = z.object({
  set: z.number().optional(),
  increment: z.number().optional(),
  decrement: z.number().optional(),
  multiply: z.number().optional(),
  divide: z.number().optional()
}).strict();

export const UserUpdateOneRequiredWithoutWalletAddressNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutWalletAddressNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutWalletAddressInputSchema),z.lazy(() => UserUncheckedCreateWithoutWalletAddressInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutWalletAddressInputSchema).optional(),
  upsert: z.lazy(() => UserUpsertWithoutWalletAddressInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => UserUpdateToOneWithWhereWithoutWalletAddressInputSchema),z.lazy(() => UserUpdateWithoutWalletAddressInputSchema),z.lazy(() => UserUncheckedUpdateWithoutWalletAddressInputSchema) ]).optional(),
}).strict();

export const UserCreateNestedOneWithoutSessionsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutSessionsInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutSessionsInputSchema),z.lazy(() => UserUncheckedCreateWithoutSessionsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutSessionsInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
}).strict();

export const UserUpdateOneRequiredWithoutSessionsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutSessionsNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutSessionsInputSchema),z.lazy(() => UserUncheckedCreateWithoutSessionsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutSessionsInputSchema).optional(),
  upsert: z.lazy(() => UserUpsertWithoutSessionsInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => UserUpdateToOneWithWhereWithoutSessionsInputSchema),z.lazy(() => UserUpdateWithoutSessionsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutSessionsInputSchema) ]).optional(),
}).strict();

export const UserCreateNestedOneWithoutProfileInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutProfileInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutProfileInputSchema),z.lazy(() => UserUncheckedCreateWithoutProfileInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutProfileInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
}).strict();

export const AddressCreateNestedOneWithoutProfileInputSchema: z.ZodType<Prisma.AddressCreateNestedOneWithoutProfileInput> = z.object({
  create: z.union([ z.lazy(() => AddressCreateWithoutProfileInputSchema),z.lazy(() => AddressUncheckedCreateWithoutProfileInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => AddressCreateOrConnectWithoutProfileInputSchema).optional(),
  connect: z.lazy(() => AddressWhereUniqueInputSchema).optional()
}).strict();

export const AddressUncheckedCreateNestedOneWithoutProfileInputSchema: z.ZodType<Prisma.AddressUncheckedCreateNestedOneWithoutProfileInput> = z.object({
  create: z.union([ z.lazy(() => AddressCreateWithoutProfileInputSchema),z.lazy(() => AddressUncheckedCreateWithoutProfileInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => AddressCreateOrConnectWithoutProfileInputSchema).optional(),
  connect: z.lazy(() => AddressWhereUniqueInputSchema).optional()
}).strict();

export const UserUpdateOneRequiredWithoutProfileNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutProfileNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutProfileInputSchema),z.lazy(() => UserUncheckedCreateWithoutProfileInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutProfileInputSchema).optional(),
  upsert: z.lazy(() => UserUpsertWithoutProfileInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => UserUpdateToOneWithWhereWithoutProfileInputSchema),z.lazy(() => UserUpdateWithoutProfileInputSchema),z.lazy(() => UserUncheckedUpdateWithoutProfileInputSchema) ]).optional(),
}).strict();

export const AddressUpdateOneWithoutProfileNestedInputSchema: z.ZodType<Prisma.AddressUpdateOneWithoutProfileNestedInput> = z.object({
  create: z.union([ z.lazy(() => AddressCreateWithoutProfileInputSchema),z.lazy(() => AddressUncheckedCreateWithoutProfileInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => AddressCreateOrConnectWithoutProfileInputSchema).optional(),
  upsert: z.lazy(() => AddressUpsertWithoutProfileInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => AddressWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => AddressWhereInputSchema) ]).optional(),
  connect: z.lazy(() => AddressWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => AddressUpdateToOneWithWhereWithoutProfileInputSchema),z.lazy(() => AddressUpdateWithoutProfileInputSchema),z.lazy(() => AddressUncheckedUpdateWithoutProfileInputSchema) ]).optional(),
}).strict();

export const AddressUncheckedUpdateOneWithoutProfileNestedInputSchema: z.ZodType<Prisma.AddressUncheckedUpdateOneWithoutProfileNestedInput> = z.object({
  create: z.union([ z.lazy(() => AddressCreateWithoutProfileInputSchema),z.lazy(() => AddressUncheckedCreateWithoutProfileInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => AddressCreateOrConnectWithoutProfileInputSchema).optional(),
  upsert: z.lazy(() => AddressUpsertWithoutProfileInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => AddressWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => AddressWhereInputSchema) ]).optional(),
  connect: z.lazy(() => AddressWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => AddressUpdateToOneWithWhereWithoutProfileInputSchema),z.lazy(() => AddressUpdateWithoutProfileInputSchema),z.lazy(() => AddressUncheckedUpdateWithoutProfileInputSchema) ]).optional(),
}).strict();

export const ProfileCreateNestedOneWithoutAddressInputSchema: z.ZodType<Prisma.ProfileCreateNestedOneWithoutAddressInput> = z.object({
  create: z.union([ z.lazy(() => ProfileCreateWithoutAddressInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutAddressInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => ProfileCreateOrConnectWithoutAddressInputSchema).optional(),
  connect: z.lazy(() => ProfileWhereUniqueInputSchema).optional()
}).strict();

export const NullableFloatFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableFloatFieldUpdateOperationsInput> = z.object({
  set: z.number().optional().nullable(),
  increment: z.number().optional(),
  decrement: z.number().optional(),
  multiply: z.number().optional(),
  divide: z.number().optional()
}).strict();

export const ProfileUpdateOneWithoutAddressNestedInputSchema: z.ZodType<Prisma.ProfileUpdateOneWithoutAddressNestedInput> = z.object({
  create: z.union([ z.lazy(() => ProfileCreateWithoutAddressInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutAddressInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => ProfileCreateOrConnectWithoutAddressInputSchema).optional(),
  upsert: z.lazy(() => ProfileUpsertWithoutAddressInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => ProfileWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => ProfileWhereInputSchema) ]).optional(),
  connect: z.lazy(() => ProfileWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => ProfileUpdateToOneWithWhereWithoutAddressInputSchema),z.lazy(() => ProfileUpdateWithoutAddressInputSchema),z.lazy(() => ProfileUncheckedUpdateWithoutAddressInputSchema) ]).optional(),
}).strict();

export const BlockchainCreateNestedOneWithoutSaleInputSchema: z.ZodType<Prisma.BlockchainCreateNestedOneWithoutSaleInput> = z.object({
  create: z.union([ z.lazy(() => BlockchainCreateWithoutSaleInputSchema),z.lazy(() => BlockchainUncheckedCreateWithoutSaleInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => BlockchainCreateOrConnectWithoutSaleInputSchema).optional(),
  connect: z.lazy(() => BlockchainWhereUniqueInputSchema).optional()
}).strict();

export const UserCreateNestedOneWithoutSalesInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutSalesInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutSalesInputSchema),z.lazy(() => UserUncheckedCreateWithoutSalesInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutSalesInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
}).strict();

export const SaleTransactionsCreateNestedManyWithoutSaleInputSchema: z.ZodType<Prisma.SaleTransactionsCreateNestedManyWithoutSaleInput> = z.object({
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutSaleInputSchema),z.lazy(() => SaleTransactionsCreateWithoutSaleInputSchema).array(),z.lazy(() => SaleTransactionsUncheckedCreateWithoutSaleInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutSaleInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleTransactionsCreateOrConnectWithoutSaleInputSchema),z.lazy(() => SaleTransactionsCreateOrConnectWithoutSaleInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleTransactionsCreateManySaleInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const SaleInformationCreateNestedOneWithoutSaleInputSchema: z.ZodType<Prisma.SaleInformationCreateNestedOneWithoutSaleInput> = z.object({
  create: z.union([ z.lazy(() => SaleInformationCreateWithoutSaleInputSchema),z.lazy(() => SaleInformationUncheckedCreateWithoutSaleInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => SaleInformationCreateOrConnectWithoutSaleInputSchema).optional(),
  connect: z.lazy(() => SaleInformationWhereUniqueInputSchema).optional()
}).strict();

export const DocumentCreateNestedManyWithoutSaleInputSchema: z.ZodType<Prisma.DocumentCreateNestedManyWithoutSaleInput> = z.object({
  create: z.union([ z.lazy(() => DocumentCreateWithoutSaleInputSchema),z.lazy(() => DocumentCreateWithoutSaleInputSchema).array(),z.lazy(() => DocumentUncheckedCreateWithoutSaleInputSchema),z.lazy(() => DocumentUncheckedCreateWithoutSaleInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => DocumentCreateOrConnectWithoutSaleInputSchema),z.lazy(() => DocumentCreateOrConnectWithoutSaleInputSchema).array() ]).optional(),
  createMany: z.lazy(() => DocumentCreateManySaleInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => DocumentWhereUniqueInputSchema),z.lazy(() => DocumentWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const TokenCreateNestedOneWithoutSalesInputSchema: z.ZodType<Prisma.TokenCreateNestedOneWithoutSalesInput> = z.object({
  create: z.union([ z.lazy(() => TokenCreateWithoutSalesInputSchema),z.lazy(() => TokenUncheckedCreateWithoutSalesInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => TokenCreateOrConnectWithoutSalesInputSchema).optional(),
  connect: z.lazy(() => TokenWhereUniqueInputSchema).optional()
}).strict();

export const VestingScheduleCreateNestedManyWithoutSaleInputSchema: z.ZodType<Prisma.VestingScheduleCreateNestedManyWithoutSaleInput> = z.object({
  create: z.union([ z.lazy(() => VestingScheduleCreateWithoutSaleInputSchema),z.lazy(() => VestingScheduleCreateWithoutSaleInputSchema).array(),z.lazy(() => VestingScheduleUncheckedCreateWithoutSaleInputSchema),z.lazy(() => VestingScheduleUncheckedCreateWithoutSaleInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => VestingScheduleCreateOrConnectWithoutSaleInputSchema),z.lazy(() => VestingScheduleCreateOrConnectWithoutSaleInputSchema).array() ]).optional(),
  createMany: z.lazy(() => VestingScheduleCreateManySaleInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => VestingScheduleWhereUniqueInputSchema),z.lazy(() => VestingScheduleWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const SaleTransactionsUncheckedCreateNestedManyWithoutSaleInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedCreateNestedManyWithoutSaleInput> = z.object({
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutSaleInputSchema),z.lazy(() => SaleTransactionsCreateWithoutSaleInputSchema).array(),z.lazy(() => SaleTransactionsUncheckedCreateWithoutSaleInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutSaleInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleTransactionsCreateOrConnectWithoutSaleInputSchema),z.lazy(() => SaleTransactionsCreateOrConnectWithoutSaleInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleTransactionsCreateManySaleInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const SaleInformationUncheckedCreateNestedOneWithoutSaleInputSchema: z.ZodType<Prisma.SaleInformationUncheckedCreateNestedOneWithoutSaleInput> = z.object({
  create: z.union([ z.lazy(() => SaleInformationCreateWithoutSaleInputSchema),z.lazy(() => SaleInformationUncheckedCreateWithoutSaleInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => SaleInformationCreateOrConnectWithoutSaleInputSchema).optional(),
  connect: z.lazy(() => SaleInformationWhereUniqueInputSchema).optional()
}).strict();

export const DocumentUncheckedCreateNestedManyWithoutSaleInputSchema: z.ZodType<Prisma.DocumentUncheckedCreateNestedManyWithoutSaleInput> = z.object({
  create: z.union([ z.lazy(() => DocumentCreateWithoutSaleInputSchema),z.lazy(() => DocumentCreateWithoutSaleInputSchema).array(),z.lazy(() => DocumentUncheckedCreateWithoutSaleInputSchema),z.lazy(() => DocumentUncheckedCreateWithoutSaleInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => DocumentCreateOrConnectWithoutSaleInputSchema),z.lazy(() => DocumentCreateOrConnectWithoutSaleInputSchema).array() ]).optional(),
  createMany: z.lazy(() => DocumentCreateManySaleInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => DocumentWhereUniqueInputSchema),z.lazy(() => DocumentWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const VestingScheduleUncheckedCreateNestedManyWithoutSaleInputSchema: z.ZodType<Prisma.VestingScheduleUncheckedCreateNestedManyWithoutSaleInput> = z.object({
  create: z.union([ z.lazy(() => VestingScheduleCreateWithoutSaleInputSchema),z.lazy(() => VestingScheduleCreateWithoutSaleInputSchema).array(),z.lazy(() => VestingScheduleUncheckedCreateWithoutSaleInputSchema),z.lazy(() => VestingScheduleUncheckedCreateWithoutSaleInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => VestingScheduleCreateOrConnectWithoutSaleInputSchema),z.lazy(() => VestingScheduleCreateOrConnectWithoutSaleInputSchema).array() ]).optional(),
  createMany: z.lazy(() => VestingScheduleCreateManySaleInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => VestingScheduleWhereUniqueInputSchema),z.lazy(() => VestingScheduleWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const EnumSaleStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumSaleStatusFieldUpdateOperationsInput> = z.object({
  set: z.lazy(() => SaleStatusSchema).optional()
}).strict();

export const EnumCurrencyFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumCurrencyFieldUpdateOperationsInput> = z.object({
  set: z.lazy(() => CurrencySchema).optional()
}).strict();

export const NullableIntFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableIntFieldUpdateOperationsInput> = z.object({
  set: z.number().optional().nullable(),
  increment: z.number().optional(),
  decrement: z.number().optional(),
  multiply: z.number().optional(),
  divide: z.number().optional()
}).strict();

export const DecimalFieldUpdateOperationsInputSchema: z.ZodType<Prisma.DecimalFieldUpdateOperationsInput> = z.object({
  set: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  increment: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  decrement: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  multiply: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  divide: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional()
}).strict();

export const BlockchainUpdateOneWithoutSaleNestedInputSchema: z.ZodType<Prisma.BlockchainUpdateOneWithoutSaleNestedInput> = z.object({
  create: z.union([ z.lazy(() => BlockchainCreateWithoutSaleInputSchema),z.lazy(() => BlockchainUncheckedCreateWithoutSaleInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => BlockchainCreateOrConnectWithoutSaleInputSchema).optional(),
  upsert: z.lazy(() => BlockchainUpsertWithoutSaleInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => BlockchainWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => BlockchainWhereInputSchema) ]).optional(),
  connect: z.lazy(() => BlockchainWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => BlockchainUpdateToOneWithWhereWithoutSaleInputSchema),z.lazy(() => BlockchainUpdateWithoutSaleInputSchema),z.lazy(() => BlockchainUncheckedUpdateWithoutSaleInputSchema) ]).optional(),
}).strict();

export const UserUpdateOneRequiredWithoutSalesNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutSalesNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutSalesInputSchema),z.lazy(() => UserUncheckedCreateWithoutSalesInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutSalesInputSchema).optional(),
  upsert: z.lazy(() => UserUpsertWithoutSalesInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => UserUpdateToOneWithWhereWithoutSalesInputSchema),z.lazy(() => UserUpdateWithoutSalesInputSchema),z.lazy(() => UserUncheckedUpdateWithoutSalesInputSchema) ]).optional(),
}).strict();

export const SaleTransactionsUpdateManyWithoutSaleNestedInputSchema: z.ZodType<Prisma.SaleTransactionsUpdateManyWithoutSaleNestedInput> = z.object({
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutSaleInputSchema),z.lazy(() => SaleTransactionsCreateWithoutSaleInputSchema).array(),z.lazy(() => SaleTransactionsUncheckedCreateWithoutSaleInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutSaleInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleTransactionsCreateOrConnectWithoutSaleInputSchema),z.lazy(() => SaleTransactionsCreateOrConnectWithoutSaleInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => SaleTransactionsUpsertWithWhereUniqueWithoutSaleInputSchema),z.lazy(() => SaleTransactionsUpsertWithWhereUniqueWithoutSaleInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleTransactionsCreateManySaleInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => SaleTransactionsUpdateWithWhereUniqueWithoutSaleInputSchema),z.lazy(() => SaleTransactionsUpdateWithWhereUniqueWithoutSaleInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => SaleTransactionsUpdateManyWithWhereWithoutSaleInputSchema),z.lazy(() => SaleTransactionsUpdateManyWithWhereWithoutSaleInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => SaleTransactionsScalarWhereInputSchema),z.lazy(() => SaleTransactionsScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const SaleInformationUpdateOneWithoutSaleNestedInputSchema: z.ZodType<Prisma.SaleInformationUpdateOneWithoutSaleNestedInput> = z.object({
  create: z.union([ z.lazy(() => SaleInformationCreateWithoutSaleInputSchema),z.lazy(() => SaleInformationUncheckedCreateWithoutSaleInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => SaleInformationCreateOrConnectWithoutSaleInputSchema).optional(),
  upsert: z.lazy(() => SaleInformationUpsertWithoutSaleInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => SaleInformationWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => SaleInformationWhereInputSchema) ]).optional(),
  connect: z.lazy(() => SaleInformationWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => SaleInformationUpdateToOneWithWhereWithoutSaleInputSchema),z.lazy(() => SaleInformationUpdateWithoutSaleInputSchema),z.lazy(() => SaleInformationUncheckedUpdateWithoutSaleInputSchema) ]).optional(),
}).strict();

export const DocumentUpdateManyWithoutSaleNestedInputSchema: z.ZodType<Prisma.DocumentUpdateManyWithoutSaleNestedInput> = z.object({
  create: z.union([ z.lazy(() => DocumentCreateWithoutSaleInputSchema),z.lazy(() => DocumentCreateWithoutSaleInputSchema).array(),z.lazy(() => DocumentUncheckedCreateWithoutSaleInputSchema),z.lazy(() => DocumentUncheckedCreateWithoutSaleInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => DocumentCreateOrConnectWithoutSaleInputSchema),z.lazy(() => DocumentCreateOrConnectWithoutSaleInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => DocumentUpsertWithWhereUniqueWithoutSaleInputSchema),z.lazy(() => DocumentUpsertWithWhereUniqueWithoutSaleInputSchema).array() ]).optional(),
  createMany: z.lazy(() => DocumentCreateManySaleInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => DocumentWhereUniqueInputSchema),z.lazy(() => DocumentWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => DocumentWhereUniqueInputSchema),z.lazy(() => DocumentWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => DocumentWhereUniqueInputSchema),z.lazy(() => DocumentWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => DocumentWhereUniqueInputSchema),z.lazy(() => DocumentWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => DocumentUpdateWithWhereUniqueWithoutSaleInputSchema),z.lazy(() => DocumentUpdateWithWhereUniqueWithoutSaleInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => DocumentUpdateManyWithWhereWithoutSaleInputSchema),z.lazy(() => DocumentUpdateManyWithWhereWithoutSaleInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => DocumentScalarWhereInputSchema),z.lazy(() => DocumentScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TokenUpdateOneRequiredWithoutSalesNestedInputSchema: z.ZodType<Prisma.TokenUpdateOneRequiredWithoutSalesNestedInput> = z.object({
  create: z.union([ z.lazy(() => TokenCreateWithoutSalesInputSchema),z.lazy(() => TokenUncheckedCreateWithoutSalesInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => TokenCreateOrConnectWithoutSalesInputSchema).optional(),
  upsert: z.lazy(() => TokenUpsertWithoutSalesInputSchema).optional(),
  connect: z.lazy(() => TokenWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => TokenUpdateToOneWithWhereWithoutSalesInputSchema),z.lazy(() => TokenUpdateWithoutSalesInputSchema),z.lazy(() => TokenUncheckedUpdateWithoutSalesInputSchema) ]).optional(),
}).strict();

export const VestingScheduleUpdateManyWithoutSaleNestedInputSchema: z.ZodType<Prisma.VestingScheduleUpdateManyWithoutSaleNestedInput> = z.object({
  create: z.union([ z.lazy(() => VestingScheduleCreateWithoutSaleInputSchema),z.lazy(() => VestingScheduleCreateWithoutSaleInputSchema).array(),z.lazy(() => VestingScheduleUncheckedCreateWithoutSaleInputSchema),z.lazy(() => VestingScheduleUncheckedCreateWithoutSaleInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => VestingScheduleCreateOrConnectWithoutSaleInputSchema),z.lazy(() => VestingScheduleCreateOrConnectWithoutSaleInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => VestingScheduleUpsertWithWhereUniqueWithoutSaleInputSchema),z.lazy(() => VestingScheduleUpsertWithWhereUniqueWithoutSaleInputSchema).array() ]).optional(),
  createMany: z.lazy(() => VestingScheduleCreateManySaleInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => VestingScheduleWhereUniqueInputSchema),z.lazy(() => VestingScheduleWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => VestingScheduleWhereUniqueInputSchema),z.lazy(() => VestingScheduleWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => VestingScheduleWhereUniqueInputSchema),z.lazy(() => VestingScheduleWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => VestingScheduleWhereUniqueInputSchema),z.lazy(() => VestingScheduleWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => VestingScheduleUpdateWithWhereUniqueWithoutSaleInputSchema),z.lazy(() => VestingScheduleUpdateWithWhereUniqueWithoutSaleInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => VestingScheduleUpdateManyWithWhereWithoutSaleInputSchema),z.lazy(() => VestingScheduleUpdateManyWithWhereWithoutSaleInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => VestingScheduleScalarWhereInputSchema),z.lazy(() => VestingScheduleScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const SaleTransactionsUncheckedUpdateManyWithoutSaleNestedInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedUpdateManyWithoutSaleNestedInput> = z.object({
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutSaleInputSchema),z.lazy(() => SaleTransactionsCreateWithoutSaleInputSchema).array(),z.lazy(() => SaleTransactionsUncheckedCreateWithoutSaleInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutSaleInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleTransactionsCreateOrConnectWithoutSaleInputSchema),z.lazy(() => SaleTransactionsCreateOrConnectWithoutSaleInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => SaleTransactionsUpsertWithWhereUniqueWithoutSaleInputSchema),z.lazy(() => SaleTransactionsUpsertWithWhereUniqueWithoutSaleInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleTransactionsCreateManySaleInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => SaleTransactionsUpdateWithWhereUniqueWithoutSaleInputSchema),z.lazy(() => SaleTransactionsUpdateWithWhereUniqueWithoutSaleInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => SaleTransactionsUpdateManyWithWhereWithoutSaleInputSchema),z.lazy(() => SaleTransactionsUpdateManyWithWhereWithoutSaleInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => SaleTransactionsScalarWhereInputSchema),z.lazy(() => SaleTransactionsScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const SaleInformationUncheckedUpdateOneWithoutSaleNestedInputSchema: z.ZodType<Prisma.SaleInformationUncheckedUpdateOneWithoutSaleNestedInput> = z.object({
  create: z.union([ z.lazy(() => SaleInformationCreateWithoutSaleInputSchema),z.lazy(() => SaleInformationUncheckedCreateWithoutSaleInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => SaleInformationCreateOrConnectWithoutSaleInputSchema).optional(),
  upsert: z.lazy(() => SaleInformationUpsertWithoutSaleInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => SaleInformationWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => SaleInformationWhereInputSchema) ]).optional(),
  connect: z.lazy(() => SaleInformationWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => SaleInformationUpdateToOneWithWhereWithoutSaleInputSchema),z.lazy(() => SaleInformationUpdateWithoutSaleInputSchema),z.lazy(() => SaleInformationUncheckedUpdateWithoutSaleInputSchema) ]).optional(),
}).strict();

export const DocumentUncheckedUpdateManyWithoutSaleNestedInputSchema: z.ZodType<Prisma.DocumentUncheckedUpdateManyWithoutSaleNestedInput> = z.object({
  create: z.union([ z.lazy(() => DocumentCreateWithoutSaleInputSchema),z.lazy(() => DocumentCreateWithoutSaleInputSchema).array(),z.lazy(() => DocumentUncheckedCreateWithoutSaleInputSchema),z.lazy(() => DocumentUncheckedCreateWithoutSaleInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => DocumentCreateOrConnectWithoutSaleInputSchema),z.lazy(() => DocumentCreateOrConnectWithoutSaleInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => DocumentUpsertWithWhereUniqueWithoutSaleInputSchema),z.lazy(() => DocumentUpsertWithWhereUniqueWithoutSaleInputSchema).array() ]).optional(),
  createMany: z.lazy(() => DocumentCreateManySaleInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => DocumentWhereUniqueInputSchema),z.lazy(() => DocumentWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => DocumentWhereUniqueInputSchema),z.lazy(() => DocumentWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => DocumentWhereUniqueInputSchema),z.lazy(() => DocumentWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => DocumentWhereUniqueInputSchema),z.lazy(() => DocumentWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => DocumentUpdateWithWhereUniqueWithoutSaleInputSchema),z.lazy(() => DocumentUpdateWithWhereUniqueWithoutSaleInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => DocumentUpdateManyWithWhereWithoutSaleInputSchema),z.lazy(() => DocumentUpdateManyWithWhereWithoutSaleInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => DocumentScalarWhereInputSchema),z.lazy(() => DocumentScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const VestingScheduleUncheckedUpdateManyWithoutSaleNestedInputSchema: z.ZodType<Prisma.VestingScheduleUncheckedUpdateManyWithoutSaleNestedInput> = z.object({
  create: z.union([ z.lazy(() => VestingScheduleCreateWithoutSaleInputSchema),z.lazy(() => VestingScheduleCreateWithoutSaleInputSchema).array(),z.lazy(() => VestingScheduleUncheckedCreateWithoutSaleInputSchema),z.lazy(() => VestingScheduleUncheckedCreateWithoutSaleInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => VestingScheduleCreateOrConnectWithoutSaleInputSchema),z.lazy(() => VestingScheduleCreateOrConnectWithoutSaleInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => VestingScheduleUpsertWithWhereUniqueWithoutSaleInputSchema),z.lazy(() => VestingScheduleUpsertWithWhereUniqueWithoutSaleInputSchema).array() ]).optional(),
  createMany: z.lazy(() => VestingScheduleCreateManySaleInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => VestingScheduleWhereUniqueInputSchema),z.lazy(() => VestingScheduleWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => VestingScheduleWhereUniqueInputSchema),z.lazy(() => VestingScheduleWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => VestingScheduleWhereUniqueInputSchema),z.lazy(() => VestingScheduleWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => VestingScheduleWhereUniqueInputSchema),z.lazy(() => VestingScheduleWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => VestingScheduleUpdateWithWhereUniqueWithoutSaleInputSchema),z.lazy(() => VestingScheduleUpdateWithWhereUniqueWithoutSaleInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => VestingScheduleUpdateManyWithWhereWithoutSaleInputSchema),z.lazy(() => VestingScheduleUpdateManyWithWhereWithoutSaleInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => VestingScheduleScalarWhereInputSchema),z.lazy(() => VestingScheduleScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const SaleCreateNestedOneWithoutDocumentsInputSchema: z.ZodType<Prisma.SaleCreateNestedOneWithoutDocumentsInput> = z.object({
  create: z.union([ z.lazy(() => SaleCreateWithoutDocumentsInputSchema),z.lazy(() => SaleUncheckedCreateWithoutDocumentsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => SaleCreateOrConnectWithoutDocumentsInputSchema).optional(),
  connect: z.lazy(() => SaleWhereUniqueInputSchema).optional()
}).strict();

export const UserCreateNestedOneWithoutDocumentInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutDocumentInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutDocumentInputSchema),z.lazy(() => UserUncheckedCreateWithoutDocumentInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutDocumentInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
}).strict();

export const SaleUpdateOneWithoutDocumentsNestedInputSchema: z.ZodType<Prisma.SaleUpdateOneWithoutDocumentsNestedInput> = z.object({
  create: z.union([ z.lazy(() => SaleCreateWithoutDocumentsInputSchema),z.lazy(() => SaleUncheckedCreateWithoutDocumentsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => SaleCreateOrConnectWithoutDocumentsInputSchema).optional(),
  upsert: z.lazy(() => SaleUpsertWithoutDocumentsInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => SaleWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => SaleWhereInputSchema) ]).optional(),
  connect: z.lazy(() => SaleWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => SaleUpdateToOneWithWhereWithoutDocumentsInputSchema),z.lazy(() => SaleUpdateWithoutDocumentsInputSchema),z.lazy(() => SaleUncheckedUpdateWithoutDocumentsInputSchema) ]).optional(),
}).strict();

export const UserUpdateOneWithoutDocumentNestedInputSchema: z.ZodType<Prisma.UserUpdateOneWithoutDocumentNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutDocumentInputSchema),z.lazy(() => UserUncheckedCreateWithoutDocumentInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutDocumentInputSchema).optional(),
  upsert: z.lazy(() => UserUpsertWithoutDocumentInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => UserWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => UserWhereInputSchema) ]).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => UserUpdateToOneWithWhereWithoutDocumentInputSchema),z.lazy(() => UserUpdateWithoutDocumentInputSchema),z.lazy(() => UserUncheckedUpdateWithoutDocumentInputSchema) ]).optional(),
}).strict();

export const SaleCreateNestedOneWithoutVestingSchedulesInputSchema: z.ZodType<Prisma.SaleCreateNestedOneWithoutVestingSchedulesInput> = z.object({
  create: z.union([ z.lazy(() => SaleCreateWithoutVestingSchedulesInputSchema),z.lazy(() => SaleUncheckedCreateWithoutVestingSchedulesInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => SaleCreateOrConnectWithoutVestingSchedulesInputSchema).optional(),
  connect: z.lazy(() => SaleWhereUniqueInputSchema).optional()
}).strict();

export const FloatFieldUpdateOperationsInputSchema: z.ZodType<Prisma.FloatFieldUpdateOperationsInput> = z.object({
  set: z.number().optional(),
  increment: z.number().optional(),
  decrement: z.number().optional(),
  multiply: z.number().optional(),
  divide: z.number().optional()
}).strict();

export const SaleUpdateOneRequiredWithoutVestingSchedulesNestedInputSchema: z.ZodType<Prisma.SaleUpdateOneRequiredWithoutVestingSchedulesNestedInput> = z.object({
  create: z.union([ z.lazy(() => SaleCreateWithoutVestingSchedulesInputSchema),z.lazy(() => SaleUncheckedCreateWithoutVestingSchedulesInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => SaleCreateOrConnectWithoutVestingSchedulesInputSchema).optional(),
  upsert: z.lazy(() => SaleUpsertWithoutVestingSchedulesInputSchema).optional(),
  connect: z.lazy(() => SaleWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => SaleUpdateToOneWithWhereWithoutVestingSchedulesInputSchema),z.lazy(() => SaleUpdateWithoutVestingSchedulesInputSchema),z.lazy(() => SaleUncheckedUpdateWithoutVestingSchedulesInputSchema) ]).optional(),
}).strict();

export const SaleTransactionsCreateNestedOneWithoutTokenDistributionsInputSchema: z.ZodType<Prisma.SaleTransactionsCreateNestedOneWithoutTokenDistributionsInput> = z.object({
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutTokenDistributionsInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutTokenDistributionsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => SaleTransactionsCreateOrConnectWithoutTokenDistributionsInputSchema).optional(),
  connect: z.lazy(() => SaleTransactionsWhereUniqueInputSchema).optional()
}).strict();

export const SaleTransactionsUpdateOneRequiredWithoutTokenDistributionsNestedInputSchema: z.ZodType<Prisma.SaleTransactionsUpdateOneRequiredWithoutTokenDistributionsNestedInput> = z.object({
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutTokenDistributionsInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutTokenDistributionsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => SaleTransactionsCreateOrConnectWithoutTokenDistributionsInputSchema).optional(),
  upsert: z.lazy(() => SaleTransactionsUpsertWithoutTokenDistributionsInputSchema).optional(),
  connect: z.lazy(() => SaleTransactionsWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => SaleTransactionsUpdateToOneWithWhereWithoutTokenDistributionsInputSchema),z.lazy(() => SaleTransactionsUpdateWithoutTokenDistributionsInputSchema),z.lazy(() => SaleTransactionsUncheckedUpdateWithoutTokenDistributionsInputSchema) ]).optional(),
}).strict();

export const SaleCreateNestedOneWithoutSaleInformationInputSchema: z.ZodType<Prisma.SaleCreateNestedOneWithoutSaleInformationInput> = z.object({
  create: z.union([ z.lazy(() => SaleCreateWithoutSaleInformationInputSchema),z.lazy(() => SaleUncheckedCreateWithoutSaleInformationInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => SaleCreateOrConnectWithoutSaleInformationInputSchema).optional(),
  connect: z.lazy(() => SaleWhereUniqueInputSchema).optional()
}).strict();

export const SaleUpdateOneRequiredWithoutSaleInformationNestedInputSchema: z.ZodType<Prisma.SaleUpdateOneRequiredWithoutSaleInformationNestedInput> = z.object({
  create: z.union([ z.lazy(() => SaleCreateWithoutSaleInformationInputSchema),z.lazy(() => SaleUncheckedCreateWithoutSaleInformationInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => SaleCreateOrConnectWithoutSaleInformationInputSchema).optional(),
  upsert: z.lazy(() => SaleUpsertWithoutSaleInformationInputSchema).optional(),
  connect: z.lazy(() => SaleWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => SaleUpdateToOneWithWhereWithoutSaleInformationInputSchema),z.lazy(() => SaleUpdateWithoutSaleInformationInputSchema),z.lazy(() => SaleUncheckedUpdateWithoutSaleInformationInputSchema) ]).optional(),
}).strict();

export const UserCreateNestedOneWithoutTransactionsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutTransactionsInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutTransactionsInputSchema),z.lazy(() => UserUncheckedCreateWithoutTransactionsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutTransactionsInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
}).strict();

export const SaleCreateNestedOneWithoutTransactionsInputSchema: z.ZodType<Prisma.SaleCreateNestedOneWithoutTransactionsInput> = z.object({
  create: z.union([ z.lazy(() => SaleCreateWithoutTransactionsInputSchema),z.lazy(() => SaleUncheckedCreateWithoutTransactionsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => SaleCreateOrConnectWithoutTransactionsInputSchema).optional(),
  connect: z.lazy(() => SaleWhereUniqueInputSchema).optional()
}).strict();

export const BlockchainCreateNestedOneWithoutTransactionsInputSchema: z.ZodType<Prisma.BlockchainCreateNestedOneWithoutTransactionsInput> = z.object({
  create: z.union([ z.lazy(() => BlockchainCreateWithoutTransactionsInputSchema),z.lazy(() => BlockchainUncheckedCreateWithoutTransactionsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => BlockchainCreateOrConnectWithoutTransactionsInputSchema).optional(),
  connect: z.lazy(() => BlockchainWhereUniqueInputSchema).optional()
}).strict();

export const UserCreateNestedOneWithoutTransactionApprovalsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutTransactionApprovalsInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutTransactionApprovalsInputSchema),z.lazy(() => UserUncheckedCreateWithoutTransactionApprovalsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutTransactionApprovalsInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
}).strict();

export const TransactionAuditCreateNestedManyWithoutTransactionInputSchema: z.ZodType<Prisma.TransactionAuditCreateNestedManyWithoutTransactionInput> = z.object({
  create: z.union([ z.lazy(() => TransactionAuditCreateWithoutTransactionInputSchema),z.lazy(() => TransactionAuditCreateWithoutTransactionInputSchema).array(),z.lazy(() => TransactionAuditUncheckedCreateWithoutTransactionInputSchema),z.lazy(() => TransactionAuditUncheckedCreateWithoutTransactionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TransactionAuditCreateOrConnectWithoutTransactionInputSchema),z.lazy(() => TransactionAuditCreateOrConnectWithoutTransactionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TransactionAuditCreateManyTransactionInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => TransactionAuditWhereUniqueInputSchema),z.lazy(() => TransactionAuditWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const TokenDistributionCreateNestedManyWithoutTransactionInputSchema: z.ZodType<Prisma.TokenDistributionCreateNestedManyWithoutTransactionInput> = z.object({
  create: z.union([ z.lazy(() => TokenDistributionCreateWithoutTransactionInputSchema),z.lazy(() => TokenDistributionCreateWithoutTransactionInputSchema).array(),z.lazy(() => TokenDistributionUncheckedCreateWithoutTransactionInputSchema),z.lazy(() => TokenDistributionUncheckedCreateWithoutTransactionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TokenDistributionCreateOrConnectWithoutTransactionInputSchema),z.lazy(() => TokenDistributionCreateOrConnectWithoutTransactionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TokenDistributionCreateManyTransactionInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => TokenDistributionWhereUniqueInputSchema),z.lazy(() => TokenDistributionWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const TransactionAuditUncheckedCreateNestedManyWithoutTransactionInputSchema: z.ZodType<Prisma.TransactionAuditUncheckedCreateNestedManyWithoutTransactionInput> = z.object({
  create: z.union([ z.lazy(() => TransactionAuditCreateWithoutTransactionInputSchema),z.lazy(() => TransactionAuditCreateWithoutTransactionInputSchema).array(),z.lazy(() => TransactionAuditUncheckedCreateWithoutTransactionInputSchema),z.lazy(() => TransactionAuditUncheckedCreateWithoutTransactionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TransactionAuditCreateOrConnectWithoutTransactionInputSchema),z.lazy(() => TransactionAuditCreateOrConnectWithoutTransactionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TransactionAuditCreateManyTransactionInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => TransactionAuditWhereUniqueInputSchema),z.lazy(() => TransactionAuditWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const TokenDistributionUncheckedCreateNestedManyWithoutTransactionInputSchema: z.ZodType<Prisma.TokenDistributionUncheckedCreateNestedManyWithoutTransactionInput> = z.object({
  create: z.union([ z.lazy(() => TokenDistributionCreateWithoutTransactionInputSchema),z.lazy(() => TokenDistributionCreateWithoutTransactionInputSchema).array(),z.lazy(() => TokenDistributionUncheckedCreateWithoutTransactionInputSchema),z.lazy(() => TokenDistributionUncheckedCreateWithoutTransactionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TokenDistributionCreateOrConnectWithoutTransactionInputSchema),z.lazy(() => TokenDistributionCreateOrConnectWithoutTransactionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TokenDistributionCreateManyTransactionInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => TokenDistributionWhereUniqueInputSchema),z.lazy(() => TokenDistributionWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const EnumFOPFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumFOPFieldUpdateOperationsInput> = z.object({
  set: z.lazy(() => FOPSchema).optional()
}).strict();

export const EnumTransactionStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumTransactionStatusFieldUpdateOperationsInput> = z.object({
  set: z.lazy(() => TransactionStatusSchema).optional()
}).strict();

export const UserUpdateOneRequiredWithoutTransactionsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutTransactionsNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutTransactionsInputSchema),z.lazy(() => UserUncheckedCreateWithoutTransactionsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutTransactionsInputSchema).optional(),
  upsert: z.lazy(() => UserUpsertWithoutTransactionsInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => UserUpdateToOneWithWhereWithoutTransactionsInputSchema),z.lazy(() => UserUpdateWithoutTransactionsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutTransactionsInputSchema) ]).optional(),
}).strict();

export const SaleUpdateOneRequiredWithoutTransactionsNestedInputSchema: z.ZodType<Prisma.SaleUpdateOneRequiredWithoutTransactionsNestedInput> = z.object({
  create: z.union([ z.lazy(() => SaleCreateWithoutTransactionsInputSchema),z.lazy(() => SaleUncheckedCreateWithoutTransactionsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => SaleCreateOrConnectWithoutTransactionsInputSchema).optional(),
  upsert: z.lazy(() => SaleUpsertWithoutTransactionsInputSchema).optional(),
  connect: z.lazy(() => SaleWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => SaleUpdateToOneWithWhereWithoutTransactionsInputSchema),z.lazy(() => SaleUpdateWithoutTransactionsInputSchema),z.lazy(() => SaleUncheckedUpdateWithoutTransactionsInputSchema) ]).optional(),
}).strict();

export const BlockchainUpdateOneWithoutTransactionsNestedInputSchema: z.ZodType<Prisma.BlockchainUpdateOneWithoutTransactionsNestedInput> = z.object({
  create: z.union([ z.lazy(() => BlockchainCreateWithoutTransactionsInputSchema),z.lazy(() => BlockchainUncheckedCreateWithoutTransactionsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => BlockchainCreateOrConnectWithoutTransactionsInputSchema).optional(),
  upsert: z.lazy(() => BlockchainUpsertWithoutTransactionsInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => BlockchainWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => BlockchainWhereInputSchema) ]).optional(),
  connect: z.lazy(() => BlockchainWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => BlockchainUpdateToOneWithWhereWithoutTransactionsInputSchema),z.lazy(() => BlockchainUpdateWithoutTransactionsInputSchema),z.lazy(() => BlockchainUncheckedUpdateWithoutTransactionsInputSchema) ]).optional(),
}).strict();

export const UserUpdateOneWithoutTransactionApprovalsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneWithoutTransactionApprovalsNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutTransactionApprovalsInputSchema),z.lazy(() => UserUncheckedCreateWithoutTransactionApprovalsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutTransactionApprovalsInputSchema).optional(),
  upsert: z.lazy(() => UserUpsertWithoutTransactionApprovalsInputSchema).optional(),
  disconnect: z.union([ z.boolean(),z.lazy(() => UserWhereInputSchema) ]).optional(),
  delete: z.union([ z.boolean(),z.lazy(() => UserWhereInputSchema) ]).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => UserUpdateToOneWithWhereWithoutTransactionApprovalsInputSchema),z.lazy(() => UserUpdateWithoutTransactionApprovalsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutTransactionApprovalsInputSchema) ]).optional(),
}).strict();

export const TransactionAuditUpdateManyWithoutTransactionNestedInputSchema: z.ZodType<Prisma.TransactionAuditUpdateManyWithoutTransactionNestedInput> = z.object({
  create: z.union([ z.lazy(() => TransactionAuditCreateWithoutTransactionInputSchema),z.lazy(() => TransactionAuditCreateWithoutTransactionInputSchema).array(),z.lazy(() => TransactionAuditUncheckedCreateWithoutTransactionInputSchema),z.lazy(() => TransactionAuditUncheckedCreateWithoutTransactionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TransactionAuditCreateOrConnectWithoutTransactionInputSchema),z.lazy(() => TransactionAuditCreateOrConnectWithoutTransactionInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => TransactionAuditUpsertWithWhereUniqueWithoutTransactionInputSchema),z.lazy(() => TransactionAuditUpsertWithWhereUniqueWithoutTransactionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TransactionAuditCreateManyTransactionInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => TransactionAuditWhereUniqueInputSchema),z.lazy(() => TransactionAuditWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => TransactionAuditWhereUniqueInputSchema),z.lazy(() => TransactionAuditWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => TransactionAuditWhereUniqueInputSchema),z.lazy(() => TransactionAuditWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => TransactionAuditWhereUniqueInputSchema),z.lazy(() => TransactionAuditWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => TransactionAuditUpdateWithWhereUniqueWithoutTransactionInputSchema),z.lazy(() => TransactionAuditUpdateWithWhereUniqueWithoutTransactionInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => TransactionAuditUpdateManyWithWhereWithoutTransactionInputSchema),z.lazy(() => TransactionAuditUpdateManyWithWhereWithoutTransactionInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => TransactionAuditScalarWhereInputSchema),z.lazy(() => TransactionAuditScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TokenDistributionUpdateManyWithoutTransactionNestedInputSchema: z.ZodType<Prisma.TokenDistributionUpdateManyWithoutTransactionNestedInput> = z.object({
  create: z.union([ z.lazy(() => TokenDistributionCreateWithoutTransactionInputSchema),z.lazy(() => TokenDistributionCreateWithoutTransactionInputSchema).array(),z.lazy(() => TokenDistributionUncheckedCreateWithoutTransactionInputSchema),z.lazy(() => TokenDistributionUncheckedCreateWithoutTransactionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TokenDistributionCreateOrConnectWithoutTransactionInputSchema),z.lazy(() => TokenDistributionCreateOrConnectWithoutTransactionInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => TokenDistributionUpsertWithWhereUniqueWithoutTransactionInputSchema),z.lazy(() => TokenDistributionUpsertWithWhereUniqueWithoutTransactionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TokenDistributionCreateManyTransactionInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => TokenDistributionWhereUniqueInputSchema),z.lazy(() => TokenDistributionWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => TokenDistributionWhereUniqueInputSchema),z.lazy(() => TokenDistributionWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => TokenDistributionWhereUniqueInputSchema),z.lazy(() => TokenDistributionWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => TokenDistributionWhereUniqueInputSchema),z.lazy(() => TokenDistributionWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => TokenDistributionUpdateWithWhereUniqueWithoutTransactionInputSchema),z.lazy(() => TokenDistributionUpdateWithWhereUniqueWithoutTransactionInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => TokenDistributionUpdateManyWithWhereWithoutTransactionInputSchema),z.lazy(() => TokenDistributionUpdateManyWithWhereWithoutTransactionInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => TokenDistributionScalarWhereInputSchema),z.lazy(() => TokenDistributionScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TransactionAuditUncheckedUpdateManyWithoutTransactionNestedInputSchema: z.ZodType<Prisma.TransactionAuditUncheckedUpdateManyWithoutTransactionNestedInput> = z.object({
  create: z.union([ z.lazy(() => TransactionAuditCreateWithoutTransactionInputSchema),z.lazy(() => TransactionAuditCreateWithoutTransactionInputSchema).array(),z.lazy(() => TransactionAuditUncheckedCreateWithoutTransactionInputSchema),z.lazy(() => TransactionAuditUncheckedCreateWithoutTransactionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TransactionAuditCreateOrConnectWithoutTransactionInputSchema),z.lazy(() => TransactionAuditCreateOrConnectWithoutTransactionInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => TransactionAuditUpsertWithWhereUniqueWithoutTransactionInputSchema),z.lazy(() => TransactionAuditUpsertWithWhereUniqueWithoutTransactionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TransactionAuditCreateManyTransactionInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => TransactionAuditWhereUniqueInputSchema),z.lazy(() => TransactionAuditWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => TransactionAuditWhereUniqueInputSchema),z.lazy(() => TransactionAuditWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => TransactionAuditWhereUniqueInputSchema),z.lazy(() => TransactionAuditWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => TransactionAuditWhereUniqueInputSchema),z.lazy(() => TransactionAuditWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => TransactionAuditUpdateWithWhereUniqueWithoutTransactionInputSchema),z.lazy(() => TransactionAuditUpdateWithWhereUniqueWithoutTransactionInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => TransactionAuditUpdateManyWithWhereWithoutTransactionInputSchema),z.lazy(() => TransactionAuditUpdateManyWithWhereWithoutTransactionInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => TransactionAuditScalarWhereInputSchema),z.lazy(() => TransactionAuditScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TokenDistributionUncheckedUpdateManyWithoutTransactionNestedInputSchema: z.ZodType<Prisma.TokenDistributionUncheckedUpdateManyWithoutTransactionNestedInput> = z.object({
  create: z.union([ z.lazy(() => TokenDistributionCreateWithoutTransactionInputSchema),z.lazy(() => TokenDistributionCreateWithoutTransactionInputSchema).array(),z.lazy(() => TokenDistributionUncheckedCreateWithoutTransactionInputSchema),z.lazy(() => TokenDistributionUncheckedCreateWithoutTransactionInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TokenDistributionCreateOrConnectWithoutTransactionInputSchema),z.lazy(() => TokenDistributionCreateOrConnectWithoutTransactionInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => TokenDistributionUpsertWithWhereUniqueWithoutTransactionInputSchema),z.lazy(() => TokenDistributionUpsertWithWhereUniqueWithoutTransactionInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TokenDistributionCreateManyTransactionInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => TokenDistributionWhereUniqueInputSchema),z.lazy(() => TokenDistributionWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => TokenDistributionWhereUniqueInputSchema),z.lazy(() => TokenDistributionWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => TokenDistributionWhereUniqueInputSchema),z.lazy(() => TokenDistributionWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => TokenDistributionWhereUniqueInputSchema),z.lazy(() => TokenDistributionWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => TokenDistributionUpdateWithWhereUniqueWithoutTransactionInputSchema),z.lazy(() => TokenDistributionUpdateWithWhereUniqueWithoutTransactionInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => TokenDistributionUpdateManyWithWhereWithoutTransactionInputSchema),z.lazy(() => TokenDistributionUpdateManyWithWhereWithoutTransactionInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => TokenDistributionScalarWhereInputSchema),z.lazy(() => TokenDistributionScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const SaleTransactionsCreateNestedManyWithoutBlockchainInputSchema: z.ZodType<Prisma.SaleTransactionsCreateNestedManyWithoutBlockchainInput> = z.object({
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutBlockchainInputSchema),z.lazy(() => SaleTransactionsCreateWithoutBlockchainInputSchema).array(),z.lazy(() => SaleTransactionsUncheckedCreateWithoutBlockchainInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutBlockchainInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleTransactionsCreateOrConnectWithoutBlockchainInputSchema),z.lazy(() => SaleTransactionsCreateOrConnectWithoutBlockchainInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleTransactionsCreateManyBlockchainInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const TokensOnBlockchainsCreateNestedManyWithoutBlockchainInputSchema: z.ZodType<Prisma.TokensOnBlockchainsCreateNestedManyWithoutBlockchainInput> = z.object({
  create: z.union([ z.lazy(() => TokensOnBlockchainsCreateWithoutBlockchainInputSchema),z.lazy(() => TokensOnBlockchainsCreateWithoutBlockchainInputSchema).array(),z.lazy(() => TokensOnBlockchainsUncheckedCreateWithoutBlockchainInputSchema),z.lazy(() => TokensOnBlockchainsUncheckedCreateWithoutBlockchainInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TokensOnBlockchainsCreateOrConnectWithoutBlockchainInputSchema),z.lazy(() => TokensOnBlockchainsCreateOrConnectWithoutBlockchainInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TokensOnBlockchainsCreateManyBlockchainInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const SaleCreateNestedManyWithoutBlockchainInputSchema: z.ZodType<Prisma.SaleCreateNestedManyWithoutBlockchainInput> = z.object({
  create: z.union([ z.lazy(() => SaleCreateWithoutBlockchainInputSchema),z.lazy(() => SaleCreateWithoutBlockchainInputSchema).array(),z.lazy(() => SaleUncheckedCreateWithoutBlockchainInputSchema),z.lazy(() => SaleUncheckedCreateWithoutBlockchainInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleCreateOrConnectWithoutBlockchainInputSchema),z.lazy(() => SaleCreateOrConnectWithoutBlockchainInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleCreateManyBlockchainInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const SaleTransactionsUncheckedCreateNestedManyWithoutBlockchainInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedCreateNestedManyWithoutBlockchainInput> = z.object({
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutBlockchainInputSchema),z.lazy(() => SaleTransactionsCreateWithoutBlockchainInputSchema).array(),z.lazy(() => SaleTransactionsUncheckedCreateWithoutBlockchainInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutBlockchainInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleTransactionsCreateOrConnectWithoutBlockchainInputSchema),z.lazy(() => SaleTransactionsCreateOrConnectWithoutBlockchainInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleTransactionsCreateManyBlockchainInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const TokensOnBlockchainsUncheckedCreateNestedManyWithoutBlockchainInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUncheckedCreateNestedManyWithoutBlockchainInput> = z.object({
  create: z.union([ z.lazy(() => TokensOnBlockchainsCreateWithoutBlockchainInputSchema),z.lazy(() => TokensOnBlockchainsCreateWithoutBlockchainInputSchema).array(),z.lazy(() => TokensOnBlockchainsUncheckedCreateWithoutBlockchainInputSchema),z.lazy(() => TokensOnBlockchainsUncheckedCreateWithoutBlockchainInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TokensOnBlockchainsCreateOrConnectWithoutBlockchainInputSchema),z.lazy(() => TokensOnBlockchainsCreateOrConnectWithoutBlockchainInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TokensOnBlockchainsCreateManyBlockchainInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const SaleUncheckedCreateNestedManyWithoutBlockchainInputSchema: z.ZodType<Prisma.SaleUncheckedCreateNestedManyWithoutBlockchainInput> = z.object({
  create: z.union([ z.lazy(() => SaleCreateWithoutBlockchainInputSchema),z.lazy(() => SaleCreateWithoutBlockchainInputSchema).array(),z.lazy(() => SaleUncheckedCreateWithoutBlockchainInputSchema),z.lazy(() => SaleUncheckedCreateWithoutBlockchainInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleCreateOrConnectWithoutBlockchainInputSchema),z.lazy(() => SaleCreateOrConnectWithoutBlockchainInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleCreateManyBlockchainInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const SaleTransactionsUpdateManyWithoutBlockchainNestedInputSchema: z.ZodType<Prisma.SaleTransactionsUpdateManyWithoutBlockchainNestedInput> = z.object({
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutBlockchainInputSchema),z.lazy(() => SaleTransactionsCreateWithoutBlockchainInputSchema).array(),z.lazy(() => SaleTransactionsUncheckedCreateWithoutBlockchainInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutBlockchainInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleTransactionsCreateOrConnectWithoutBlockchainInputSchema),z.lazy(() => SaleTransactionsCreateOrConnectWithoutBlockchainInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => SaleTransactionsUpsertWithWhereUniqueWithoutBlockchainInputSchema),z.lazy(() => SaleTransactionsUpsertWithWhereUniqueWithoutBlockchainInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleTransactionsCreateManyBlockchainInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => SaleTransactionsUpdateWithWhereUniqueWithoutBlockchainInputSchema),z.lazy(() => SaleTransactionsUpdateWithWhereUniqueWithoutBlockchainInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => SaleTransactionsUpdateManyWithWhereWithoutBlockchainInputSchema),z.lazy(() => SaleTransactionsUpdateManyWithWhereWithoutBlockchainInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => SaleTransactionsScalarWhereInputSchema),z.lazy(() => SaleTransactionsScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TokensOnBlockchainsUpdateManyWithoutBlockchainNestedInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUpdateManyWithoutBlockchainNestedInput> = z.object({
  create: z.union([ z.lazy(() => TokensOnBlockchainsCreateWithoutBlockchainInputSchema),z.lazy(() => TokensOnBlockchainsCreateWithoutBlockchainInputSchema).array(),z.lazy(() => TokensOnBlockchainsUncheckedCreateWithoutBlockchainInputSchema),z.lazy(() => TokensOnBlockchainsUncheckedCreateWithoutBlockchainInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TokensOnBlockchainsCreateOrConnectWithoutBlockchainInputSchema),z.lazy(() => TokensOnBlockchainsCreateOrConnectWithoutBlockchainInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => TokensOnBlockchainsUpsertWithWhereUniqueWithoutBlockchainInputSchema),z.lazy(() => TokensOnBlockchainsUpsertWithWhereUniqueWithoutBlockchainInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TokensOnBlockchainsCreateManyBlockchainInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => TokensOnBlockchainsUpdateWithWhereUniqueWithoutBlockchainInputSchema),z.lazy(() => TokensOnBlockchainsUpdateWithWhereUniqueWithoutBlockchainInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => TokensOnBlockchainsUpdateManyWithWhereWithoutBlockchainInputSchema),z.lazy(() => TokensOnBlockchainsUpdateManyWithWhereWithoutBlockchainInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => TokensOnBlockchainsScalarWhereInputSchema),z.lazy(() => TokensOnBlockchainsScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const SaleUpdateManyWithoutBlockchainNestedInputSchema: z.ZodType<Prisma.SaleUpdateManyWithoutBlockchainNestedInput> = z.object({
  create: z.union([ z.lazy(() => SaleCreateWithoutBlockchainInputSchema),z.lazy(() => SaleCreateWithoutBlockchainInputSchema).array(),z.lazy(() => SaleUncheckedCreateWithoutBlockchainInputSchema),z.lazy(() => SaleUncheckedCreateWithoutBlockchainInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleCreateOrConnectWithoutBlockchainInputSchema),z.lazy(() => SaleCreateOrConnectWithoutBlockchainInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => SaleUpsertWithWhereUniqueWithoutBlockchainInputSchema),z.lazy(() => SaleUpsertWithWhereUniqueWithoutBlockchainInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleCreateManyBlockchainInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => SaleUpdateWithWhereUniqueWithoutBlockchainInputSchema),z.lazy(() => SaleUpdateWithWhereUniqueWithoutBlockchainInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => SaleUpdateManyWithWhereWithoutBlockchainInputSchema),z.lazy(() => SaleUpdateManyWithWhereWithoutBlockchainInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => SaleScalarWhereInputSchema),z.lazy(() => SaleScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const SaleTransactionsUncheckedUpdateManyWithoutBlockchainNestedInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedUpdateManyWithoutBlockchainNestedInput> = z.object({
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutBlockchainInputSchema),z.lazy(() => SaleTransactionsCreateWithoutBlockchainInputSchema).array(),z.lazy(() => SaleTransactionsUncheckedCreateWithoutBlockchainInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutBlockchainInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleTransactionsCreateOrConnectWithoutBlockchainInputSchema),z.lazy(() => SaleTransactionsCreateOrConnectWithoutBlockchainInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => SaleTransactionsUpsertWithWhereUniqueWithoutBlockchainInputSchema),z.lazy(() => SaleTransactionsUpsertWithWhereUniqueWithoutBlockchainInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleTransactionsCreateManyBlockchainInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => SaleTransactionsWhereUniqueInputSchema),z.lazy(() => SaleTransactionsWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => SaleTransactionsUpdateWithWhereUniqueWithoutBlockchainInputSchema),z.lazy(() => SaleTransactionsUpdateWithWhereUniqueWithoutBlockchainInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => SaleTransactionsUpdateManyWithWhereWithoutBlockchainInputSchema),z.lazy(() => SaleTransactionsUpdateManyWithWhereWithoutBlockchainInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => SaleTransactionsScalarWhereInputSchema),z.lazy(() => SaleTransactionsScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TokensOnBlockchainsUncheckedUpdateManyWithoutBlockchainNestedInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUncheckedUpdateManyWithoutBlockchainNestedInput> = z.object({
  create: z.union([ z.lazy(() => TokensOnBlockchainsCreateWithoutBlockchainInputSchema),z.lazy(() => TokensOnBlockchainsCreateWithoutBlockchainInputSchema).array(),z.lazy(() => TokensOnBlockchainsUncheckedCreateWithoutBlockchainInputSchema),z.lazy(() => TokensOnBlockchainsUncheckedCreateWithoutBlockchainInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TokensOnBlockchainsCreateOrConnectWithoutBlockchainInputSchema),z.lazy(() => TokensOnBlockchainsCreateOrConnectWithoutBlockchainInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => TokensOnBlockchainsUpsertWithWhereUniqueWithoutBlockchainInputSchema),z.lazy(() => TokensOnBlockchainsUpsertWithWhereUniqueWithoutBlockchainInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TokensOnBlockchainsCreateManyBlockchainInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => TokensOnBlockchainsUpdateWithWhereUniqueWithoutBlockchainInputSchema),z.lazy(() => TokensOnBlockchainsUpdateWithWhereUniqueWithoutBlockchainInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => TokensOnBlockchainsUpdateManyWithWhereWithoutBlockchainInputSchema),z.lazy(() => TokensOnBlockchainsUpdateManyWithWhereWithoutBlockchainInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => TokensOnBlockchainsScalarWhereInputSchema),z.lazy(() => TokensOnBlockchainsScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const SaleUncheckedUpdateManyWithoutBlockchainNestedInputSchema: z.ZodType<Prisma.SaleUncheckedUpdateManyWithoutBlockchainNestedInput> = z.object({
  create: z.union([ z.lazy(() => SaleCreateWithoutBlockchainInputSchema),z.lazy(() => SaleCreateWithoutBlockchainInputSchema).array(),z.lazy(() => SaleUncheckedCreateWithoutBlockchainInputSchema),z.lazy(() => SaleUncheckedCreateWithoutBlockchainInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleCreateOrConnectWithoutBlockchainInputSchema),z.lazy(() => SaleCreateOrConnectWithoutBlockchainInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => SaleUpsertWithWhereUniqueWithoutBlockchainInputSchema),z.lazy(() => SaleUpsertWithWhereUniqueWithoutBlockchainInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleCreateManyBlockchainInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => SaleUpdateWithWhereUniqueWithoutBlockchainInputSchema),z.lazy(() => SaleUpdateWithWhereUniqueWithoutBlockchainInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => SaleUpdateManyWithWhereWithoutBlockchainInputSchema),z.lazy(() => SaleUpdateManyWithWhereWithoutBlockchainInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => SaleScalarWhereInputSchema),z.lazy(() => SaleScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const EnumContractSignatureStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumContractSignatureStatusFieldUpdateOperationsInput> = z.object({
  set: z.lazy(() => ContractSignatureStatusSchema).optional()
}).strict();

export const SaleTransactionsCreateNestedOneWithoutAuditTrailInputSchema: z.ZodType<Prisma.SaleTransactionsCreateNestedOneWithoutAuditTrailInput> = z.object({
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutAuditTrailInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutAuditTrailInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => SaleTransactionsCreateOrConnectWithoutAuditTrailInputSchema).optional(),
  connect: z.lazy(() => SaleTransactionsWhereUniqueInputSchema).optional()
}).strict();

export const UserCreateNestedOneWithoutTransactionAuditInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutTransactionAuditInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutTransactionAuditInputSchema),z.lazy(() => UserUncheckedCreateWithoutTransactionAuditInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutTransactionAuditInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
}).strict();

export const SaleTransactionsUpdateOneRequiredWithoutAuditTrailNestedInputSchema: z.ZodType<Prisma.SaleTransactionsUpdateOneRequiredWithoutAuditTrailNestedInput> = z.object({
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutAuditTrailInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutAuditTrailInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => SaleTransactionsCreateOrConnectWithoutAuditTrailInputSchema).optional(),
  upsert: z.lazy(() => SaleTransactionsUpsertWithoutAuditTrailInputSchema).optional(),
  connect: z.lazy(() => SaleTransactionsWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => SaleTransactionsUpdateToOneWithWhereWithoutAuditTrailInputSchema),z.lazy(() => SaleTransactionsUpdateWithoutAuditTrailInputSchema),z.lazy(() => SaleTransactionsUncheckedUpdateWithoutAuditTrailInputSchema) ]).optional(),
}).strict();

export const UserUpdateOneRequiredWithoutTransactionAuditNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutTransactionAuditNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutTransactionAuditInputSchema),z.lazy(() => UserUncheckedCreateWithoutTransactionAuditInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutTransactionAuditInputSchema).optional(),
  upsert: z.lazy(() => UserUpsertWithoutTransactionAuditInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => UserUpdateToOneWithWhereWithoutTransactionAuditInputSchema),z.lazy(() => UserUpdateWithoutTransactionAuditInputSchema),z.lazy(() => UserUncheckedUpdateWithoutTransactionAuditInputSchema) ]).optional(),
}).strict();

export const UserCreateNestedOneWithoutKycVerificationInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutKycVerificationInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutKycVerificationInputSchema),z.lazy(() => UserUncheckedCreateWithoutKycVerificationInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutKycVerificationInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
}).strict();

export const EnumKycStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumKycStatusFieldUpdateOperationsInput> = z.object({
  set: z.lazy(() => KycStatusSchema).optional()
}).strict();

export const UserUpdateOneRequiredWithoutKycVerificationNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutKycVerificationNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutKycVerificationInputSchema),z.lazy(() => UserUncheckedCreateWithoutKycVerificationInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutKycVerificationInputSchema).optional(),
  upsert: z.lazy(() => UserUpsertWithoutKycVerificationInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => UserUpdateToOneWithWhereWithoutKycVerificationInputSchema),z.lazy(() => UserUpdateWithoutKycVerificationInputSchema),z.lazy(() => UserUncheckedUpdateWithoutKycVerificationInputSchema) ]).optional(),
}).strict();

export const UserRoleCreateNestedManyWithoutRoleInputSchema: z.ZodType<Prisma.UserRoleCreateNestedManyWithoutRoleInput> = z.object({
  create: z.union([ z.lazy(() => UserRoleCreateWithoutRoleInputSchema),z.lazy(() => UserRoleCreateWithoutRoleInputSchema).array(),z.lazy(() => UserRoleUncheckedCreateWithoutRoleInputSchema),z.lazy(() => UserRoleUncheckedCreateWithoutRoleInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserRoleCreateOrConnectWithoutRoleInputSchema),z.lazy(() => UserRoleCreateOrConnectWithoutRoleInputSchema).array() ]).optional(),
  createMany: z.lazy(() => UserRoleCreateManyRoleInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => UserRoleWhereUniqueInputSchema),z.lazy(() => UserRoleWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const UserRoleUncheckedCreateNestedManyWithoutRoleInputSchema: z.ZodType<Prisma.UserRoleUncheckedCreateNestedManyWithoutRoleInput> = z.object({
  create: z.union([ z.lazy(() => UserRoleCreateWithoutRoleInputSchema),z.lazy(() => UserRoleCreateWithoutRoleInputSchema).array(),z.lazy(() => UserRoleUncheckedCreateWithoutRoleInputSchema),z.lazy(() => UserRoleUncheckedCreateWithoutRoleInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserRoleCreateOrConnectWithoutRoleInputSchema),z.lazy(() => UserRoleCreateOrConnectWithoutRoleInputSchema).array() ]).optional(),
  createMany: z.lazy(() => UserRoleCreateManyRoleInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => UserRoleWhereUniqueInputSchema),z.lazy(() => UserRoleWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const UserRoleUpdateManyWithoutRoleNestedInputSchema: z.ZodType<Prisma.UserRoleUpdateManyWithoutRoleNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserRoleCreateWithoutRoleInputSchema),z.lazy(() => UserRoleCreateWithoutRoleInputSchema).array(),z.lazy(() => UserRoleUncheckedCreateWithoutRoleInputSchema),z.lazy(() => UserRoleUncheckedCreateWithoutRoleInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserRoleCreateOrConnectWithoutRoleInputSchema),z.lazy(() => UserRoleCreateOrConnectWithoutRoleInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => UserRoleUpsertWithWhereUniqueWithoutRoleInputSchema),z.lazy(() => UserRoleUpsertWithWhereUniqueWithoutRoleInputSchema).array() ]).optional(),
  createMany: z.lazy(() => UserRoleCreateManyRoleInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => UserRoleWhereUniqueInputSchema),z.lazy(() => UserRoleWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => UserRoleWhereUniqueInputSchema),z.lazy(() => UserRoleWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => UserRoleWhereUniqueInputSchema),z.lazy(() => UserRoleWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => UserRoleWhereUniqueInputSchema),z.lazy(() => UserRoleWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => UserRoleUpdateWithWhereUniqueWithoutRoleInputSchema),z.lazy(() => UserRoleUpdateWithWhereUniqueWithoutRoleInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => UserRoleUpdateManyWithWhereWithoutRoleInputSchema),z.lazy(() => UserRoleUpdateManyWithWhereWithoutRoleInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => UserRoleScalarWhereInputSchema),z.lazy(() => UserRoleScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const UserRoleUncheckedUpdateManyWithoutRoleNestedInputSchema: z.ZodType<Prisma.UserRoleUncheckedUpdateManyWithoutRoleNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserRoleCreateWithoutRoleInputSchema),z.lazy(() => UserRoleCreateWithoutRoleInputSchema).array(),z.lazy(() => UserRoleUncheckedCreateWithoutRoleInputSchema),z.lazy(() => UserRoleUncheckedCreateWithoutRoleInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => UserRoleCreateOrConnectWithoutRoleInputSchema),z.lazy(() => UserRoleCreateOrConnectWithoutRoleInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => UserRoleUpsertWithWhereUniqueWithoutRoleInputSchema),z.lazy(() => UserRoleUpsertWithWhereUniqueWithoutRoleInputSchema).array() ]).optional(),
  createMany: z.lazy(() => UserRoleCreateManyRoleInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => UserRoleWhereUniqueInputSchema),z.lazy(() => UserRoleWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => UserRoleWhereUniqueInputSchema),z.lazy(() => UserRoleWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => UserRoleWhereUniqueInputSchema),z.lazy(() => UserRoleWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => UserRoleWhereUniqueInputSchema),z.lazy(() => UserRoleWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => UserRoleUpdateWithWhereUniqueWithoutRoleInputSchema),z.lazy(() => UserRoleUpdateWithWhereUniqueWithoutRoleInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => UserRoleUpdateManyWithWhereWithoutRoleInputSchema),z.lazy(() => UserRoleUpdateManyWithWhereWithoutRoleInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => UserRoleScalarWhereInputSchema),z.lazy(() => UserRoleScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const UserCreateNestedOneWithoutUserRoleInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutUserRoleInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutUserRoleInputSchema),z.lazy(() => UserUncheckedCreateWithoutUserRoleInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutUserRoleInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional()
}).strict();

export const RoleCreateNestedOneWithoutUsersInputSchema: z.ZodType<Prisma.RoleCreateNestedOneWithoutUsersInput> = z.object({
  create: z.union([ z.lazy(() => RoleCreateWithoutUsersInputSchema),z.lazy(() => RoleUncheckedCreateWithoutUsersInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => RoleCreateOrConnectWithoutUsersInputSchema).optional(),
  connect: z.lazy(() => RoleWhereUniqueInputSchema).optional()
}).strict();

export const UserUpdateOneRequiredWithoutUserRoleNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutUserRoleNestedInput> = z.object({
  create: z.union([ z.lazy(() => UserCreateWithoutUserRoleInputSchema),z.lazy(() => UserUncheckedCreateWithoutUserRoleInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutUserRoleInputSchema).optional(),
  upsert: z.lazy(() => UserUpsertWithoutUserRoleInputSchema).optional(),
  connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => UserUpdateToOneWithWhereWithoutUserRoleInputSchema),z.lazy(() => UserUpdateWithoutUserRoleInputSchema),z.lazy(() => UserUncheckedUpdateWithoutUserRoleInputSchema) ]).optional(),
}).strict();

export const RoleUpdateOneRequiredWithoutUsersNestedInputSchema: z.ZodType<Prisma.RoleUpdateOneRequiredWithoutUsersNestedInput> = z.object({
  create: z.union([ z.lazy(() => RoleCreateWithoutUsersInputSchema),z.lazy(() => RoleUncheckedCreateWithoutUsersInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => RoleCreateOrConnectWithoutUsersInputSchema).optional(),
  upsert: z.lazy(() => RoleUpsertWithoutUsersInputSchema).optional(),
  connect: z.lazy(() => RoleWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => RoleUpdateToOneWithWhereWithoutUsersInputSchema),z.lazy(() => RoleUpdateWithoutUsersInputSchema),z.lazy(() => RoleUncheckedUpdateWithoutUsersInputSchema) ]).optional(),
}).strict();

export const SaleCreateNestedManyWithoutTokenInputSchema: z.ZodType<Prisma.SaleCreateNestedManyWithoutTokenInput> = z.object({
  create: z.union([ z.lazy(() => SaleCreateWithoutTokenInputSchema),z.lazy(() => SaleCreateWithoutTokenInputSchema).array(),z.lazy(() => SaleUncheckedCreateWithoutTokenInputSchema),z.lazy(() => SaleUncheckedCreateWithoutTokenInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleCreateOrConnectWithoutTokenInputSchema),z.lazy(() => SaleCreateOrConnectWithoutTokenInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleCreateManyTokenInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const TokensOnBlockchainsCreateNestedManyWithoutTokenInputSchema: z.ZodType<Prisma.TokensOnBlockchainsCreateNestedManyWithoutTokenInput> = z.object({
  create: z.union([ z.lazy(() => TokensOnBlockchainsCreateWithoutTokenInputSchema),z.lazy(() => TokensOnBlockchainsCreateWithoutTokenInputSchema).array(),z.lazy(() => TokensOnBlockchainsUncheckedCreateWithoutTokenInputSchema),z.lazy(() => TokensOnBlockchainsUncheckedCreateWithoutTokenInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TokensOnBlockchainsCreateOrConnectWithoutTokenInputSchema),z.lazy(() => TokensOnBlockchainsCreateOrConnectWithoutTokenInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TokensOnBlockchainsCreateManyTokenInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const SaleUncheckedCreateNestedManyWithoutTokenInputSchema: z.ZodType<Prisma.SaleUncheckedCreateNestedManyWithoutTokenInput> = z.object({
  create: z.union([ z.lazy(() => SaleCreateWithoutTokenInputSchema),z.lazy(() => SaleCreateWithoutTokenInputSchema).array(),z.lazy(() => SaleUncheckedCreateWithoutTokenInputSchema),z.lazy(() => SaleUncheckedCreateWithoutTokenInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleCreateOrConnectWithoutTokenInputSchema),z.lazy(() => SaleCreateOrConnectWithoutTokenInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleCreateManyTokenInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const TokensOnBlockchainsUncheckedCreateNestedManyWithoutTokenInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUncheckedCreateNestedManyWithoutTokenInput> = z.object({
  create: z.union([ z.lazy(() => TokensOnBlockchainsCreateWithoutTokenInputSchema),z.lazy(() => TokensOnBlockchainsCreateWithoutTokenInputSchema).array(),z.lazy(() => TokensOnBlockchainsUncheckedCreateWithoutTokenInputSchema),z.lazy(() => TokensOnBlockchainsUncheckedCreateWithoutTokenInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TokensOnBlockchainsCreateOrConnectWithoutTokenInputSchema),z.lazy(() => TokensOnBlockchainsCreateOrConnectWithoutTokenInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TokensOnBlockchainsCreateManyTokenInputEnvelopeSchema).optional(),
  connect: z.union([ z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema).array() ]).optional(),
}).strict();

export const SaleUpdateManyWithoutTokenNestedInputSchema: z.ZodType<Prisma.SaleUpdateManyWithoutTokenNestedInput> = z.object({
  create: z.union([ z.lazy(() => SaleCreateWithoutTokenInputSchema),z.lazy(() => SaleCreateWithoutTokenInputSchema).array(),z.lazy(() => SaleUncheckedCreateWithoutTokenInputSchema),z.lazy(() => SaleUncheckedCreateWithoutTokenInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleCreateOrConnectWithoutTokenInputSchema),z.lazy(() => SaleCreateOrConnectWithoutTokenInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => SaleUpsertWithWhereUniqueWithoutTokenInputSchema),z.lazy(() => SaleUpsertWithWhereUniqueWithoutTokenInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleCreateManyTokenInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => SaleUpdateWithWhereUniqueWithoutTokenInputSchema),z.lazy(() => SaleUpdateWithWhereUniqueWithoutTokenInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => SaleUpdateManyWithWhereWithoutTokenInputSchema),z.lazy(() => SaleUpdateManyWithWhereWithoutTokenInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => SaleScalarWhereInputSchema),z.lazy(() => SaleScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TokensOnBlockchainsUpdateManyWithoutTokenNestedInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUpdateManyWithoutTokenNestedInput> = z.object({
  create: z.union([ z.lazy(() => TokensOnBlockchainsCreateWithoutTokenInputSchema),z.lazy(() => TokensOnBlockchainsCreateWithoutTokenInputSchema).array(),z.lazy(() => TokensOnBlockchainsUncheckedCreateWithoutTokenInputSchema),z.lazy(() => TokensOnBlockchainsUncheckedCreateWithoutTokenInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TokensOnBlockchainsCreateOrConnectWithoutTokenInputSchema),z.lazy(() => TokensOnBlockchainsCreateOrConnectWithoutTokenInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => TokensOnBlockchainsUpsertWithWhereUniqueWithoutTokenInputSchema),z.lazy(() => TokensOnBlockchainsUpsertWithWhereUniqueWithoutTokenInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TokensOnBlockchainsCreateManyTokenInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => TokensOnBlockchainsUpdateWithWhereUniqueWithoutTokenInputSchema),z.lazy(() => TokensOnBlockchainsUpdateWithWhereUniqueWithoutTokenInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => TokensOnBlockchainsUpdateManyWithWhereWithoutTokenInputSchema),z.lazy(() => TokensOnBlockchainsUpdateManyWithWhereWithoutTokenInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => TokensOnBlockchainsScalarWhereInputSchema),z.lazy(() => TokensOnBlockchainsScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const SaleUncheckedUpdateManyWithoutTokenNestedInputSchema: z.ZodType<Prisma.SaleUncheckedUpdateManyWithoutTokenNestedInput> = z.object({
  create: z.union([ z.lazy(() => SaleCreateWithoutTokenInputSchema),z.lazy(() => SaleCreateWithoutTokenInputSchema).array(),z.lazy(() => SaleUncheckedCreateWithoutTokenInputSchema),z.lazy(() => SaleUncheckedCreateWithoutTokenInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => SaleCreateOrConnectWithoutTokenInputSchema),z.lazy(() => SaleCreateOrConnectWithoutTokenInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => SaleUpsertWithWhereUniqueWithoutTokenInputSchema),z.lazy(() => SaleUpsertWithWhereUniqueWithoutTokenInputSchema).array() ]).optional(),
  createMany: z.lazy(() => SaleCreateManyTokenInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => SaleWhereUniqueInputSchema),z.lazy(() => SaleWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => SaleUpdateWithWhereUniqueWithoutTokenInputSchema),z.lazy(() => SaleUpdateWithWhereUniqueWithoutTokenInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => SaleUpdateManyWithWhereWithoutTokenInputSchema),z.lazy(() => SaleUpdateManyWithWhereWithoutTokenInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => SaleScalarWhereInputSchema),z.lazy(() => SaleScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TokensOnBlockchainsUncheckedUpdateManyWithoutTokenNestedInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUncheckedUpdateManyWithoutTokenNestedInput> = z.object({
  create: z.union([ z.lazy(() => TokensOnBlockchainsCreateWithoutTokenInputSchema),z.lazy(() => TokensOnBlockchainsCreateWithoutTokenInputSchema).array(),z.lazy(() => TokensOnBlockchainsUncheckedCreateWithoutTokenInputSchema),z.lazy(() => TokensOnBlockchainsUncheckedCreateWithoutTokenInputSchema).array() ]).optional(),
  connectOrCreate: z.union([ z.lazy(() => TokensOnBlockchainsCreateOrConnectWithoutTokenInputSchema),z.lazy(() => TokensOnBlockchainsCreateOrConnectWithoutTokenInputSchema).array() ]).optional(),
  upsert: z.union([ z.lazy(() => TokensOnBlockchainsUpsertWithWhereUniqueWithoutTokenInputSchema),z.lazy(() => TokensOnBlockchainsUpsertWithWhereUniqueWithoutTokenInputSchema).array() ]).optional(),
  createMany: z.lazy(() => TokensOnBlockchainsCreateManyTokenInputEnvelopeSchema).optional(),
  set: z.union([ z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema).array() ]).optional(),
  disconnect: z.union([ z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema).array() ]).optional(),
  delete: z.union([ z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema).array() ]).optional(),
  connect: z.union([ z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema).array() ]).optional(),
  update: z.union([ z.lazy(() => TokensOnBlockchainsUpdateWithWhereUniqueWithoutTokenInputSchema),z.lazy(() => TokensOnBlockchainsUpdateWithWhereUniqueWithoutTokenInputSchema).array() ]).optional(),
  updateMany: z.union([ z.lazy(() => TokensOnBlockchainsUpdateManyWithWhereWithoutTokenInputSchema),z.lazy(() => TokensOnBlockchainsUpdateManyWithWhereWithoutTokenInputSchema).array() ]).optional(),
  deleteMany: z.union([ z.lazy(() => TokensOnBlockchainsScalarWhereInputSchema),z.lazy(() => TokensOnBlockchainsScalarWhereInputSchema).array() ]).optional(),
}).strict();

export const TokenCreateNestedOneWithoutTokensOnBlockchainsInputSchema: z.ZodType<Prisma.TokenCreateNestedOneWithoutTokensOnBlockchainsInput> = z.object({
  create: z.union([ z.lazy(() => TokenCreateWithoutTokensOnBlockchainsInputSchema),z.lazy(() => TokenUncheckedCreateWithoutTokensOnBlockchainsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => TokenCreateOrConnectWithoutTokensOnBlockchainsInputSchema).optional(),
  connect: z.lazy(() => TokenWhereUniqueInputSchema).optional()
}).strict();

export const BlockchainCreateNestedOneWithoutTokensOnBlockchainsInputSchema: z.ZodType<Prisma.BlockchainCreateNestedOneWithoutTokensOnBlockchainsInput> = z.object({
  create: z.union([ z.lazy(() => BlockchainCreateWithoutTokensOnBlockchainsInputSchema),z.lazy(() => BlockchainUncheckedCreateWithoutTokensOnBlockchainsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => BlockchainCreateOrConnectWithoutTokensOnBlockchainsInputSchema).optional(),
  connect: z.lazy(() => BlockchainWhereUniqueInputSchema).optional()
}).strict();

export const TokenUpdateOneRequiredWithoutTokensOnBlockchainsNestedInputSchema: z.ZodType<Prisma.TokenUpdateOneRequiredWithoutTokensOnBlockchainsNestedInput> = z.object({
  create: z.union([ z.lazy(() => TokenCreateWithoutTokensOnBlockchainsInputSchema),z.lazy(() => TokenUncheckedCreateWithoutTokensOnBlockchainsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => TokenCreateOrConnectWithoutTokensOnBlockchainsInputSchema).optional(),
  upsert: z.lazy(() => TokenUpsertWithoutTokensOnBlockchainsInputSchema).optional(),
  connect: z.lazy(() => TokenWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => TokenUpdateToOneWithWhereWithoutTokensOnBlockchainsInputSchema),z.lazy(() => TokenUpdateWithoutTokensOnBlockchainsInputSchema),z.lazy(() => TokenUncheckedUpdateWithoutTokensOnBlockchainsInputSchema) ]).optional(),
}).strict();

export const BlockchainUpdateOneRequiredWithoutTokensOnBlockchainsNestedInputSchema: z.ZodType<Prisma.BlockchainUpdateOneRequiredWithoutTokensOnBlockchainsNestedInput> = z.object({
  create: z.union([ z.lazy(() => BlockchainCreateWithoutTokensOnBlockchainsInputSchema),z.lazy(() => BlockchainUncheckedCreateWithoutTokensOnBlockchainsInputSchema) ]).optional(),
  connectOrCreate: z.lazy(() => BlockchainCreateOrConnectWithoutTokensOnBlockchainsInputSchema).optional(),
  upsert: z.lazy(() => BlockchainUpsertWithoutTokensOnBlockchainsInputSchema).optional(),
  connect: z.lazy(() => BlockchainWhereUniqueInputSchema).optional(),
  update: z.union([ z.lazy(() => BlockchainUpdateToOneWithWhereWithoutTokensOnBlockchainsInputSchema),z.lazy(() => BlockchainUpdateWithoutTokensOnBlockchainsInputSchema),z.lazy(() => BlockchainUncheckedUpdateWithoutTokensOnBlockchainsInputSchema) ]).optional(),
}).strict();

export const NestedStringFilterSchema: z.ZodType<Prisma.NestedStringFilter> = z.object({
  equals: z.string().optional(),
  in: z.string().array().optional(),
  notIn: z.string().array().optional(),
  lt: z.string().optional(),
  lte: z.string().optional(),
  gt: z.string().optional(),
  gte: z.string().optional(),
  contains: z.string().optional(),
  startsWith: z.string().optional(),
  endsWith: z.string().optional(),
  not: z.union([ z.string(),z.lazy(() => NestedStringFilterSchema) ]).optional(),
}).strict();

export const NestedStringNullableFilterSchema: z.ZodType<Prisma.NestedStringNullableFilter> = z.object({
  equals: z.string().optional().nullable(),
  in: z.string().array().optional().nullable(),
  notIn: z.string().array().optional().nullable(),
  lt: z.string().optional(),
  lte: z.string().optional(),
  gt: z.string().optional(),
  gte: z.string().optional(),
  contains: z.string().optional(),
  startsWith: z.string().optional(),
  endsWith: z.string().optional(),
  not: z.union([ z.string(),z.lazy(() => NestedStringNullableFilterSchema) ]).optional().nullable(),
}).strict();

export const NestedDateTimeFilterSchema: z.ZodType<Prisma.NestedDateTimeFilter> = z.object({
  equals: z.coerce.date().optional(),
  in: z.coerce.date().array().optional(),
  notIn: z.coerce.date().array().optional(),
  lt: z.coerce.date().optional(),
  lte: z.coerce.date().optional(),
  gt: z.coerce.date().optional(),
  gte: z.coerce.date().optional(),
  not: z.union([ z.coerce.date(),z.lazy(() => NestedDateTimeFilterSchema) ]).optional(),
}).strict();

export const NestedDateTimeNullableFilterSchema: z.ZodType<Prisma.NestedDateTimeNullableFilter> = z.object({
  equals: z.coerce.date().optional().nullable(),
  in: z.coerce.date().array().optional().nullable(),
  notIn: z.coerce.date().array().optional().nullable(),
  lt: z.coerce.date().optional(),
  lte: z.coerce.date().optional(),
  gt: z.coerce.date().optional(),
  gte: z.coerce.date().optional(),
  not: z.union([ z.coerce.date(),z.lazy(() => NestedDateTimeNullableFilterSchema) ]).optional().nullable(),
}).strict();

export const NestedBoolFilterSchema: z.ZodType<Prisma.NestedBoolFilter> = z.object({
  equals: z.boolean().optional(),
  not: z.union([ z.boolean(),z.lazy(() => NestedBoolFilterSchema) ]).optional(),
}).strict();

export const NestedBoolNullableFilterSchema: z.ZodType<Prisma.NestedBoolNullableFilter> = z.object({
  equals: z.boolean().optional().nullable(),
  not: z.union([ z.boolean(),z.lazy(() => NestedBoolNullableFilterSchema) ]).optional().nullable(),
}).strict();

export const NestedStringWithAggregatesFilterSchema: z.ZodType<Prisma.NestedStringWithAggregatesFilter> = z.object({
  equals: z.string().optional(),
  in: z.string().array().optional(),
  notIn: z.string().array().optional(),
  lt: z.string().optional(),
  lte: z.string().optional(),
  gt: z.string().optional(),
  gte: z.string().optional(),
  contains: z.string().optional(),
  startsWith: z.string().optional(),
  endsWith: z.string().optional(),
  not: z.union([ z.string(),z.lazy(() => NestedStringWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedStringFilterSchema).optional(),
  _max: z.lazy(() => NestedStringFilterSchema).optional()
}).strict();

export const NestedIntFilterSchema: z.ZodType<Prisma.NestedIntFilter> = z.object({
  equals: z.number().optional(),
  in: z.number().array().optional(),
  notIn: z.number().array().optional(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedIntFilterSchema) ]).optional(),
}).strict();

export const NestedStringNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedStringNullableWithAggregatesFilter> = z.object({
  equals: z.string().optional().nullable(),
  in: z.string().array().optional().nullable(),
  notIn: z.string().array().optional().nullable(),
  lt: z.string().optional(),
  lte: z.string().optional(),
  gt: z.string().optional(),
  gte: z.string().optional(),
  contains: z.string().optional(),
  startsWith: z.string().optional(),
  endsWith: z.string().optional(),
  not: z.union([ z.string(),z.lazy(() => NestedStringNullableWithAggregatesFilterSchema) ]).optional().nullable(),
  _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _min: z.lazy(() => NestedStringNullableFilterSchema).optional(),
  _max: z.lazy(() => NestedStringNullableFilterSchema).optional()
}).strict();

export const NestedIntNullableFilterSchema: z.ZodType<Prisma.NestedIntNullableFilter> = z.object({
  equals: z.number().optional().nullable(),
  in: z.number().array().optional().nullable(),
  notIn: z.number().array().optional().nullable(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedIntNullableFilterSchema) ]).optional().nullable(),
}).strict();

export const NestedDateTimeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedDateTimeWithAggregatesFilter> = z.object({
  equals: z.coerce.date().optional(),
  in: z.coerce.date().array().optional(),
  notIn: z.coerce.date().array().optional(),
  lt: z.coerce.date().optional(),
  lte: z.coerce.date().optional(),
  gt: z.coerce.date().optional(),
  gte: z.coerce.date().optional(),
  not: z.union([ z.coerce.date(),z.lazy(() => NestedDateTimeWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedDateTimeFilterSchema).optional(),
  _max: z.lazy(() => NestedDateTimeFilterSchema).optional()
}).strict();

export const NestedDateTimeNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedDateTimeNullableWithAggregatesFilter> = z.object({
  equals: z.coerce.date().optional().nullable(),
  in: z.coerce.date().array().optional().nullable(),
  notIn: z.coerce.date().array().optional().nullable(),
  lt: z.coerce.date().optional(),
  lte: z.coerce.date().optional(),
  gt: z.coerce.date().optional(),
  gte: z.coerce.date().optional(),
  not: z.union([ z.coerce.date(),z.lazy(() => NestedDateTimeNullableWithAggregatesFilterSchema) ]).optional().nullable(),
  _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _min: z.lazy(() => NestedDateTimeNullableFilterSchema).optional(),
  _max: z.lazy(() => NestedDateTimeNullableFilterSchema).optional()
}).strict();

export const NestedBoolWithAggregatesFilterSchema: z.ZodType<Prisma.NestedBoolWithAggregatesFilter> = z.object({
  equals: z.boolean().optional(),
  not: z.union([ z.boolean(),z.lazy(() => NestedBoolWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedBoolFilterSchema).optional(),
  _max: z.lazy(() => NestedBoolFilterSchema).optional()
}).strict();

export const NestedBoolNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedBoolNullableWithAggregatesFilter> = z.object({
  equals: z.boolean().optional().nullable(),
  not: z.union([ z.boolean(),z.lazy(() => NestedBoolNullableWithAggregatesFilterSchema) ]).optional().nullable(),
  _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _min: z.lazy(() => NestedBoolNullableFilterSchema).optional(),
  _max: z.lazy(() => NestedBoolNullableFilterSchema).optional()
}).strict();

export const NestedIntWithAggregatesFilterSchema: z.ZodType<Prisma.NestedIntWithAggregatesFilter> = z.object({
  equals: z.number().optional(),
  in: z.number().array().optional(),
  notIn: z.number().array().optional(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedIntWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _avg: z.lazy(() => NestedFloatFilterSchema).optional(),
  _sum: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedIntFilterSchema).optional(),
  _max: z.lazy(() => NestedIntFilterSchema).optional()
}).strict();

export const NestedFloatFilterSchema: z.ZodType<Prisma.NestedFloatFilter> = z.object({
  equals: z.number().optional(),
  in: z.number().array().optional(),
  notIn: z.number().array().optional(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedFloatFilterSchema) ]).optional(),
}).strict();

export const NestedFloatNullableFilterSchema: z.ZodType<Prisma.NestedFloatNullableFilter> = z.object({
  equals: z.number().optional().nullable(),
  in: z.number().array().optional().nullable(),
  notIn: z.number().array().optional().nullable(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedFloatNullableFilterSchema) ]).optional().nullable(),
}).strict();

export const NestedFloatNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedFloatNullableWithAggregatesFilter> = z.object({
  equals: z.number().optional().nullable(),
  in: z.number().array().optional().nullable(),
  notIn: z.number().array().optional().nullable(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedFloatNullableWithAggregatesFilterSchema) ]).optional().nullable(),
  _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _avg: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
  _sum: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
  _min: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
  _max: z.lazy(() => NestedFloatNullableFilterSchema).optional()
}).strict();

export const NestedEnumSaleStatusFilterSchema: z.ZodType<Prisma.NestedEnumSaleStatusFilter> = z.object({
  equals: z.lazy(() => SaleStatusSchema).optional(),
  in: z.lazy(() => SaleStatusSchema).array().optional(),
  notIn: z.lazy(() => SaleStatusSchema).array().optional(),
  not: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => NestedEnumSaleStatusFilterSchema) ]).optional(),
}).strict();

export const NestedEnumCurrencyFilterSchema: z.ZodType<Prisma.NestedEnumCurrencyFilter> = z.object({
  equals: z.lazy(() => CurrencySchema).optional(),
  in: z.lazy(() => CurrencySchema).array().optional(),
  notIn: z.lazy(() => CurrencySchema).array().optional(),
  not: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => NestedEnumCurrencyFilterSchema) ]).optional(),
}).strict();

export const NestedDecimalFilterSchema: z.ZodType<Prisma.NestedDecimalFilter> = z.object({
  equals: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  in: z.union([z.number().array(),z.string().array(),z.instanceof(Decimal).array(),z.instanceof(Prisma.Decimal).array(),DecimalJsLikeSchema.array(),]).refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), { message: 'Must be a Decimal' }).optional(),
  notIn: z.union([z.number().array(),z.string().array(),z.instanceof(Decimal).array(),z.instanceof(Prisma.Decimal).array(),DecimalJsLikeSchema.array(),]).refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), { message: 'Must be a Decimal' }).optional(),
  lt: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  lte: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  gt: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  gte: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  not: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NestedDecimalFilterSchema) ]).optional(),
}).strict();

export const NestedEnumSaleStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumSaleStatusWithAggregatesFilter> = z.object({
  equals: z.lazy(() => SaleStatusSchema).optional(),
  in: z.lazy(() => SaleStatusSchema).array().optional(),
  notIn: z.lazy(() => SaleStatusSchema).array().optional(),
  not: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => NestedEnumSaleStatusWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedEnumSaleStatusFilterSchema).optional(),
  _max: z.lazy(() => NestedEnumSaleStatusFilterSchema).optional()
}).strict();

export const NestedEnumCurrencyWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumCurrencyWithAggregatesFilter> = z.object({
  equals: z.lazy(() => CurrencySchema).optional(),
  in: z.lazy(() => CurrencySchema).array().optional(),
  notIn: z.lazy(() => CurrencySchema).array().optional(),
  not: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => NestedEnumCurrencyWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedEnumCurrencyFilterSchema).optional(),
  _max: z.lazy(() => NestedEnumCurrencyFilterSchema).optional()
}).strict();

export const NestedIntNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedIntNullableWithAggregatesFilter> = z.object({
  equals: z.number().optional().nullable(),
  in: z.number().array().optional().nullable(),
  notIn: z.number().array().optional().nullable(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedIntNullableWithAggregatesFilterSchema) ]).optional().nullable(),
  _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _avg: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
  _sum: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _min: z.lazy(() => NestedIntNullableFilterSchema).optional(),
  _max: z.lazy(() => NestedIntNullableFilterSchema).optional()
}).strict();

export const NestedDecimalWithAggregatesFilterSchema: z.ZodType<Prisma.NestedDecimalWithAggregatesFilter> = z.object({
  equals: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  in: z.union([z.number().array(),z.string().array(),z.instanceof(Decimal).array(),z.instanceof(Prisma.Decimal).array(),DecimalJsLikeSchema.array(),]).refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), { message: 'Must be a Decimal' }).optional(),
  notIn: z.union([z.number().array(),z.string().array(),z.instanceof(Decimal).array(),z.instanceof(Prisma.Decimal).array(),DecimalJsLikeSchema.array(),]).refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), { message: 'Must be a Decimal' }).optional(),
  lt: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  lte: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  gt: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  gte: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }).optional(),
  not: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => NestedDecimalWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _avg: z.lazy(() => NestedDecimalFilterSchema).optional(),
  _sum: z.lazy(() => NestedDecimalFilterSchema).optional(),
  _min: z.lazy(() => NestedDecimalFilterSchema).optional(),
  _max: z.lazy(() => NestedDecimalFilterSchema).optional()
}).strict();

export const NestedFloatWithAggregatesFilterSchema: z.ZodType<Prisma.NestedFloatWithAggregatesFilter> = z.object({
  equals: z.number().optional(),
  in: z.number().array().optional(),
  notIn: z.number().array().optional(),
  lt: z.number().optional(),
  lte: z.number().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  not: z.union([ z.number(),z.lazy(() => NestedFloatWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _avg: z.lazy(() => NestedFloatFilterSchema).optional(),
  _sum: z.lazy(() => NestedFloatFilterSchema).optional(),
  _min: z.lazy(() => NestedFloatFilterSchema).optional(),
  _max: z.lazy(() => NestedFloatFilterSchema).optional()
}).strict();

export const NestedEnumFOPFilterSchema: z.ZodType<Prisma.NestedEnumFOPFilter> = z.object({
  equals: z.lazy(() => FOPSchema).optional(),
  in: z.lazy(() => FOPSchema).array().optional(),
  notIn: z.lazy(() => FOPSchema).array().optional(),
  not: z.union([ z.lazy(() => FOPSchema),z.lazy(() => NestedEnumFOPFilterSchema) ]).optional(),
}).strict();

export const NestedEnumTransactionStatusFilterSchema: z.ZodType<Prisma.NestedEnumTransactionStatusFilter> = z.object({
  equals: z.lazy(() => TransactionStatusSchema).optional(),
  in: z.lazy(() => TransactionStatusSchema).array().optional(),
  notIn: z.lazy(() => TransactionStatusSchema).array().optional(),
  not: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => NestedEnumTransactionStatusFilterSchema) ]).optional(),
}).strict();

export const NestedEnumFOPWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumFOPWithAggregatesFilter> = z.object({
  equals: z.lazy(() => FOPSchema).optional(),
  in: z.lazy(() => FOPSchema).array().optional(),
  notIn: z.lazy(() => FOPSchema).array().optional(),
  not: z.union([ z.lazy(() => FOPSchema),z.lazy(() => NestedEnumFOPWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedEnumFOPFilterSchema).optional(),
  _max: z.lazy(() => NestedEnumFOPFilterSchema).optional()
}).strict();

export const NestedEnumTransactionStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumTransactionStatusWithAggregatesFilter> = z.object({
  equals: z.lazy(() => TransactionStatusSchema).optional(),
  in: z.lazy(() => TransactionStatusSchema).array().optional(),
  notIn: z.lazy(() => TransactionStatusSchema).array().optional(),
  not: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => NestedEnumTransactionStatusWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedEnumTransactionStatusFilterSchema).optional(),
  _max: z.lazy(() => NestedEnumTransactionStatusFilterSchema).optional()
}).strict();

export const NestedEnumContractSignatureStatusFilterSchema: z.ZodType<Prisma.NestedEnumContractSignatureStatusFilter> = z.object({
  equals: z.lazy(() => ContractSignatureStatusSchema).optional(),
  in: z.lazy(() => ContractSignatureStatusSchema).array().optional(),
  notIn: z.lazy(() => ContractSignatureStatusSchema).array().optional(),
  not: z.union([ z.lazy(() => ContractSignatureStatusSchema),z.lazy(() => NestedEnumContractSignatureStatusFilterSchema) ]).optional(),
}).strict();

export const NestedEnumContractSignatureStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumContractSignatureStatusWithAggregatesFilter> = z.object({
  equals: z.lazy(() => ContractSignatureStatusSchema).optional(),
  in: z.lazy(() => ContractSignatureStatusSchema).array().optional(),
  notIn: z.lazy(() => ContractSignatureStatusSchema).array().optional(),
  not: z.union([ z.lazy(() => ContractSignatureStatusSchema),z.lazy(() => NestedEnumContractSignatureStatusWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedEnumContractSignatureStatusFilterSchema).optional(),
  _max: z.lazy(() => NestedEnumContractSignatureStatusFilterSchema).optional()
}).strict();

export const NestedEnumKycStatusFilterSchema: z.ZodType<Prisma.NestedEnumKycStatusFilter> = z.object({
  equals: z.lazy(() => KycStatusSchema).optional(),
  in: z.lazy(() => KycStatusSchema).array().optional(),
  notIn: z.lazy(() => KycStatusSchema).array().optional(),
  not: z.union([ z.lazy(() => KycStatusSchema),z.lazy(() => NestedEnumKycStatusFilterSchema) ]).optional(),
}).strict();

export const NestedEnumKycStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumKycStatusWithAggregatesFilter> = z.object({
  equals: z.lazy(() => KycStatusSchema).optional(),
  in: z.lazy(() => KycStatusSchema).array().optional(),
  notIn: z.lazy(() => KycStatusSchema).array().optional(),
  not: z.union([ z.lazy(() => KycStatusSchema),z.lazy(() => NestedEnumKycStatusWithAggregatesFilterSchema) ]).optional(),
  _count: z.lazy(() => NestedIntFilterSchema).optional(),
  _min: z.lazy(() => NestedEnumKycStatusFilterSchema).optional(),
  _max: z.lazy(() => NestedEnumKycStatusFilterSchema).optional()
}).strict();

export const ProfileCreateWithoutUserInputSchema: z.ZodType<Prisma.ProfileCreateWithoutUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  firstName: z.string().optional().nullable(),
  lastName: z.string().optional().nullable(),
  email: z.string().optional().nullable(),
  phoneNumber: z.string().optional().nullable(),
  dateOfBirth: z.coerce.date().optional().nullable(),
  address: z.lazy(() => AddressCreateNestedOneWithoutProfileInputSchema).optional()
}).strict();

export const ProfileUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.ProfileUncheckedCreateWithoutUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  firstName: z.string().optional().nullable(),
  lastName: z.string().optional().nullable(),
  email: z.string().optional().nullable(),
  phoneNumber: z.string().optional().nullable(),
  dateOfBirth: z.coerce.date().optional().nullable(),
  address: z.lazy(() => AddressUncheckedCreateNestedOneWithoutProfileInputSchema).optional()
}).strict();

export const ProfileCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.ProfileCreateOrConnectWithoutUserInput> = z.object({
  where: z.lazy(() => ProfileWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => ProfileCreateWithoutUserInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const SaleCreateWithoutUserInputSchema: z.ZodType<Prisma.SaleCreateWithoutUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  status: z.lazy(() => SaleStatusSchema).optional(),
  saleCurrency: z.lazy(() => CurrencySchema).optional(),
  initialTokenQuantity: z.number().int(),
  availableTokenQuantity: z.number().int(),
  maximumTokenBuyPerUser: z.number().int().optional().nullable(),
  minimumTokenBuyPerUser: z.number().int().optional(),
  saleStartDate: z.coerce.date(),
  tokenContractAddress: z.string().optional().nullable(),
  tokenName: z.string(),
  tokenTotalSupply: z.string().optional().nullable(),
  tokenPricePerUnit: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  tokenSymbol: z.string(),
  toWalletsAddress: z.string(),
  saleClosingDate: z.coerce.date(),
  saftCheckbox: z.boolean().optional(),
  saftContract: z.string().optional().nullable(),
  blockchain: z.lazy(() => BlockchainCreateNestedOneWithoutSaleInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsCreateNestedManyWithoutSaleInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationCreateNestedOneWithoutSaleInputSchema).optional(),
  documents: z.lazy(() => DocumentCreateNestedManyWithoutSaleInputSchema).optional(),
  token: z.lazy(() => TokenCreateNestedOneWithoutSalesInputSchema),
  vestingSchedules: z.lazy(() => VestingScheduleCreateNestedManyWithoutSaleInputSchema).optional()
}).strict();

export const SaleUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.SaleUncheckedCreateWithoutUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  status: z.lazy(() => SaleStatusSchema).optional(),
  saleCurrency: z.lazy(() => CurrencySchema).optional(),
  initialTokenQuantity: z.number().int(),
  availableTokenQuantity: z.number().int(),
  maximumTokenBuyPerUser: z.number().int().optional().nullable(),
  minimumTokenBuyPerUser: z.number().int().optional(),
  saleStartDate: z.coerce.date(),
  tokenContractAddress: z.string().optional().nullable(),
  tokenContractChainId: z.number().int().optional().nullable(),
  tokenName: z.string(),
  tokenTotalSupply: z.string().optional().nullable(),
  tokenPricePerUnit: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  tokenSymbol: z.string(),
  toWalletsAddress: z.string(),
  saleClosingDate: z.coerce.date(),
  saftCheckbox: z.boolean().optional(),
  saftContract: z.string().optional().nullable(),
  tokenId: z.string(),
  transactions: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutSaleInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationUncheckedCreateNestedOneWithoutSaleInputSchema).optional(),
  documents: z.lazy(() => DocumentUncheckedCreateNestedManyWithoutSaleInputSchema).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleUncheckedCreateNestedManyWithoutSaleInputSchema).optional()
}).strict();

export const SaleCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.SaleCreateOrConnectWithoutUserInput> = z.object({
  where: z.lazy(() => SaleWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => SaleCreateWithoutUserInputSchema),z.lazy(() => SaleUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const SaleCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.SaleCreateManyUserInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => SaleCreateManyUserInputSchema),z.lazy(() => SaleCreateManyUserInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const UserRoleCreateWithoutUserInputSchema: z.ZodType<Prisma.UserRoleCreateWithoutUserInput> = z.object({
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  role: z.lazy(() => RoleCreateNestedOneWithoutUsersInputSchema)
}).strict();

export const UserRoleUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.UserRoleUncheckedCreateWithoutUserInput> = z.object({
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  roleId: z.string()
}).strict();

export const UserRoleCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.UserRoleCreateOrConnectWithoutUserInput> = z.object({
  where: z.lazy(() => UserRoleWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserRoleCreateWithoutUserInputSchema),z.lazy(() => UserRoleUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const UserRoleCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.UserRoleCreateManyUserInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => UserRoleCreateManyUserInputSchema),z.lazy(() => UserRoleCreateManyUserInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const TransactionAuditCreateWithoutAdminInputSchema: z.ZodType<Prisma.TransactionAuditCreateWithoutAdminInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  actionType: z.string(),
  fromStatus: z.lazy(() => TransactionStatusSchema),
  toStatus: z.lazy(() => TransactionStatusSchema),
  comment: z.string().optional().nullable(),
  transaction: z.lazy(() => SaleTransactionsCreateNestedOneWithoutAuditTrailInputSchema)
}).strict();

export const TransactionAuditUncheckedCreateWithoutAdminInputSchema: z.ZodType<Prisma.TransactionAuditUncheckedCreateWithoutAdminInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  transactionId: z.string(),
  actionType: z.string(),
  fromStatus: z.lazy(() => TransactionStatusSchema),
  toStatus: z.lazy(() => TransactionStatusSchema),
  comment: z.string().optional().nullable()
}).strict();

export const TransactionAuditCreateOrConnectWithoutAdminInputSchema: z.ZodType<Prisma.TransactionAuditCreateOrConnectWithoutAdminInput> = z.object({
  where: z.lazy(() => TransactionAuditWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => TransactionAuditCreateWithoutAdminInputSchema),z.lazy(() => TransactionAuditUncheckedCreateWithoutAdminInputSchema) ]),
}).strict();

export const TransactionAuditCreateManyAdminInputEnvelopeSchema: z.ZodType<Prisma.TransactionAuditCreateManyAdminInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => TransactionAuditCreateManyAdminInputSchema),z.lazy(() => TransactionAuditCreateManyAdminInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const KycVerificationCreateWithoutUserInputSchema: z.ZodType<Prisma.KycVerificationCreateWithoutUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  status: z.lazy(() => KycStatusSchema).optional(),
  documentType: z.string().optional().nullable(),
  documentNumber: z.string().optional().nullable(),
  verifiedAt: z.coerce.date().optional().nullable(),
  rejectionReason: z.string().optional().nullable()
}).strict();

export const KycVerificationUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.KycVerificationUncheckedCreateWithoutUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  status: z.lazy(() => KycStatusSchema).optional(),
  documentType: z.string().optional().nullable(),
  documentNumber: z.string().optional().nullable(),
  verifiedAt: z.coerce.date().optional().nullable(),
  rejectionReason: z.string().optional().nullable()
}).strict();

export const KycVerificationCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.KycVerificationCreateOrConnectWithoutUserInput> = z.object({
  where: z.lazy(() => KycVerificationWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => KycVerificationCreateWithoutUserInputSchema),z.lazy(() => KycVerificationUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const SessionCreateWithoutUserInputSchema: z.ZodType<Prisma.SessionCreateWithoutUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  expiresAt: z.coerce.date(),
  token: z.string(),
  ipAddress: z.string().optional().nullable(),
  userAgent: z.string().optional().nullable()
}).strict();

export const SessionUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.SessionUncheckedCreateWithoutUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  expiresAt: z.coerce.date(),
  token: z.string(),
  ipAddress: z.string().optional().nullable(),
  userAgent: z.string().optional().nullable()
}).strict();

export const SessionCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.SessionCreateOrConnectWithoutUserInput> = z.object({
  where: z.lazy(() => SessionWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => SessionCreateWithoutUserInputSchema),z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const SessionCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.SessionCreateManyUserInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => SessionCreateManyUserInputSchema),z.lazy(() => SessionCreateManyUserInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const SaleTransactionsCreateWithoutUserInputSchema: z.ZodType<Prisma.SaleTransactionsCreateWithoutUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  tokenSymbol: z.string(),
  quantity: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rawPrice: z.string(),
  price: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  totalAmount: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  formOfPayment: z.lazy(() => FOPSchema),
  confirmationId: z.string().optional().nullable(),
  receivingWallet: z.string().optional().nullable(),
  status: z.lazy(() => TransactionStatusSchema).optional(),
  comment: z.string().optional().nullable(),
  amountPaid: z.string(),
  amountPaidCurrency: z.lazy(() => CurrencySchema),
  txHash: z.string().optional().nullable(),
  agreementId: z.string().optional().nullable(),
  rejectionReason: z.string().optional().nullable(),
  paymentEvidence: z.string().optional().nullable(),
  paymentDate: z.coerce.date().optional().nullable(),
  sale: z.lazy(() => SaleCreateNestedOneWithoutTransactionsInputSchema),
  blockchain: z.lazy(() => BlockchainCreateNestedOneWithoutTransactionsInputSchema).optional(),
  approver: z.lazy(() => UserCreateNestedOneWithoutTransactionApprovalsInputSchema).optional(),
  auditTrail: z.lazy(() => TransactionAuditCreateNestedManyWithoutTransactionInputSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionCreateNestedManyWithoutTransactionInputSchema).optional()
}).strict();

export const SaleTransactionsUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedCreateWithoutUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  tokenSymbol: z.string(),
  quantity: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rawPrice: z.string(),
  price: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  totalAmount: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  formOfPayment: z.lazy(() => FOPSchema),
  confirmationId: z.string().optional().nullable(),
  receivingWallet: z.string().optional().nullable(),
  status: z.lazy(() => TransactionStatusSchema).optional(),
  saleId: z.string(),
  comment: z.string().optional().nullable(),
  amountPaid: z.string(),
  amountPaidCurrency: z.lazy(() => CurrencySchema),
  txHash: z.string().optional().nullable(),
  blockchainId: z.string().optional().nullable(),
  agreementId: z.string().optional().nullable(),
  approvedBy: z.string().optional().nullable(),
  rejectionReason: z.string().optional().nullable(),
  paymentEvidence: z.string().optional().nullable(),
  paymentDate: z.coerce.date().optional().nullable(),
  auditTrail: z.lazy(() => TransactionAuditUncheckedCreateNestedManyWithoutTransactionInputSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionUncheckedCreateNestedManyWithoutTransactionInputSchema).optional()
}).strict();

export const SaleTransactionsCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.SaleTransactionsCreateOrConnectWithoutUserInput> = z.object({
  where: z.lazy(() => SaleTransactionsWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutUserInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const SaleTransactionsCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.SaleTransactionsCreateManyUserInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => SaleTransactionsCreateManyUserInputSchema),z.lazy(() => SaleTransactionsCreateManyUserInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const SaleTransactionsCreateWithoutApproverInputSchema: z.ZodType<Prisma.SaleTransactionsCreateWithoutApproverInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  tokenSymbol: z.string(),
  quantity: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rawPrice: z.string(),
  price: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  totalAmount: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  formOfPayment: z.lazy(() => FOPSchema),
  confirmationId: z.string().optional().nullable(),
  receivingWallet: z.string().optional().nullable(),
  status: z.lazy(() => TransactionStatusSchema).optional(),
  comment: z.string().optional().nullable(),
  amountPaid: z.string(),
  amountPaidCurrency: z.lazy(() => CurrencySchema),
  txHash: z.string().optional().nullable(),
  agreementId: z.string().optional().nullable(),
  rejectionReason: z.string().optional().nullable(),
  paymentEvidence: z.string().optional().nullable(),
  paymentDate: z.coerce.date().optional().nullable(),
  user: z.lazy(() => UserCreateNestedOneWithoutTransactionsInputSchema),
  sale: z.lazy(() => SaleCreateNestedOneWithoutTransactionsInputSchema),
  blockchain: z.lazy(() => BlockchainCreateNestedOneWithoutTransactionsInputSchema).optional(),
  auditTrail: z.lazy(() => TransactionAuditCreateNestedManyWithoutTransactionInputSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionCreateNestedManyWithoutTransactionInputSchema).optional()
}).strict();

export const SaleTransactionsUncheckedCreateWithoutApproverInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedCreateWithoutApproverInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  tokenSymbol: z.string(),
  quantity: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rawPrice: z.string(),
  price: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  totalAmount: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  formOfPayment: z.lazy(() => FOPSchema),
  confirmationId: z.string().optional().nullable(),
  receivingWallet: z.string().optional().nullable(),
  status: z.lazy(() => TransactionStatusSchema).optional(),
  userId: z.string(),
  saleId: z.string(),
  comment: z.string().optional().nullable(),
  amountPaid: z.string(),
  amountPaidCurrency: z.lazy(() => CurrencySchema),
  txHash: z.string().optional().nullable(),
  blockchainId: z.string().optional().nullable(),
  agreementId: z.string().optional().nullable(),
  rejectionReason: z.string().optional().nullable(),
  paymentEvidence: z.string().optional().nullable(),
  paymentDate: z.coerce.date().optional().nullable(),
  auditTrail: z.lazy(() => TransactionAuditUncheckedCreateNestedManyWithoutTransactionInputSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionUncheckedCreateNestedManyWithoutTransactionInputSchema).optional()
}).strict();

export const SaleTransactionsCreateOrConnectWithoutApproverInputSchema: z.ZodType<Prisma.SaleTransactionsCreateOrConnectWithoutApproverInput> = z.object({
  where: z.lazy(() => SaleTransactionsWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutApproverInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutApproverInputSchema) ]),
}).strict();

export const SaleTransactionsCreateManyApproverInputEnvelopeSchema: z.ZodType<Prisma.SaleTransactionsCreateManyApproverInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => SaleTransactionsCreateManyApproverInputSchema),z.lazy(() => SaleTransactionsCreateManyApproverInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const DocumentCreateWithoutUserInputSchema: z.ZodType<Prisma.DocumentCreateWithoutUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  fileName: z.string(),
  url: z.string(),
  type: z.string(),
  sale: z.lazy(() => SaleCreateNestedOneWithoutDocumentsInputSchema).optional()
}).strict();

export const DocumentUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.DocumentUncheckedCreateWithoutUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  fileName: z.string(),
  url: z.string(),
  type: z.string(),
  saleId: z.string().optional().nullable()
}).strict();

export const DocumentCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.DocumentCreateOrConnectWithoutUserInput> = z.object({
  where: z.lazy(() => DocumentWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => DocumentCreateWithoutUserInputSchema),z.lazy(() => DocumentUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const DocumentCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.DocumentCreateManyUserInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => DocumentCreateManyUserInputSchema),z.lazy(() => DocumentCreateManyUserInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const WalletAddressCreateWithoutAddressInputSchema: z.ZodType<Prisma.WalletAddressCreateWithoutAddressInput> = z.object({
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  chainId: z.number().int()
}).strict();

export const WalletAddressUncheckedCreateWithoutAddressInputSchema: z.ZodType<Prisma.WalletAddressUncheckedCreateWithoutAddressInput> = z.object({
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  chainId: z.number().int()
}).strict();

export const WalletAddressCreateOrConnectWithoutAddressInputSchema: z.ZodType<Prisma.WalletAddressCreateOrConnectWithoutAddressInput> = z.object({
  where: z.lazy(() => WalletAddressWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => WalletAddressCreateWithoutAddressInputSchema),z.lazy(() => WalletAddressUncheckedCreateWithoutAddressInputSchema) ]),
}).strict();

export const WalletAddressCreateManyAddressInputEnvelopeSchema: z.ZodType<Prisma.WalletAddressCreateManyAddressInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => WalletAddressCreateManyAddressInputSchema),z.lazy(() => WalletAddressCreateManyAddressInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const ProfileUpsertWithoutUserInputSchema: z.ZodType<Prisma.ProfileUpsertWithoutUserInput> = z.object({
  update: z.union([ z.lazy(() => ProfileUpdateWithoutUserInputSchema),z.lazy(() => ProfileUncheckedUpdateWithoutUserInputSchema) ]),
  create: z.union([ z.lazy(() => ProfileCreateWithoutUserInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutUserInputSchema) ]),
  where: z.lazy(() => ProfileWhereInputSchema).optional()
}).strict();

export const ProfileUpdateToOneWithWhereWithoutUserInputSchema: z.ZodType<Prisma.ProfileUpdateToOneWithWhereWithoutUserInput> = z.object({
  where: z.lazy(() => ProfileWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => ProfileUpdateWithoutUserInputSchema),z.lazy(() => ProfileUncheckedUpdateWithoutUserInputSchema) ]),
}).strict();

export const ProfileUpdateWithoutUserInputSchema: z.ZodType<Prisma.ProfileUpdateWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  firstName: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  lastName: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  email: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  phoneNumber: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  dateOfBirth: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  address: z.lazy(() => AddressUpdateOneWithoutProfileNestedInputSchema).optional()
}).strict();

export const ProfileUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.ProfileUncheckedUpdateWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  firstName: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  lastName: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  email: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  phoneNumber: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  dateOfBirth: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  address: z.lazy(() => AddressUncheckedUpdateOneWithoutProfileNestedInputSchema).optional()
}).strict();

export const SaleUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.SaleUpsertWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => SaleWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => SaleUpdateWithoutUserInputSchema),z.lazy(() => SaleUncheckedUpdateWithoutUserInputSchema) ]),
  create: z.union([ z.lazy(() => SaleCreateWithoutUserInputSchema),z.lazy(() => SaleUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const SaleUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.SaleUpdateWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => SaleWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => SaleUpdateWithoutUserInputSchema),z.lazy(() => SaleUncheckedUpdateWithoutUserInputSchema) ]),
}).strict();

export const SaleUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.SaleUpdateManyWithWhereWithoutUserInput> = z.object({
  where: z.lazy(() => SaleScalarWhereInputSchema),
  data: z.union([ z.lazy(() => SaleUpdateManyMutationInputSchema),z.lazy(() => SaleUncheckedUpdateManyWithoutUserInputSchema) ]),
}).strict();

export const SaleScalarWhereInputSchema: z.ZodType<Prisma.SaleScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => SaleScalarWhereInputSchema),z.lazy(() => SaleScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => SaleScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => SaleScalarWhereInputSchema),z.lazy(() => SaleScalarWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  status: z.union([ z.lazy(() => EnumSaleStatusFilterSchema),z.lazy(() => SaleStatusSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => EnumCurrencyFilterSchema),z.lazy(() => CurrencySchema) ]).optional(),
  initialTokenQuantity: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  availableTokenQuantity: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.lazy(() => IntNullableFilterSchema),z.number() ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  saleStartDate: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  tokenContractAddress: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  tokenContractChainId: z.union([ z.lazy(() => IntNullableFilterSchema),z.number() ]).optional().nullable(),
  tokenName: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  tokenTotalSupply: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.lazy(() => DecimalFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional(),
  tokenSymbol: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  toWalletsAddress: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  saleClosingDate: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  createdBy: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  saftCheckbox: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  saftContract: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  tokenId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
}).strict();

export const UserRoleUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.UserRoleUpsertWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => UserRoleWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => UserRoleUpdateWithoutUserInputSchema),z.lazy(() => UserRoleUncheckedUpdateWithoutUserInputSchema) ]),
  create: z.union([ z.lazy(() => UserRoleCreateWithoutUserInputSchema),z.lazy(() => UserRoleUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const UserRoleUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.UserRoleUpdateWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => UserRoleWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => UserRoleUpdateWithoutUserInputSchema),z.lazy(() => UserRoleUncheckedUpdateWithoutUserInputSchema) ]),
}).strict();

export const UserRoleUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.UserRoleUpdateManyWithWhereWithoutUserInput> = z.object({
  where: z.lazy(() => UserRoleScalarWhereInputSchema),
  data: z.union([ z.lazy(() => UserRoleUpdateManyMutationInputSchema),z.lazy(() => UserRoleUncheckedUpdateManyWithoutUserInputSchema) ]),
}).strict();

export const UserRoleScalarWhereInputSchema: z.ZodType<Prisma.UserRoleScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => UserRoleScalarWhereInputSchema),z.lazy(() => UserRoleScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => UserRoleScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => UserRoleScalarWhereInputSchema),z.lazy(() => UserRoleScalarWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  roleId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
}).strict();

export const TransactionAuditUpsertWithWhereUniqueWithoutAdminInputSchema: z.ZodType<Prisma.TransactionAuditUpsertWithWhereUniqueWithoutAdminInput> = z.object({
  where: z.lazy(() => TransactionAuditWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => TransactionAuditUpdateWithoutAdminInputSchema),z.lazy(() => TransactionAuditUncheckedUpdateWithoutAdminInputSchema) ]),
  create: z.union([ z.lazy(() => TransactionAuditCreateWithoutAdminInputSchema),z.lazy(() => TransactionAuditUncheckedCreateWithoutAdminInputSchema) ]),
}).strict();

export const TransactionAuditUpdateWithWhereUniqueWithoutAdminInputSchema: z.ZodType<Prisma.TransactionAuditUpdateWithWhereUniqueWithoutAdminInput> = z.object({
  where: z.lazy(() => TransactionAuditWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => TransactionAuditUpdateWithoutAdminInputSchema),z.lazy(() => TransactionAuditUncheckedUpdateWithoutAdminInputSchema) ]),
}).strict();

export const TransactionAuditUpdateManyWithWhereWithoutAdminInputSchema: z.ZodType<Prisma.TransactionAuditUpdateManyWithWhereWithoutAdminInput> = z.object({
  where: z.lazy(() => TransactionAuditScalarWhereInputSchema),
  data: z.union([ z.lazy(() => TransactionAuditUpdateManyMutationInputSchema),z.lazy(() => TransactionAuditUncheckedUpdateManyWithoutAdminInputSchema) ]),
}).strict();

export const TransactionAuditScalarWhereInputSchema: z.ZodType<Prisma.TransactionAuditScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => TransactionAuditScalarWhereInputSchema),z.lazy(() => TransactionAuditScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => TransactionAuditScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TransactionAuditScalarWhereInputSchema),z.lazy(() => TransactionAuditScalarWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  transactionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  actionType: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  fromStatus: z.union([ z.lazy(() => EnumTransactionStatusFilterSchema),z.lazy(() => TransactionStatusSchema) ]).optional(),
  toStatus: z.union([ z.lazy(() => EnumTransactionStatusFilterSchema),z.lazy(() => TransactionStatusSchema) ]).optional(),
  performedBy: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  comment: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
}).strict();

export const KycVerificationUpsertWithoutUserInputSchema: z.ZodType<Prisma.KycVerificationUpsertWithoutUserInput> = z.object({
  update: z.union([ z.lazy(() => KycVerificationUpdateWithoutUserInputSchema),z.lazy(() => KycVerificationUncheckedUpdateWithoutUserInputSchema) ]),
  create: z.union([ z.lazy(() => KycVerificationCreateWithoutUserInputSchema),z.lazy(() => KycVerificationUncheckedCreateWithoutUserInputSchema) ]),
  where: z.lazy(() => KycVerificationWhereInputSchema).optional()
}).strict();

export const KycVerificationUpdateToOneWithWhereWithoutUserInputSchema: z.ZodType<Prisma.KycVerificationUpdateToOneWithWhereWithoutUserInput> = z.object({
  where: z.lazy(() => KycVerificationWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => KycVerificationUpdateWithoutUserInputSchema),z.lazy(() => KycVerificationUncheckedUpdateWithoutUserInputSchema) ]),
}).strict();

export const KycVerificationUpdateWithoutUserInputSchema: z.ZodType<Prisma.KycVerificationUpdateWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.lazy(() => KycStatusSchema),z.lazy(() => EnumKycStatusFieldUpdateOperationsInputSchema) ]).optional(),
  documentType: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  documentNumber: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  verifiedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const KycVerificationUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.KycVerificationUncheckedUpdateWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.lazy(() => KycStatusSchema),z.lazy(() => EnumKycStatusFieldUpdateOperationsInputSchema) ]).optional(),
  documentType: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  documentNumber: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  verifiedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const SessionUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.SessionUpsertWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => SessionWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => SessionUpdateWithoutUserInputSchema),z.lazy(() => SessionUncheckedUpdateWithoutUserInputSchema) ]),
  create: z.union([ z.lazy(() => SessionCreateWithoutUserInputSchema),z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const SessionUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.SessionUpdateWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => SessionWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => SessionUpdateWithoutUserInputSchema),z.lazy(() => SessionUncheckedUpdateWithoutUserInputSchema) ]),
}).strict();

export const SessionUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.SessionUpdateManyWithWhereWithoutUserInput> = z.object({
  where: z.lazy(() => SessionScalarWhereInputSchema),
  data: z.union([ z.lazy(() => SessionUpdateManyMutationInputSchema),z.lazy(() => SessionUncheckedUpdateManyWithoutUserInputSchema) ]),
}).strict();

export const SessionScalarWhereInputSchema: z.ZodType<Prisma.SessionScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => SessionScalarWhereInputSchema),z.lazy(() => SessionScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => SessionScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => SessionScalarWhereInputSchema),z.lazy(() => SessionScalarWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  expiresAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  token: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  ipAddress: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  userAgent: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
}).strict();

export const SaleTransactionsUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.SaleTransactionsUpsertWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => SaleTransactionsWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => SaleTransactionsUpdateWithoutUserInputSchema),z.lazy(() => SaleTransactionsUncheckedUpdateWithoutUserInputSchema) ]),
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutUserInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const SaleTransactionsUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.SaleTransactionsUpdateWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => SaleTransactionsWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => SaleTransactionsUpdateWithoutUserInputSchema),z.lazy(() => SaleTransactionsUncheckedUpdateWithoutUserInputSchema) ]),
}).strict();

export const SaleTransactionsUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.SaleTransactionsUpdateManyWithWhereWithoutUserInput> = z.object({
  where: z.lazy(() => SaleTransactionsScalarWhereInputSchema),
  data: z.union([ z.lazy(() => SaleTransactionsUpdateManyMutationInputSchema),z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutUserInputSchema) ]),
}).strict();

export const SaleTransactionsScalarWhereInputSchema: z.ZodType<Prisma.SaleTransactionsScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => SaleTransactionsScalarWhereInputSchema),z.lazy(() => SaleTransactionsScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => SaleTransactionsScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => SaleTransactionsScalarWhereInputSchema),z.lazy(() => SaleTransactionsScalarWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  tokenSymbol: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  quantity: z.union([ z.lazy(() => DecimalFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional(),
  rawPrice: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  price: z.union([ z.lazy(() => DecimalFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional(),
  totalAmount: z.union([ z.lazy(() => DecimalFilterSchema),z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }) ]).optional(),
  formOfPayment: z.union([ z.lazy(() => EnumFOPFilterSchema),z.lazy(() => FOPSchema) ]).optional(),
  confirmationId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  receivingWallet: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  status: z.union([ z.lazy(() => EnumTransactionStatusFilterSchema),z.lazy(() => TransactionStatusSchema) ]).optional(),
  userId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  saleId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  comment: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  amountPaid: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  amountPaidCurrency: z.union([ z.lazy(() => EnumCurrencyFilterSchema),z.lazy(() => CurrencySchema) ]).optional(),
  txHash: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  blockchainId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  agreementId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  approvedBy: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  rejectionReason: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  paymentEvidence: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  paymentDate: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
}).strict();

export const SaleTransactionsUpsertWithWhereUniqueWithoutApproverInputSchema: z.ZodType<Prisma.SaleTransactionsUpsertWithWhereUniqueWithoutApproverInput> = z.object({
  where: z.lazy(() => SaleTransactionsWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => SaleTransactionsUpdateWithoutApproverInputSchema),z.lazy(() => SaleTransactionsUncheckedUpdateWithoutApproverInputSchema) ]),
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutApproverInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutApproverInputSchema) ]),
}).strict();

export const SaleTransactionsUpdateWithWhereUniqueWithoutApproverInputSchema: z.ZodType<Prisma.SaleTransactionsUpdateWithWhereUniqueWithoutApproverInput> = z.object({
  where: z.lazy(() => SaleTransactionsWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => SaleTransactionsUpdateWithoutApproverInputSchema),z.lazy(() => SaleTransactionsUncheckedUpdateWithoutApproverInputSchema) ]),
}).strict();

export const SaleTransactionsUpdateManyWithWhereWithoutApproverInputSchema: z.ZodType<Prisma.SaleTransactionsUpdateManyWithWhereWithoutApproverInput> = z.object({
  where: z.lazy(() => SaleTransactionsScalarWhereInputSchema),
  data: z.union([ z.lazy(() => SaleTransactionsUpdateManyMutationInputSchema),z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutApproverInputSchema) ]),
}).strict();

export const DocumentUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.DocumentUpsertWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => DocumentWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => DocumentUpdateWithoutUserInputSchema),z.lazy(() => DocumentUncheckedUpdateWithoutUserInputSchema) ]),
  create: z.union([ z.lazy(() => DocumentCreateWithoutUserInputSchema),z.lazy(() => DocumentUncheckedCreateWithoutUserInputSchema) ]),
}).strict();

export const DocumentUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.DocumentUpdateWithWhereUniqueWithoutUserInput> = z.object({
  where: z.lazy(() => DocumentWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => DocumentUpdateWithoutUserInputSchema),z.lazy(() => DocumentUncheckedUpdateWithoutUserInputSchema) ]),
}).strict();

export const DocumentUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.DocumentUpdateManyWithWhereWithoutUserInput> = z.object({
  where: z.lazy(() => DocumentScalarWhereInputSchema),
  data: z.union([ z.lazy(() => DocumentUpdateManyMutationInputSchema),z.lazy(() => DocumentUncheckedUpdateManyWithoutUserInputSchema) ]),
}).strict();

export const DocumentScalarWhereInputSchema: z.ZodType<Prisma.DocumentScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => DocumentScalarWhereInputSchema),z.lazy(() => DocumentScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => DocumentScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => DocumentScalarWhereInputSchema),z.lazy(() => DocumentScalarWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  fileName: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  url: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  type: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  saleId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  userId: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
}).strict();

export const WalletAddressUpsertWithWhereUniqueWithoutAddressInputSchema: z.ZodType<Prisma.WalletAddressUpsertWithWhereUniqueWithoutAddressInput> = z.object({
  where: z.lazy(() => WalletAddressWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => WalletAddressUpdateWithoutAddressInputSchema),z.lazy(() => WalletAddressUncheckedUpdateWithoutAddressInputSchema) ]),
  create: z.union([ z.lazy(() => WalletAddressCreateWithoutAddressInputSchema),z.lazy(() => WalletAddressUncheckedCreateWithoutAddressInputSchema) ]),
}).strict();

export const WalletAddressUpdateWithWhereUniqueWithoutAddressInputSchema: z.ZodType<Prisma.WalletAddressUpdateWithWhereUniqueWithoutAddressInput> = z.object({
  where: z.lazy(() => WalletAddressWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => WalletAddressUpdateWithoutAddressInputSchema),z.lazy(() => WalletAddressUncheckedUpdateWithoutAddressInputSchema) ]),
}).strict();

export const WalletAddressUpdateManyWithWhereWithoutAddressInputSchema: z.ZodType<Prisma.WalletAddressUpdateManyWithWhereWithoutAddressInput> = z.object({
  where: z.lazy(() => WalletAddressScalarWhereInputSchema),
  data: z.union([ z.lazy(() => WalletAddressUpdateManyMutationInputSchema),z.lazy(() => WalletAddressUncheckedUpdateManyWithoutAddressInputSchema) ]),
}).strict();

export const WalletAddressScalarWhereInputSchema: z.ZodType<Prisma.WalletAddressScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => WalletAddressScalarWhereInputSchema),z.lazy(() => WalletAddressScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => WalletAddressScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => WalletAddressScalarWhereInputSchema),z.lazy(() => WalletAddressScalarWhereInputSchema).array() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  walletAddress: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  chainId: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
}).strict();

export const UserCreateWithoutWalletAddressInputSchema: z.ZodType<Prisma.UserCreateWithoutWalletAddressInput> = z.object({
  id: z.string().cuid().optional(),
  externalId: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  walletAddress: z.string(),
  email: z.string(),
  emailVerified: z.boolean().optional(),
  image: z.string().optional().nullable(),
  isSiwe: z.boolean().optional().nullable(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutUserInputSchema).optional(),
  sales: z.lazy(() => SaleCreateNestedManyWithoutUserInputSchema).optional(),
  userRole: z.lazy(() => UserRoleCreateNestedManyWithoutUserInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditCreateNestedManyWithoutAdminInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationCreateNestedOneWithoutUserInputSchema).optional(),
  sessions: z.lazy(() => SessionCreateNestedManyWithoutUserInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsCreateNestedManyWithoutUserInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsCreateNestedManyWithoutApproverInputSchema).optional(),
  Document: z.lazy(() => DocumentCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserUncheckedCreateWithoutWalletAddressInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutWalletAddressInput> = z.object({
  id: z.string().cuid().optional(),
  externalId: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  walletAddress: z.string(),
  email: z.string(),
  emailVerified: z.boolean().optional(),
  image: z.string().optional().nullable(),
  isSiwe: z.boolean().optional().nullable(),
  profile: z.lazy(() => ProfileUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  sales: z.lazy(() => SaleUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUncheckedCreateNestedManyWithoutAdminInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  sessions: z.lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutApproverInputSchema).optional(),
  Document: z.lazy(() => DocumentUncheckedCreateNestedManyWithoutUserInputSchema).optional()
}).strict();

export const UserCreateOrConnectWithoutWalletAddressInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutWalletAddressInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserCreateWithoutWalletAddressInputSchema),z.lazy(() => UserUncheckedCreateWithoutWalletAddressInputSchema) ]),
}).strict();

export const UserUpsertWithoutWalletAddressInputSchema: z.ZodType<Prisma.UserUpsertWithoutWalletAddressInput> = z.object({
  update: z.union([ z.lazy(() => UserUpdateWithoutWalletAddressInputSchema),z.lazy(() => UserUncheckedUpdateWithoutWalletAddressInputSchema) ]),
  create: z.union([ z.lazy(() => UserCreateWithoutWalletAddressInputSchema),z.lazy(() => UserUncheckedCreateWithoutWalletAddressInputSchema) ]),
  where: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const UserUpdateToOneWithWhereWithoutWalletAddressInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutWalletAddressInput> = z.object({
  where: z.lazy(() => UserWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => UserUpdateWithoutWalletAddressInputSchema),z.lazy(() => UserUncheckedUpdateWithoutWalletAddressInputSchema) ]),
}).strict();

export const UserUpdateWithoutWalletAddressInputSchema: z.ZodType<Prisma.UserUpdateWithoutWalletAddressInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  externalId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailVerified: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isSiwe: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profile: z.lazy(() => ProfileUpdateOneWithoutUserNestedInputSchema).optional(),
  sales: z.lazy(() => SaleUpdateManyWithoutUserNestedInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUpdateManyWithoutAdminNestedInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUpdateOneWithoutUserNestedInputSchema).optional(),
  sessions: z.lazy(() => SessionUpdateManyWithoutUserNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUpdateManyWithoutApproverNestedInputSchema).optional(),
  Document: z.lazy(() => DocumentUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateWithoutWalletAddressInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutWalletAddressInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  externalId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailVerified: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isSiwe: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profile: z.lazy(() => ProfileUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  sales: z.lazy(() => SaleUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUncheckedUpdateManyWithoutAdminNestedInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  sessions: z.lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutApproverNestedInputSchema).optional(),
  Document: z.lazy(() => DocumentUncheckedUpdateManyWithoutUserNestedInputSchema).optional()
}).strict();

export const UserCreateWithoutSessionsInputSchema: z.ZodType<Prisma.UserCreateWithoutSessionsInput> = z.object({
  id: z.string().cuid().optional(),
  externalId: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  walletAddress: z.string(),
  email: z.string(),
  emailVerified: z.boolean().optional(),
  image: z.string().optional().nullable(),
  isSiwe: z.boolean().optional().nullable(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutUserInputSchema).optional(),
  sales: z.lazy(() => SaleCreateNestedManyWithoutUserInputSchema).optional(),
  userRole: z.lazy(() => UserRoleCreateNestedManyWithoutUserInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditCreateNestedManyWithoutAdminInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationCreateNestedOneWithoutUserInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsCreateNestedManyWithoutUserInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsCreateNestedManyWithoutApproverInputSchema).optional(),
  Document: z.lazy(() => DocumentCreateNestedManyWithoutUserInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressCreateNestedManyWithoutAddressInputSchema).optional()
}).strict();

export const UserUncheckedCreateWithoutSessionsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutSessionsInput> = z.object({
  id: z.string().cuid().optional(),
  externalId: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  walletAddress: z.string(),
  email: z.string(),
  emailVerified: z.boolean().optional(),
  image: z.string().optional().nullable(),
  isSiwe: z.boolean().optional().nullable(),
  profile: z.lazy(() => ProfileUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  sales: z.lazy(() => SaleUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUncheckedCreateNestedManyWithoutAdminInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutApproverInputSchema).optional(),
  Document: z.lazy(() => DocumentUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUncheckedCreateNestedManyWithoutAddressInputSchema).optional()
}).strict();

export const UserCreateOrConnectWithoutSessionsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutSessionsInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserCreateWithoutSessionsInputSchema),z.lazy(() => UserUncheckedCreateWithoutSessionsInputSchema) ]),
}).strict();

export const UserUpsertWithoutSessionsInputSchema: z.ZodType<Prisma.UserUpsertWithoutSessionsInput> = z.object({
  update: z.union([ z.lazy(() => UserUpdateWithoutSessionsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutSessionsInputSchema) ]),
  create: z.union([ z.lazy(() => UserCreateWithoutSessionsInputSchema),z.lazy(() => UserUncheckedCreateWithoutSessionsInputSchema) ]),
  where: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const UserUpdateToOneWithWhereWithoutSessionsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutSessionsInput> = z.object({
  where: z.lazy(() => UserWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => UserUpdateWithoutSessionsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutSessionsInputSchema) ]),
}).strict();

export const UserUpdateWithoutSessionsInputSchema: z.ZodType<Prisma.UserUpdateWithoutSessionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  externalId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailVerified: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isSiwe: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profile: z.lazy(() => ProfileUpdateOneWithoutUserNestedInputSchema).optional(),
  sales: z.lazy(() => SaleUpdateManyWithoutUserNestedInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUpdateManyWithoutAdminNestedInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUpdateOneWithoutUserNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUpdateManyWithoutApproverNestedInputSchema).optional(),
  Document: z.lazy(() => DocumentUpdateManyWithoutUserNestedInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUpdateManyWithoutAddressNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateWithoutSessionsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutSessionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  externalId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailVerified: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isSiwe: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profile: z.lazy(() => ProfileUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  sales: z.lazy(() => SaleUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUncheckedUpdateManyWithoutAdminNestedInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutApproverNestedInputSchema).optional(),
  Document: z.lazy(() => DocumentUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUncheckedUpdateManyWithoutAddressNestedInputSchema).optional()
}).strict();

export const UserCreateWithoutProfileInputSchema: z.ZodType<Prisma.UserCreateWithoutProfileInput> = z.object({
  id: z.string().cuid().optional(),
  externalId: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  walletAddress: z.string(),
  email: z.string(),
  emailVerified: z.boolean().optional(),
  image: z.string().optional().nullable(),
  isSiwe: z.boolean().optional().nullable(),
  sales: z.lazy(() => SaleCreateNestedManyWithoutUserInputSchema).optional(),
  userRole: z.lazy(() => UserRoleCreateNestedManyWithoutUserInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditCreateNestedManyWithoutAdminInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationCreateNestedOneWithoutUserInputSchema).optional(),
  sessions: z.lazy(() => SessionCreateNestedManyWithoutUserInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsCreateNestedManyWithoutUserInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsCreateNestedManyWithoutApproverInputSchema).optional(),
  Document: z.lazy(() => DocumentCreateNestedManyWithoutUserInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressCreateNestedManyWithoutAddressInputSchema).optional()
}).strict();

export const UserUncheckedCreateWithoutProfileInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutProfileInput> = z.object({
  id: z.string().cuid().optional(),
  externalId: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  walletAddress: z.string(),
  email: z.string(),
  emailVerified: z.boolean().optional(),
  image: z.string().optional().nullable(),
  isSiwe: z.boolean().optional().nullable(),
  sales: z.lazy(() => SaleUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUncheckedCreateNestedManyWithoutAdminInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  sessions: z.lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutApproverInputSchema).optional(),
  Document: z.lazy(() => DocumentUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUncheckedCreateNestedManyWithoutAddressInputSchema).optional()
}).strict();

export const UserCreateOrConnectWithoutProfileInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutProfileInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserCreateWithoutProfileInputSchema),z.lazy(() => UserUncheckedCreateWithoutProfileInputSchema) ]),
}).strict();

export const AddressCreateWithoutProfileInputSchema: z.ZodType<Prisma.AddressCreateWithoutProfileInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  city: z.string().optional().nullable(),
  zipCode: z.string().optional().nullable(),
  country: z.string().optional().nullable(),
  state: z.string().optional().nullable(),
  street: z.string().optional().nullable(),
  formattedAddress: z.string().optional().nullable(),
  latitude: z.number().optional().nullable(),
  longitude: z.number().optional().nullable()
}).strict();

export const AddressUncheckedCreateWithoutProfileInputSchema: z.ZodType<Prisma.AddressUncheckedCreateWithoutProfileInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  city: z.string().optional().nullable(),
  zipCode: z.string().optional().nullable(),
  country: z.string().optional().nullable(),
  state: z.string().optional().nullable(),
  street: z.string().optional().nullable(),
  formattedAddress: z.string().optional().nullable(),
  latitude: z.number().optional().nullable(),
  longitude: z.number().optional().nullable()
}).strict();

export const AddressCreateOrConnectWithoutProfileInputSchema: z.ZodType<Prisma.AddressCreateOrConnectWithoutProfileInput> = z.object({
  where: z.lazy(() => AddressWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => AddressCreateWithoutProfileInputSchema),z.lazy(() => AddressUncheckedCreateWithoutProfileInputSchema) ]),
}).strict();

export const UserUpsertWithoutProfileInputSchema: z.ZodType<Prisma.UserUpsertWithoutProfileInput> = z.object({
  update: z.union([ z.lazy(() => UserUpdateWithoutProfileInputSchema),z.lazy(() => UserUncheckedUpdateWithoutProfileInputSchema) ]),
  create: z.union([ z.lazy(() => UserCreateWithoutProfileInputSchema),z.lazy(() => UserUncheckedCreateWithoutProfileInputSchema) ]),
  where: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const UserUpdateToOneWithWhereWithoutProfileInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutProfileInput> = z.object({
  where: z.lazy(() => UserWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => UserUpdateWithoutProfileInputSchema),z.lazy(() => UserUncheckedUpdateWithoutProfileInputSchema) ]),
}).strict();

export const UserUpdateWithoutProfileInputSchema: z.ZodType<Prisma.UserUpdateWithoutProfileInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  externalId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailVerified: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isSiwe: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sales: z.lazy(() => SaleUpdateManyWithoutUserNestedInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUpdateManyWithoutAdminNestedInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUpdateOneWithoutUserNestedInputSchema).optional(),
  sessions: z.lazy(() => SessionUpdateManyWithoutUserNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUpdateManyWithoutApproverNestedInputSchema).optional(),
  Document: z.lazy(() => DocumentUpdateManyWithoutUserNestedInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUpdateManyWithoutAddressNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateWithoutProfileInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutProfileInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  externalId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailVerified: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isSiwe: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sales: z.lazy(() => SaleUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUncheckedUpdateManyWithoutAdminNestedInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  sessions: z.lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutApproverNestedInputSchema).optional(),
  Document: z.lazy(() => DocumentUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUncheckedUpdateManyWithoutAddressNestedInputSchema).optional()
}).strict();

export const AddressUpsertWithoutProfileInputSchema: z.ZodType<Prisma.AddressUpsertWithoutProfileInput> = z.object({
  update: z.union([ z.lazy(() => AddressUpdateWithoutProfileInputSchema),z.lazy(() => AddressUncheckedUpdateWithoutProfileInputSchema) ]),
  create: z.union([ z.lazy(() => AddressCreateWithoutProfileInputSchema),z.lazy(() => AddressUncheckedCreateWithoutProfileInputSchema) ]),
  where: z.lazy(() => AddressWhereInputSchema).optional()
}).strict();

export const AddressUpdateToOneWithWhereWithoutProfileInputSchema: z.ZodType<Prisma.AddressUpdateToOneWithWhereWithoutProfileInput> = z.object({
  where: z.lazy(() => AddressWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => AddressUpdateWithoutProfileInputSchema),z.lazy(() => AddressUncheckedUpdateWithoutProfileInputSchema) ]),
}).strict();

export const AddressUpdateWithoutProfileInputSchema: z.ZodType<Prisma.AddressUpdateWithoutProfileInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  city: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  zipCode: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  country: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  state: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  street: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  formattedAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  latitude: z.union([ z.number(),z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  longitude: z.union([ z.number(),z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const AddressUncheckedUpdateWithoutProfileInputSchema: z.ZodType<Prisma.AddressUncheckedUpdateWithoutProfileInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  city: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  zipCode: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  country: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  state: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  street: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  formattedAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  latitude: z.union([ z.number(),z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  longitude: z.union([ z.number(),z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const ProfileCreateWithoutAddressInputSchema: z.ZodType<Prisma.ProfileCreateWithoutAddressInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  firstName: z.string().optional().nullable(),
  lastName: z.string().optional().nullable(),
  email: z.string().optional().nullable(),
  phoneNumber: z.string().optional().nullable(),
  dateOfBirth: z.coerce.date().optional().nullable(),
  user: z.lazy(() => UserCreateNestedOneWithoutProfileInputSchema)
}).strict();

export const ProfileUncheckedCreateWithoutAddressInputSchema: z.ZodType<Prisma.ProfileUncheckedCreateWithoutAddressInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  firstName: z.string().optional().nullable(),
  lastName: z.string().optional().nullable(),
  userId: z.string(),
  email: z.string().optional().nullable(),
  phoneNumber: z.string().optional().nullable(),
  dateOfBirth: z.coerce.date().optional().nullable()
}).strict();

export const ProfileCreateOrConnectWithoutAddressInputSchema: z.ZodType<Prisma.ProfileCreateOrConnectWithoutAddressInput> = z.object({
  where: z.lazy(() => ProfileWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => ProfileCreateWithoutAddressInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutAddressInputSchema) ]),
}).strict();

export const ProfileUpsertWithoutAddressInputSchema: z.ZodType<Prisma.ProfileUpsertWithoutAddressInput> = z.object({
  update: z.union([ z.lazy(() => ProfileUpdateWithoutAddressInputSchema),z.lazy(() => ProfileUncheckedUpdateWithoutAddressInputSchema) ]),
  create: z.union([ z.lazy(() => ProfileCreateWithoutAddressInputSchema),z.lazy(() => ProfileUncheckedCreateWithoutAddressInputSchema) ]),
  where: z.lazy(() => ProfileWhereInputSchema).optional()
}).strict();

export const ProfileUpdateToOneWithWhereWithoutAddressInputSchema: z.ZodType<Prisma.ProfileUpdateToOneWithWhereWithoutAddressInput> = z.object({
  where: z.lazy(() => ProfileWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => ProfileUpdateWithoutAddressInputSchema),z.lazy(() => ProfileUncheckedUpdateWithoutAddressInputSchema) ]),
}).strict();

export const ProfileUpdateWithoutAddressInputSchema: z.ZodType<Prisma.ProfileUpdateWithoutAddressInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  firstName: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  lastName: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  email: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  phoneNumber: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  dateOfBirth: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutProfileNestedInputSchema).optional()
}).strict();

export const ProfileUncheckedUpdateWithoutAddressInputSchema: z.ZodType<Prisma.ProfileUncheckedUpdateWithoutAddressInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  firstName: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  lastName: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  phoneNumber: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  dateOfBirth: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const BlockchainCreateWithoutSaleInputSchema: z.ZodType<Prisma.BlockchainCreateWithoutSaleInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  chainId: z.number().int(),
  rpcUrl: z.string(),
  explorerUrl: z.string().optional().nullable(),
  isTestnet: z.boolean().optional(),
  isEnabled: z.boolean().optional(),
  transactions: z.lazy(() => SaleTransactionsCreateNestedManyWithoutBlockchainInputSchema).optional(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsCreateNestedManyWithoutBlockchainInputSchema).optional()
}).strict();

export const BlockchainUncheckedCreateWithoutSaleInputSchema: z.ZodType<Prisma.BlockchainUncheckedCreateWithoutSaleInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  chainId: z.number().int(),
  rpcUrl: z.string(),
  explorerUrl: z.string().optional().nullable(),
  isTestnet: z.boolean().optional(),
  isEnabled: z.boolean().optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutBlockchainInputSchema).optional(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsUncheckedCreateNestedManyWithoutBlockchainInputSchema).optional()
}).strict();

export const BlockchainCreateOrConnectWithoutSaleInputSchema: z.ZodType<Prisma.BlockchainCreateOrConnectWithoutSaleInput> = z.object({
  where: z.lazy(() => BlockchainWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => BlockchainCreateWithoutSaleInputSchema),z.lazy(() => BlockchainUncheckedCreateWithoutSaleInputSchema) ]),
}).strict();

export const UserCreateWithoutSalesInputSchema: z.ZodType<Prisma.UserCreateWithoutSalesInput> = z.object({
  id: z.string().cuid().optional(),
  externalId: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  walletAddress: z.string(),
  email: z.string(),
  emailVerified: z.boolean().optional(),
  image: z.string().optional().nullable(),
  isSiwe: z.boolean().optional().nullable(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutUserInputSchema).optional(),
  userRole: z.lazy(() => UserRoleCreateNestedManyWithoutUserInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditCreateNestedManyWithoutAdminInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationCreateNestedOneWithoutUserInputSchema).optional(),
  sessions: z.lazy(() => SessionCreateNestedManyWithoutUserInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsCreateNestedManyWithoutUserInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsCreateNestedManyWithoutApproverInputSchema).optional(),
  Document: z.lazy(() => DocumentCreateNestedManyWithoutUserInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressCreateNestedManyWithoutAddressInputSchema).optional()
}).strict();

export const UserUncheckedCreateWithoutSalesInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutSalesInput> = z.object({
  id: z.string().cuid().optional(),
  externalId: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  walletAddress: z.string(),
  email: z.string(),
  emailVerified: z.boolean().optional(),
  image: z.string().optional().nullable(),
  isSiwe: z.boolean().optional().nullable(),
  profile: z.lazy(() => ProfileUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUncheckedCreateNestedManyWithoutAdminInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  sessions: z.lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutApproverInputSchema).optional(),
  Document: z.lazy(() => DocumentUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUncheckedCreateNestedManyWithoutAddressInputSchema).optional()
}).strict();

export const UserCreateOrConnectWithoutSalesInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutSalesInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserCreateWithoutSalesInputSchema),z.lazy(() => UserUncheckedCreateWithoutSalesInputSchema) ]),
}).strict();

export const SaleTransactionsCreateWithoutSaleInputSchema: z.ZodType<Prisma.SaleTransactionsCreateWithoutSaleInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  tokenSymbol: z.string(),
  quantity: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rawPrice: z.string(),
  price: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  totalAmount: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  formOfPayment: z.lazy(() => FOPSchema),
  confirmationId: z.string().optional().nullable(),
  receivingWallet: z.string().optional().nullable(),
  status: z.lazy(() => TransactionStatusSchema).optional(),
  comment: z.string().optional().nullable(),
  amountPaid: z.string(),
  amountPaidCurrency: z.lazy(() => CurrencySchema),
  txHash: z.string().optional().nullable(),
  agreementId: z.string().optional().nullable(),
  rejectionReason: z.string().optional().nullable(),
  paymentEvidence: z.string().optional().nullable(),
  paymentDate: z.coerce.date().optional().nullable(),
  user: z.lazy(() => UserCreateNestedOneWithoutTransactionsInputSchema),
  blockchain: z.lazy(() => BlockchainCreateNestedOneWithoutTransactionsInputSchema).optional(),
  approver: z.lazy(() => UserCreateNestedOneWithoutTransactionApprovalsInputSchema).optional(),
  auditTrail: z.lazy(() => TransactionAuditCreateNestedManyWithoutTransactionInputSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionCreateNestedManyWithoutTransactionInputSchema).optional()
}).strict();

export const SaleTransactionsUncheckedCreateWithoutSaleInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedCreateWithoutSaleInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  tokenSymbol: z.string(),
  quantity: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rawPrice: z.string(),
  price: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  totalAmount: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  formOfPayment: z.lazy(() => FOPSchema),
  confirmationId: z.string().optional().nullable(),
  receivingWallet: z.string().optional().nullable(),
  status: z.lazy(() => TransactionStatusSchema).optional(),
  userId: z.string(),
  comment: z.string().optional().nullable(),
  amountPaid: z.string(),
  amountPaidCurrency: z.lazy(() => CurrencySchema),
  txHash: z.string().optional().nullable(),
  blockchainId: z.string().optional().nullable(),
  agreementId: z.string().optional().nullable(),
  approvedBy: z.string().optional().nullable(),
  rejectionReason: z.string().optional().nullable(),
  paymentEvidence: z.string().optional().nullable(),
  paymentDate: z.coerce.date().optional().nullable(),
  auditTrail: z.lazy(() => TransactionAuditUncheckedCreateNestedManyWithoutTransactionInputSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionUncheckedCreateNestedManyWithoutTransactionInputSchema).optional()
}).strict();

export const SaleTransactionsCreateOrConnectWithoutSaleInputSchema: z.ZodType<Prisma.SaleTransactionsCreateOrConnectWithoutSaleInput> = z.object({
  where: z.lazy(() => SaleTransactionsWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutSaleInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutSaleInputSchema) ]),
}).strict();

export const SaleTransactionsCreateManySaleInputEnvelopeSchema: z.ZodType<Prisma.SaleTransactionsCreateManySaleInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => SaleTransactionsCreateManySaleInputSchema),z.lazy(() => SaleTransactionsCreateManySaleInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const SaleInformationCreateWithoutSaleInputSchema: z.ZodType<Prisma.SaleInformationCreateWithoutSaleInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  summary: z.string().optional().nullable(),
  tokenUtility: z.string().optional().nullable(),
  tokenDistribution: z.string().optional().nullable(),
  otherInformation: z.string().optional().nullable(),
  tokenLifecycle: z.string().optional().nullable(),
  liquidityPool: z.string().optional().nullable(),
  futurePlans: z.string().optional().nullable(),
  useOfProceeds: z.string().optional().nullable(),
  imageSale: z.string().optional().nullable(),
  imageToken: z.string().optional().nullable(),
  contactEmail: z.string().optional().nullable()
}).strict();

export const SaleInformationUncheckedCreateWithoutSaleInputSchema: z.ZodType<Prisma.SaleInformationUncheckedCreateWithoutSaleInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  summary: z.string().optional().nullable(),
  tokenUtility: z.string().optional().nullable(),
  tokenDistribution: z.string().optional().nullable(),
  otherInformation: z.string().optional().nullable(),
  tokenLifecycle: z.string().optional().nullable(),
  liquidityPool: z.string().optional().nullable(),
  futurePlans: z.string().optional().nullable(),
  useOfProceeds: z.string().optional().nullable(),
  imageSale: z.string().optional().nullable(),
  imageToken: z.string().optional().nullable(),
  contactEmail: z.string().optional().nullable()
}).strict();

export const SaleInformationCreateOrConnectWithoutSaleInputSchema: z.ZodType<Prisma.SaleInformationCreateOrConnectWithoutSaleInput> = z.object({
  where: z.lazy(() => SaleInformationWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => SaleInformationCreateWithoutSaleInputSchema),z.lazy(() => SaleInformationUncheckedCreateWithoutSaleInputSchema) ]),
}).strict();

export const DocumentCreateWithoutSaleInputSchema: z.ZodType<Prisma.DocumentCreateWithoutSaleInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  fileName: z.string(),
  url: z.string(),
  type: z.string(),
  user: z.lazy(() => UserCreateNestedOneWithoutDocumentInputSchema).optional()
}).strict();

export const DocumentUncheckedCreateWithoutSaleInputSchema: z.ZodType<Prisma.DocumentUncheckedCreateWithoutSaleInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  fileName: z.string(),
  url: z.string(),
  type: z.string(),
  userId: z.string().optional().nullable()
}).strict();

export const DocumentCreateOrConnectWithoutSaleInputSchema: z.ZodType<Prisma.DocumentCreateOrConnectWithoutSaleInput> = z.object({
  where: z.lazy(() => DocumentWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => DocumentCreateWithoutSaleInputSchema),z.lazy(() => DocumentUncheckedCreateWithoutSaleInputSchema) ]),
}).strict();

export const DocumentCreateManySaleInputEnvelopeSchema: z.ZodType<Prisma.DocumentCreateManySaleInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => DocumentCreateManySaleInputSchema),z.lazy(() => DocumentCreateManySaleInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const TokenCreateWithoutSalesInputSchema: z.ZodType<Prisma.TokenCreateWithoutSalesInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  symbol: z.string(),
  totalSupply: z.string().optional().nullable(),
  image: z.string().optional().nullable(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsCreateNestedManyWithoutTokenInputSchema).optional()
}).strict();

export const TokenUncheckedCreateWithoutSalesInputSchema: z.ZodType<Prisma.TokenUncheckedCreateWithoutSalesInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  symbol: z.string(),
  totalSupply: z.string().optional().nullable(),
  image: z.string().optional().nullable(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsUncheckedCreateNestedManyWithoutTokenInputSchema).optional()
}).strict();

export const TokenCreateOrConnectWithoutSalesInputSchema: z.ZodType<Prisma.TokenCreateOrConnectWithoutSalesInput> = z.object({
  where: z.lazy(() => TokenWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => TokenCreateWithoutSalesInputSchema),z.lazy(() => TokenUncheckedCreateWithoutSalesInputSchema) ]),
}).strict();

export const VestingScheduleCreateWithoutSaleInputSchema: z.ZodType<Prisma.VestingScheduleCreateWithoutSaleInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  cliffPeriod: z.number().int(),
  vestingPeriod: z.number().int(),
  releaseFrequency: z.number().int(),
  initialRelease: z.number(),
  isEnabled: z.boolean().optional()
}).strict();

export const VestingScheduleUncheckedCreateWithoutSaleInputSchema: z.ZodType<Prisma.VestingScheduleUncheckedCreateWithoutSaleInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  cliffPeriod: z.number().int(),
  vestingPeriod: z.number().int(),
  releaseFrequency: z.number().int(),
  initialRelease: z.number(),
  isEnabled: z.boolean().optional()
}).strict();

export const VestingScheduleCreateOrConnectWithoutSaleInputSchema: z.ZodType<Prisma.VestingScheduleCreateOrConnectWithoutSaleInput> = z.object({
  where: z.lazy(() => VestingScheduleWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => VestingScheduleCreateWithoutSaleInputSchema),z.lazy(() => VestingScheduleUncheckedCreateWithoutSaleInputSchema) ]),
}).strict();

export const VestingScheduleCreateManySaleInputEnvelopeSchema: z.ZodType<Prisma.VestingScheduleCreateManySaleInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => VestingScheduleCreateManySaleInputSchema),z.lazy(() => VestingScheduleCreateManySaleInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const BlockchainUpsertWithoutSaleInputSchema: z.ZodType<Prisma.BlockchainUpsertWithoutSaleInput> = z.object({
  update: z.union([ z.lazy(() => BlockchainUpdateWithoutSaleInputSchema),z.lazy(() => BlockchainUncheckedUpdateWithoutSaleInputSchema) ]),
  create: z.union([ z.lazy(() => BlockchainCreateWithoutSaleInputSchema),z.lazy(() => BlockchainUncheckedCreateWithoutSaleInputSchema) ]),
  where: z.lazy(() => BlockchainWhereInputSchema).optional()
}).strict();

export const BlockchainUpdateToOneWithWhereWithoutSaleInputSchema: z.ZodType<Prisma.BlockchainUpdateToOneWithWhereWithoutSaleInput> = z.object({
  where: z.lazy(() => BlockchainWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => BlockchainUpdateWithoutSaleInputSchema),z.lazy(() => BlockchainUncheckedUpdateWithoutSaleInputSchema) ]),
}).strict();

export const BlockchainUpdateWithoutSaleInputSchema: z.ZodType<Prisma.BlockchainUpdateWithoutSaleInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  chainId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  rpcUrl: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  explorerUrl: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isTestnet: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  isEnabled: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  transactions: z.lazy(() => SaleTransactionsUpdateManyWithoutBlockchainNestedInputSchema).optional(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsUpdateManyWithoutBlockchainNestedInputSchema).optional()
}).strict();

export const BlockchainUncheckedUpdateWithoutSaleInputSchema: z.ZodType<Prisma.BlockchainUncheckedUpdateWithoutSaleInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  chainId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  rpcUrl: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  explorerUrl: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isTestnet: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  isEnabled: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutBlockchainNestedInputSchema).optional(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsUncheckedUpdateManyWithoutBlockchainNestedInputSchema).optional()
}).strict();

export const UserUpsertWithoutSalesInputSchema: z.ZodType<Prisma.UserUpsertWithoutSalesInput> = z.object({
  update: z.union([ z.lazy(() => UserUpdateWithoutSalesInputSchema),z.lazy(() => UserUncheckedUpdateWithoutSalesInputSchema) ]),
  create: z.union([ z.lazy(() => UserCreateWithoutSalesInputSchema),z.lazy(() => UserUncheckedCreateWithoutSalesInputSchema) ]),
  where: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const UserUpdateToOneWithWhereWithoutSalesInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutSalesInput> = z.object({
  where: z.lazy(() => UserWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => UserUpdateWithoutSalesInputSchema),z.lazy(() => UserUncheckedUpdateWithoutSalesInputSchema) ]),
}).strict();

export const UserUpdateWithoutSalesInputSchema: z.ZodType<Prisma.UserUpdateWithoutSalesInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  externalId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailVerified: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isSiwe: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profile: z.lazy(() => ProfileUpdateOneWithoutUserNestedInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUpdateManyWithoutAdminNestedInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUpdateOneWithoutUserNestedInputSchema).optional(),
  sessions: z.lazy(() => SessionUpdateManyWithoutUserNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUpdateManyWithoutApproverNestedInputSchema).optional(),
  Document: z.lazy(() => DocumentUpdateManyWithoutUserNestedInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUpdateManyWithoutAddressNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateWithoutSalesInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutSalesInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  externalId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailVerified: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isSiwe: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profile: z.lazy(() => ProfileUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUncheckedUpdateManyWithoutAdminNestedInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  sessions: z.lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutApproverNestedInputSchema).optional(),
  Document: z.lazy(() => DocumentUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUncheckedUpdateManyWithoutAddressNestedInputSchema).optional()
}).strict();

export const SaleTransactionsUpsertWithWhereUniqueWithoutSaleInputSchema: z.ZodType<Prisma.SaleTransactionsUpsertWithWhereUniqueWithoutSaleInput> = z.object({
  where: z.lazy(() => SaleTransactionsWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => SaleTransactionsUpdateWithoutSaleInputSchema),z.lazy(() => SaleTransactionsUncheckedUpdateWithoutSaleInputSchema) ]),
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutSaleInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutSaleInputSchema) ]),
}).strict();

export const SaleTransactionsUpdateWithWhereUniqueWithoutSaleInputSchema: z.ZodType<Prisma.SaleTransactionsUpdateWithWhereUniqueWithoutSaleInput> = z.object({
  where: z.lazy(() => SaleTransactionsWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => SaleTransactionsUpdateWithoutSaleInputSchema),z.lazy(() => SaleTransactionsUncheckedUpdateWithoutSaleInputSchema) ]),
}).strict();

export const SaleTransactionsUpdateManyWithWhereWithoutSaleInputSchema: z.ZodType<Prisma.SaleTransactionsUpdateManyWithWhereWithoutSaleInput> = z.object({
  where: z.lazy(() => SaleTransactionsScalarWhereInputSchema),
  data: z.union([ z.lazy(() => SaleTransactionsUpdateManyMutationInputSchema),z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutSaleInputSchema) ]),
}).strict();

export const SaleInformationUpsertWithoutSaleInputSchema: z.ZodType<Prisma.SaleInformationUpsertWithoutSaleInput> = z.object({
  update: z.union([ z.lazy(() => SaleInformationUpdateWithoutSaleInputSchema),z.lazy(() => SaleInformationUncheckedUpdateWithoutSaleInputSchema) ]),
  create: z.union([ z.lazy(() => SaleInformationCreateWithoutSaleInputSchema),z.lazy(() => SaleInformationUncheckedCreateWithoutSaleInputSchema) ]),
  where: z.lazy(() => SaleInformationWhereInputSchema).optional()
}).strict();

export const SaleInformationUpdateToOneWithWhereWithoutSaleInputSchema: z.ZodType<Prisma.SaleInformationUpdateToOneWithWhereWithoutSaleInput> = z.object({
  where: z.lazy(() => SaleInformationWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => SaleInformationUpdateWithoutSaleInputSchema),z.lazy(() => SaleInformationUncheckedUpdateWithoutSaleInputSchema) ]),
}).strict();

export const SaleInformationUpdateWithoutSaleInputSchema: z.ZodType<Prisma.SaleInformationUpdateWithoutSaleInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  summary: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenUtility: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenDistribution: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  otherInformation: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenLifecycle: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  liquidityPool: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  futurePlans: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  useOfProceeds: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  imageSale: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  imageToken: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  contactEmail: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const SaleInformationUncheckedUpdateWithoutSaleInputSchema: z.ZodType<Prisma.SaleInformationUncheckedUpdateWithoutSaleInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  summary: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenUtility: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenDistribution: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  otherInformation: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenLifecycle: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  liquidityPool: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  futurePlans: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  useOfProceeds: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  imageSale: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  imageToken: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  contactEmail: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const DocumentUpsertWithWhereUniqueWithoutSaleInputSchema: z.ZodType<Prisma.DocumentUpsertWithWhereUniqueWithoutSaleInput> = z.object({
  where: z.lazy(() => DocumentWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => DocumentUpdateWithoutSaleInputSchema),z.lazy(() => DocumentUncheckedUpdateWithoutSaleInputSchema) ]),
  create: z.union([ z.lazy(() => DocumentCreateWithoutSaleInputSchema),z.lazy(() => DocumentUncheckedCreateWithoutSaleInputSchema) ]),
}).strict();

export const DocumentUpdateWithWhereUniqueWithoutSaleInputSchema: z.ZodType<Prisma.DocumentUpdateWithWhereUniqueWithoutSaleInput> = z.object({
  where: z.lazy(() => DocumentWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => DocumentUpdateWithoutSaleInputSchema),z.lazy(() => DocumentUncheckedUpdateWithoutSaleInputSchema) ]),
}).strict();

export const DocumentUpdateManyWithWhereWithoutSaleInputSchema: z.ZodType<Prisma.DocumentUpdateManyWithWhereWithoutSaleInput> = z.object({
  where: z.lazy(() => DocumentScalarWhereInputSchema),
  data: z.union([ z.lazy(() => DocumentUpdateManyMutationInputSchema),z.lazy(() => DocumentUncheckedUpdateManyWithoutSaleInputSchema) ]),
}).strict();

export const TokenUpsertWithoutSalesInputSchema: z.ZodType<Prisma.TokenUpsertWithoutSalesInput> = z.object({
  update: z.union([ z.lazy(() => TokenUpdateWithoutSalesInputSchema),z.lazy(() => TokenUncheckedUpdateWithoutSalesInputSchema) ]),
  create: z.union([ z.lazy(() => TokenCreateWithoutSalesInputSchema),z.lazy(() => TokenUncheckedCreateWithoutSalesInputSchema) ]),
  where: z.lazy(() => TokenWhereInputSchema).optional()
}).strict();

export const TokenUpdateToOneWithWhereWithoutSalesInputSchema: z.ZodType<Prisma.TokenUpdateToOneWithWhereWithoutSalesInput> = z.object({
  where: z.lazy(() => TokenWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => TokenUpdateWithoutSalesInputSchema),z.lazy(() => TokenUncheckedUpdateWithoutSalesInputSchema) ]),
}).strict();

export const TokenUpdateWithoutSalesInputSchema: z.ZodType<Prisma.TokenUpdateWithoutSalesInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  symbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  totalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsUpdateManyWithoutTokenNestedInputSchema).optional()
}).strict();

export const TokenUncheckedUpdateWithoutSalesInputSchema: z.ZodType<Prisma.TokenUncheckedUpdateWithoutSalesInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  symbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  totalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsUncheckedUpdateManyWithoutTokenNestedInputSchema).optional()
}).strict();

export const VestingScheduleUpsertWithWhereUniqueWithoutSaleInputSchema: z.ZodType<Prisma.VestingScheduleUpsertWithWhereUniqueWithoutSaleInput> = z.object({
  where: z.lazy(() => VestingScheduleWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => VestingScheduleUpdateWithoutSaleInputSchema),z.lazy(() => VestingScheduleUncheckedUpdateWithoutSaleInputSchema) ]),
  create: z.union([ z.lazy(() => VestingScheduleCreateWithoutSaleInputSchema),z.lazy(() => VestingScheduleUncheckedCreateWithoutSaleInputSchema) ]),
}).strict();

export const VestingScheduleUpdateWithWhereUniqueWithoutSaleInputSchema: z.ZodType<Prisma.VestingScheduleUpdateWithWhereUniqueWithoutSaleInput> = z.object({
  where: z.lazy(() => VestingScheduleWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => VestingScheduleUpdateWithoutSaleInputSchema),z.lazy(() => VestingScheduleUncheckedUpdateWithoutSaleInputSchema) ]),
}).strict();

export const VestingScheduleUpdateManyWithWhereWithoutSaleInputSchema: z.ZodType<Prisma.VestingScheduleUpdateManyWithWhereWithoutSaleInput> = z.object({
  where: z.lazy(() => VestingScheduleScalarWhereInputSchema),
  data: z.union([ z.lazy(() => VestingScheduleUpdateManyMutationInputSchema),z.lazy(() => VestingScheduleUncheckedUpdateManyWithoutSaleInputSchema) ]),
}).strict();

export const VestingScheduleScalarWhereInputSchema: z.ZodType<Prisma.VestingScheduleScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => VestingScheduleScalarWhereInputSchema),z.lazy(() => VestingScheduleScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => VestingScheduleScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => VestingScheduleScalarWhereInputSchema),z.lazy(() => VestingScheduleScalarWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  saleId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  cliffPeriod: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  vestingPeriod: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  releaseFrequency: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  initialRelease: z.union([ z.lazy(() => FloatFilterSchema),z.number() ]).optional(),
  isEnabled: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
}).strict();

export const SaleCreateWithoutDocumentsInputSchema: z.ZodType<Prisma.SaleCreateWithoutDocumentsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  status: z.lazy(() => SaleStatusSchema).optional(),
  saleCurrency: z.lazy(() => CurrencySchema).optional(),
  initialTokenQuantity: z.number().int(),
  availableTokenQuantity: z.number().int(),
  maximumTokenBuyPerUser: z.number().int().optional().nullable(),
  minimumTokenBuyPerUser: z.number().int().optional(),
  saleStartDate: z.coerce.date(),
  tokenContractAddress: z.string().optional().nullable(),
  tokenName: z.string(),
  tokenTotalSupply: z.string().optional().nullable(),
  tokenPricePerUnit: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  tokenSymbol: z.string(),
  toWalletsAddress: z.string(),
  saleClosingDate: z.coerce.date(),
  saftCheckbox: z.boolean().optional(),
  saftContract: z.string().optional().nullable(),
  blockchain: z.lazy(() => BlockchainCreateNestedOneWithoutSaleInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutSalesInputSchema),
  transactions: z.lazy(() => SaleTransactionsCreateNestedManyWithoutSaleInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationCreateNestedOneWithoutSaleInputSchema).optional(),
  token: z.lazy(() => TokenCreateNestedOneWithoutSalesInputSchema),
  vestingSchedules: z.lazy(() => VestingScheduleCreateNestedManyWithoutSaleInputSchema).optional()
}).strict();

export const SaleUncheckedCreateWithoutDocumentsInputSchema: z.ZodType<Prisma.SaleUncheckedCreateWithoutDocumentsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  status: z.lazy(() => SaleStatusSchema).optional(),
  saleCurrency: z.lazy(() => CurrencySchema).optional(),
  initialTokenQuantity: z.number().int(),
  availableTokenQuantity: z.number().int(),
  maximumTokenBuyPerUser: z.number().int().optional().nullable(),
  minimumTokenBuyPerUser: z.number().int().optional(),
  saleStartDate: z.coerce.date(),
  tokenContractAddress: z.string().optional().nullable(),
  tokenContractChainId: z.number().int().optional().nullable(),
  tokenName: z.string(),
  tokenTotalSupply: z.string().optional().nullable(),
  tokenPricePerUnit: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  tokenSymbol: z.string(),
  toWalletsAddress: z.string(),
  saleClosingDate: z.coerce.date(),
  createdBy: z.string(),
  saftCheckbox: z.boolean().optional(),
  saftContract: z.string().optional().nullable(),
  tokenId: z.string(),
  transactions: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutSaleInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationUncheckedCreateNestedOneWithoutSaleInputSchema).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleUncheckedCreateNestedManyWithoutSaleInputSchema).optional()
}).strict();

export const SaleCreateOrConnectWithoutDocumentsInputSchema: z.ZodType<Prisma.SaleCreateOrConnectWithoutDocumentsInput> = z.object({
  where: z.lazy(() => SaleWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => SaleCreateWithoutDocumentsInputSchema),z.lazy(() => SaleUncheckedCreateWithoutDocumentsInputSchema) ]),
}).strict();

export const UserCreateWithoutDocumentInputSchema: z.ZodType<Prisma.UserCreateWithoutDocumentInput> = z.object({
  id: z.string().cuid().optional(),
  externalId: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  walletAddress: z.string(),
  email: z.string(),
  emailVerified: z.boolean().optional(),
  image: z.string().optional().nullable(),
  isSiwe: z.boolean().optional().nullable(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutUserInputSchema).optional(),
  sales: z.lazy(() => SaleCreateNestedManyWithoutUserInputSchema).optional(),
  userRole: z.lazy(() => UserRoleCreateNestedManyWithoutUserInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditCreateNestedManyWithoutAdminInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationCreateNestedOneWithoutUserInputSchema).optional(),
  sessions: z.lazy(() => SessionCreateNestedManyWithoutUserInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsCreateNestedManyWithoutUserInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsCreateNestedManyWithoutApproverInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressCreateNestedManyWithoutAddressInputSchema).optional()
}).strict();

export const UserUncheckedCreateWithoutDocumentInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutDocumentInput> = z.object({
  id: z.string().cuid().optional(),
  externalId: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  walletAddress: z.string(),
  email: z.string(),
  emailVerified: z.boolean().optional(),
  image: z.string().optional().nullable(),
  isSiwe: z.boolean().optional().nullable(),
  profile: z.lazy(() => ProfileUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  sales: z.lazy(() => SaleUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUncheckedCreateNestedManyWithoutAdminInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  sessions: z.lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutApproverInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUncheckedCreateNestedManyWithoutAddressInputSchema).optional()
}).strict();

export const UserCreateOrConnectWithoutDocumentInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutDocumentInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserCreateWithoutDocumentInputSchema),z.lazy(() => UserUncheckedCreateWithoutDocumentInputSchema) ]),
}).strict();

export const SaleUpsertWithoutDocumentsInputSchema: z.ZodType<Prisma.SaleUpsertWithoutDocumentsInput> = z.object({
  update: z.union([ z.lazy(() => SaleUpdateWithoutDocumentsInputSchema),z.lazy(() => SaleUncheckedUpdateWithoutDocumentsInputSchema) ]),
  create: z.union([ z.lazy(() => SaleCreateWithoutDocumentsInputSchema),z.lazy(() => SaleUncheckedCreateWithoutDocumentsInputSchema) ]),
  where: z.lazy(() => SaleWhereInputSchema).optional()
}).strict();

export const SaleUpdateToOneWithWhereWithoutDocumentsInputSchema: z.ZodType<Prisma.SaleUpdateToOneWithWhereWithoutDocumentsInput> = z.object({
  where: z.lazy(() => SaleWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => SaleUpdateWithoutDocumentsInputSchema),z.lazy(() => SaleUncheckedUpdateWithoutDocumentsInputSchema) ]),
}).strict();

export const SaleUpdateWithoutDocumentsInputSchema: z.ZodType<Prisma.SaleUpdateWithoutDocumentsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => EnumSaleStatusFieldUpdateOperationsInputSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  initialTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  availableTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  saleStartDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  tokenContractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenTotalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  toWalletsAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleClosingDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  saftCheckbox: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  saftContract: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  blockchain: z.lazy(() => BlockchainUpdateOneWithoutSaleNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutSalesNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUpdateManyWithoutSaleNestedInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationUpdateOneWithoutSaleNestedInputSchema).optional(),
  token: z.lazy(() => TokenUpdateOneRequiredWithoutSalesNestedInputSchema).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleUpdateManyWithoutSaleNestedInputSchema).optional()
}).strict();

export const SaleUncheckedUpdateWithoutDocumentsInputSchema: z.ZodType<Prisma.SaleUncheckedUpdateWithoutDocumentsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => EnumSaleStatusFieldUpdateOperationsInputSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  initialTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  availableTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  saleStartDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  tokenContractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenContractChainId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenTotalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  toWalletsAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleClosingDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  createdBy: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saftCheckbox: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  saftContract: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutSaleNestedInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationUncheckedUpdateOneWithoutSaleNestedInputSchema).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleUncheckedUpdateManyWithoutSaleNestedInputSchema).optional()
}).strict();

export const UserUpsertWithoutDocumentInputSchema: z.ZodType<Prisma.UserUpsertWithoutDocumentInput> = z.object({
  update: z.union([ z.lazy(() => UserUpdateWithoutDocumentInputSchema),z.lazy(() => UserUncheckedUpdateWithoutDocumentInputSchema) ]),
  create: z.union([ z.lazy(() => UserCreateWithoutDocumentInputSchema),z.lazy(() => UserUncheckedCreateWithoutDocumentInputSchema) ]),
  where: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const UserUpdateToOneWithWhereWithoutDocumentInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutDocumentInput> = z.object({
  where: z.lazy(() => UserWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => UserUpdateWithoutDocumentInputSchema),z.lazy(() => UserUncheckedUpdateWithoutDocumentInputSchema) ]),
}).strict();

export const UserUpdateWithoutDocumentInputSchema: z.ZodType<Prisma.UserUpdateWithoutDocumentInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  externalId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailVerified: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isSiwe: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profile: z.lazy(() => ProfileUpdateOneWithoutUserNestedInputSchema).optional(),
  sales: z.lazy(() => SaleUpdateManyWithoutUserNestedInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUpdateManyWithoutAdminNestedInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUpdateOneWithoutUserNestedInputSchema).optional(),
  sessions: z.lazy(() => SessionUpdateManyWithoutUserNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUpdateManyWithoutApproverNestedInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUpdateManyWithoutAddressNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateWithoutDocumentInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutDocumentInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  externalId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailVerified: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isSiwe: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profile: z.lazy(() => ProfileUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  sales: z.lazy(() => SaleUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUncheckedUpdateManyWithoutAdminNestedInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  sessions: z.lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutApproverNestedInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUncheckedUpdateManyWithoutAddressNestedInputSchema).optional()
}).strict();

export const SaleCreateWithoutVestingSchedulesInputSchema: z.ZodType<Prisma.SaleCreateWithoutVestingSchedulesInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  status: z.lazy(() => SaleStatusSchema).optional(),
  saleCurrency: z.lazy(() => CurrencySchema).optional(),
  initialTokenQuantity: z.number().int(),
  availableTokenQuantity: z.number().int(),
  maximumTokenBuyPerUser: z.number().int().optional().nullable(),
  minimumTokenBuyPerUser: z.number().int().optional(),
  saleStartDate: z.coerce.date(),
  tokenContractAddress: z.string().optional().nullable(),
  tokenName: z.string(),
  tokenTotalSupply: z.string().optional().nullable(),
  tokenPricePerUnit: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  tokenSymbol: z.string(),
  toWalletsAddress: z.string(),
  saleClosingDate: z.coerce.date(),
  saftCheckbox: z.boolean().optional(),
  saftContract: z.string().optional().nullable(),
  blockchain: z.lazy(() => BlockchainCreateNestedOneWithoutSaleInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutSalesInputSchema),
  transactions: z.lazy(() => SaleTransactionsCreateNestedManyWithoutSaleInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationCreateNestedOneWithoutSaleInputSchema).optional(),
  documents: z.lazy(() => DocumentCreateNestedManyWithoutSaleInputSchema).optional(),
  token: z.lazy(() => TokenCreateNestedOneWithoutSalesInputSchema)
}).strict();

export const SaleUncheckedCreateWithoutVestingSchedulesInputSchema: z.ZodType<Prisma.SaleUncheckedCreateWithoutVestingSchedulesInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  status: z.lazy(() => SaleStatusSchema).optional(),
  saleCurrency: z.lazy(() => CurrencySchema).optional(),
  initialTokenQuantity: z.number().int(),
  availableTokenQuantity: z.number().int(),
  maximumTokenBuyPerUser: z.number().int().optional().nullable(),
  minimumTokenBuyPerUser: z.number().int().optional(),
  saleStartDate: z.coerce.date(),
  tokenContractAddress: z.string().optional().nullable(),
  tokenContractChainId: z.number().int().optional().nullable(),
  tokenName: z.string(),
  tokenTotalSupply: z.string().optional().nullable(),
  tokenPricePerUnit: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  tokenSymbol: z.string(),
  toWalletsAddress: z.string(),
  saleClosingDate: z.coerce.date(),
  createdBy: z.string(),
  saftCheckbox: z.boolean().optional(),
  saftContract: z.string().optional().nullable(),
  tokenId: z.string(),
  transactions: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutSaleInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationUncheckedCreateNestedOneWithoutSaleInputSchema).optional(),
  documents: z.lazy(() => DocumentUncheckedCreateNestedManyWithoutSaleInputSchema).optional()
}).strict();

export const SaleCreateOrConnectWithoutVestingSchedulesInputSchema: z.ZodType<Prisma.SaleCreateOrConnectWithoutVestingSchedulesInput> = z.object({
  where: z.lazy(() => SaleWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => SaleCreateWithoutVestingSchedulesInputSchema),z.lazy(() => SaleUncheckedCreateWithoutVestingSchedulesInputSchema) ]),
}).strict();

export const SaleUpsertWithoutVestingSchedulesInputSchema: z.ZodType<Prisma.SaleUpsertWithoutVestingSchedulesInput> = z.object({
  update: z.union([ z.lazy(() => SaleUpdateWithoutVestingSchedulesInputSchema),z.lazy(() => SaleUncheckedUpdateWithoutVestingSchedulesInputSchema) ]),
  create: z.union([ z.lazy(() => SaleCreateWithoutVestingSchedulesInputSchema),z.lazy(() => SaleUncheckedCreateWithoutVestingSchedulesInputSchema) ]),
  where: z.lazy(() => SaleWhereInputSchema).optional()
}).strict();

export const SaleUpdateToOneWithWhereWithoutVestingSchedulesInputSchema: z.ZodType<Prisma.SaleUpdateToOneWithWhereWithoutVestingSchedulesInput> = z.object({
  where: z.lazy(() => SaleWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => SaleUpdateWithoutVestingSchedulesInputSchema),z.lazy(() => SaleUncheckedUpdateWithoutVestingSchedulesInputSchema) ]),
}).strict();

export const SaleUpdateWithoutVestingSchedulesInputSchema: z.ZodType<Prisma.SaleUpdateWithoutVestingSchedulesInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => EnumSaleStatusFieldUpdateOperationsInputSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  initialTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  availableTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  saleStartDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  tokenContractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenTotalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  toWalletsAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleClosingDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  saftCheckbox: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  saftContract: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  blockchain: z.lazy(() => BlockchainUpdateOneWithoutSaleNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutSalesNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUpdateManyWithoutSaleNestedInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationUpdateOneWithoutSaleNestedInputSchema).optional(),
  documents: z.lazy(() => DocumentUpdateManyWithoutSaleNestedInputSchema).optional(),
  token: z.lazy(() => TokenUpdateOneRequiredWithoutSalesNestedInputSchema).optional()
}).strict();

export const SaleUncheckedUpdateWithoutVestingSchedulesInputSchema: z.ZodType<Prisma.SaleUncheckedUpdateWithoutVestingSchedulesInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => EnumSaleStatusFieldUpdateOperationsInputSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  initialTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  availableTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  saleStartDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  tokenContractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenContractChainId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenTotalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  toWalletsAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleClosingDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  createdBy: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saftCheckbox: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  saftContract: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutSaleNestedInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationUncheckedUpdateOneWithoutSaleNestedInputSchema).optional(),
  documents: z.lazy(() => DocumentUncheckedUpdateManyWithoutSaleNestedInputSchema).optional()
}).strict();

export const SaleTransactionsCreateWithoutTokenDistributionsInputSchema: z.ZodType<Prisma.SaleTransactionsCreateWithoutTokenDistributionsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  tokenSymbol: z.string(),
  quantity: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rawPrice: z.string(),
  price: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  totalAmount: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  formOfPayment: z.lazy(() => FOPSchema),
  confirmationId: z.string().optional().nullable(),
  receivingWallet: z.string().optional().nullable(),
  status: z.lazy(() => TransactionStatusSchema).optional(),
  comment: z.string().optional().nullable(),
  amountPaid: z.string(),
  amountPaidCurrency: z.lazy(() => CurrencySchema),
  txHash: z.string().optional().nullable(),
  agreementId: z.string().optional().nullable(),
  rejectionReason: z.string().optional().nullable(),
  paymentEvidence: z.string().optional().nullable(),
  paymentDate: z.coerce.date().optional().nullable(),
  user: z.lazy(() => UserCreateNestedOneWithoutTransactionsInputSchema),
  sale: z.lazy(() => SaleCreateNestedOneWithoutTransactionsInputSchema),
  blockchain: z.lazy(() => BlockchainCreateNestedOneWithoutTransactionsInputSchema).optional(),
  approver: z.lazy(() => UserCreateNestedOneWithoutTransactionApprovalsInputSchema).optional(),
  auditTrail: z.lazy(() => TransactionAuditCreateNestedManyWithoutTransactionInputSchema).optional()
}).strict();

export const SaleTransactionsUncheckedCreateWithoutTokenDistributionsInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedCreateWithoutTokenDistributionsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  tokenSymbol: z.string(),
  quantity: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rawPrice: z.string(),
  price: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  totalAmount: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  formOfPayment: z.lazy(() => FOPSchema),
  confirmationId: z.string().optional().nullable(),
  receivingWallet: z.string().optional().nullable(),
  status: z.lazy(() => TransactionStatusSchema).optional(),
  userId: z.string(),
  saleId: z.string(),
  comment: z.string().optional().nullable(),
  amountPaid: z.string(),
  amountPaidCurrency: z.lazy(() => CurrencySchema),
  txHash: z.string().optional().nullable(),
  blockchainId: z.string().optional().nullable(),
  agreementId: z.string().optional().nullable(),
  approvedBy: z.string().optional().nullable(),
  rejectionReason: z.string().optional().nullable(),
  paymentEvidence: z.string().optional().nullable(),
  paymentDate: z.coerce.date().optional().nullable(),
  auditTrail: z.lazy(() => TransactionAuditUncheckedCreateNestedManyWithoutTransactionInputSchema).optional()
}).strict();

export const SaleTransactionsCreateOrConnectWithoutTokenDistributionsInputSchema: z.ZodType<Prisma.SaleTransactionsCreateOrConnectWithoutTokenDistributionsInput> = z.object({
  where: z.lazy(() => SaleTransactionsWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutTokenDistributionsInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutTokenDistributionsInputSchema) ]),
}).strict();

export const SaleTransactionsUpsertWithoutTokenDistributionsInputSchema: z.ZodType<Prisma.SaleTransactionsUpsertWithoutTokenDistributionsInput> = z.object({
  update: z.union([ z.lazy(() => SaleTransactionsUpdateWithoutTokenDistributionsInputSchema),z.lazy(() => SaleTransactionsUncheckedUpdateWithoutTokenDistributionsInputSchema) ]),
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutTokenDistributionsInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutTokenDistributionsInputSchema) ]),
  where: z.lazy(() => SaleTransactionsWhereInputSchema).optional()
}).strict();

export const SaleTransactionsUpdateToOneWithWhereWithoutTokenDistributionsInputSchema: z.ZodType<Prisma.SaleTransactionsUpdateToOneWithWhereWithoutTokenDistributionsInput> = z.object({
  where: z.lazy(() => SaleTransactionsWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => SaleTransactionsUpdateWithoutTokenDistributionsInputSchema),z.lazy(() => SaleTransactionsUncheckedUpdateWithoutTokenDistributionsInputSchema) ]),
}).strict();

export const SaleTransactionsUpdateWithoutTokenDistributionsInputSchema: z.ZodType<Prisma.SaleTransactionsUpdateWithoutTokenDistributionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  quantity: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rawPrice: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  price: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  totalAmount: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  formOfPayment: z.union([ z.lazy(() => FOPSchema),z.lazy(() => EnumFOPFieldUpdateOperationsInputSchema) ]).optional(),
  confirmationId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  receivingWallet: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amountPaid: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  amountPaidCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  agreementId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentEvidence: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentDate: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutTransactionsNestedInputSchema).optional(),
  sale: z.lazy(() => SaleUpdateOneRequiredWithoutTransactionsNestedInputSchema).optional(),
  blockchain: z.lazy(() => BlockchainUpdateOneWithoutTransactionsNestedInputSchema).optional(),
  approver: z.lazy(() => UserUpdateOneWithoutTransactionApprovalsNestedInputSchema).optional(),
  auditTrail: z.lazy(() => TransactionAuditUpdateManyWithoutTransactionNestedInputSchema).optional()
}).strict();

export const SaleTransactionsUncheckedUpdateWithoutTokenDistributionsInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedUpdateWithoutTokenDistributionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  quantity: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rawPrice: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  price: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  totalAmount: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  formOfPayment: z.union([ z.lazy(() => FOPSchema),z.lazy(() => EnumFOPFieldUpdateOperationsInputSchema) ]).optional(),
  confirmationId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  receivingWallet: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amountPaid: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  amountPaidCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  blockchainId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  agreementId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  approvedBy: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentEvidence: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentDate: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  auditTrail: z.lazy(() => TransactionAuditUncheckedUpdateManyWithoutTransactionNestedInputSchema).optional()
}).strict();

export const SaleCreateWithoutSaleInformationInputSchema: z.ZodType<Prisma.SaleCreateWithoutSaleInformationInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  status: z.lazy(() => SaleStatusSchema).optional(),
  saleCurrency: z.lazy(() => CurrencySchema).optional(),
  initialTokenQuantity: z.number().int(),
  availableTokenQuantity: z.number().int(),
  maximumTokenBuyPerUser: z.number().int().optional().nullable(),
  minimumTokenBuyPerUser: z.number().int().optional(),
  saleStartDate: z.coerce.date(),
  tokenContractAddress: z.string().optional().nullable(),
  tokenName: z.string(),
  tokenTotalSupply: z.string().optional().nullable(),
  tokenPricePerUnit: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  tokenSymbol: z.string(),
  toWalletsAddress: z.string(),
  saleClosingDate: z.coerce.date(),
  saftCheckbox: z.boolean().optional(),
  saftContract: z.string().optional().nullable(),
  blockchain: z.lazy(() => BlockchainCreateNestedOneWithoutSaleInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutSalesInputSchema),
  transactions: z.lazy(() => SaleTransactionsCreateNestedManyWithoutSaleInputSchema).optional(),
  documents: z.lazy(() => DocumentCreateNestedManyWithoutSaleInputSchema).optional(),
  token: z.lazy(() => TokenCreateNestedOneWithoutSalesInputSchema),
  vestingSchedules: z.lazy(() => VestingScheduleCreateNestedManyWithoutSaleInputSchema).optional()
}).strict();

export const SaleUncheckedCreateWithoutSaleInformationInputSchema: z.ZodType<Prisma.SaleUncheckedCreateWithoutSaleInformationInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  status: z.lazy(() => SaleStatusSchema).optional(),
  saleCurrency: z.lazy(() => CurrencySchema).optional(),
  initialTokenQuantity: z.number().int(),
  availableTokenQuantity: z.number().int(),
  maximumTokenBuyPerUser: z.number().int().optional().nullable(),
  minimumTokenBuyPerUser: z.number().int().optional(),
  saleStartDate: z.coerce.date(),
  tokenContractAddress: z.string().optional().nullable(),
  tokenContractChainId: z.number().int().optional().nullable(),
  tokenName: z.string(),
  tokenTotalSupply: z.string().optional().nullable(),
  tokenPricePerUnit: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  tokenSymbol: z.string(),
  toWalletsAddress: z.string(),
  saleClosingDate: z.coerce.date(),
  createdBy: z.string(),
  saftCheckbox: z.boolean().optional(),
  saftContract: z.string().optional().nullable(),
  tokenId: z.string(),
  transactions: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutSaleInputSchema).optional(),
  documents: z.lazy(() => DocumentUncheckedCreateNestedManyWithoutSaleInputSchema).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleUncheckedCreateNestedManyWithoutSaleInputSchema).optional()
}).strict();

export const SaleCreateOrConnectWithoutSaleInformationInputSchema: z.ZodType<Prisma.SaleCreateOrConnectWithoutSaleInformationInput> = z.object({
  where: z.lazy(() => SaleWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => SaleCreateWithoutSaleInformationInputSchema),z.lazy(() => SaleUncheckedCreateWithoutSaleInformationInputSchema) ]),
}).strict();

export const SaleUpsertWithoutSaleInformationInputSchema: z.ZodType<Prisma.SaleUpsertWithoutSaleInformationInput> = z.object({
  update: z.union([ z.lazy(() => SaleUpdateWithoutSaleInformationInputSchema),z.lazy(() => SaleUncheckedUpdateWithoutSaleInformationInputSchema) ]),
  create: z.union([ z.lazy(() => SaleCreateWithoutSaleInformationInputSchema),z.lazy(() => SaleUncheckedCreateWithoutSaleInformationInputSchema) ]),
  where: z.lazy(() => SaleWhereInputSchema).optional()
}).strict();

export const SaleUpdateToOneWithWhereWithoutSaleInformationInputSchema: z.ZodType<Prisma.SaleUpdateToOneWithWhereWithoutSaleInformationInput> = z.object({
  where: z.lazy(() => SaleWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => SaleUpdateWithoutSaleInformationInputSchema),z.lazy(() => SaleUncheckedUpdateWithoutSaleInformationInputSchema) ]),
}).strict();

export const SaleUpdateWithoutSaleInformationInputSchema: z.ZodType<Prisma.SaleUpdateWithoutSaleInformationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => EnumSaleStatusFieldUpdateOperationsInputSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  initialTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  availableTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  saleStartDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  tokenContractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenTotalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  toWalletsAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleClosingDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  saftCheckbox: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  saftContract: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  blockchain: z.lazy(() => BlockchainUpdateOneWithoutSaleNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutSalesNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUpdateManyWithoutSaleNestedInputSchema).optional(),
  documents: z.lazy(() => DocumentUpdateManyWithoutSaleNestedInputSchema).optional(),
  token: z.lazy(() => TokenUpdateOneRequiredWithoutSalesNestedInputSchema).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleUpdateManyWithoutSaleNestedInputSchema).optional()
}).strict();

export const SaleUncheckedUpdateWithoutSaleInformationInputSchema: z.ZodType<Prisma.SaleUncheckedUpdateWithoutSaleInformationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => EnumSaleStatusFieldUpdateOperationsInputSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  initialTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  availableTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  saleStartDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  tokenContractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenContractChainId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenTotalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  toWalletsAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleClosingDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  createdBy: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saftCheckbox: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  saftContract: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutSaleNestedInputSchema).optional(),
  documents: z.lazy(() => DocumentUncheckedUpdateManyWithoutSaleNestedInputSchema).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleUncheckedUpdateManyWithoutSaleNestedInputSchema).optional()
}).strict();

export const UserCreateWithoutTransactionsInputSchema: z.ZodType<Prisma.UserCreateWithoutTransactionsInput> = z.object({
  id: z.string().cuid().optional(),
  externalId: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  walletAddress: z.string(),
  email: z.string(),
  emailVerified: z.boolean().optional(),
  image: z.string().optional().nullable(),
  isSiwe: z.boolean().optional().nullable(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutUserInputSchema).optional(),
  sales: z.lazy(() => SaleCreateNestedManyWithoutUserInputSchema).optional(),
  userRole: z.lazy(() => UserRoleCreateNestedManyWithoutUserInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditCreateNestedManyWithoutAdminInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationCreateNestedOneWithoutUserInputSchema).optional(),
  sessions: z.lazy(() => SessionCreateNestedManyWithoutUserInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsCreateNestedManyWithoutApproverInputSchema).optional(),
  Document: z.lazy(() => DocumentCreateNestedManyWithoutUserInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressCreateNestedManyWithoutAddressInputSchema).optional()
}).strict();

export const UserUncheckedCreateWithoutTransactionsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutTransactionsInput> = z.object({
  id: z.string().cuid().optional(),
  externalId: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  walletAddress: z.string(),
  email: z.string(),
  emailVerified: z.boolean().optional(),
  image: z.string().optional().nullable(),
  isSiwe: z.boolean().optional().nullable(),
  profile: z.lazy(() => ProfileUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  sales: z.lazy(() => SaleUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUncheckedCreateNestedManyWithoutAdminInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  sessions: z.lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutApproverInputSchema).optional(),
  Document: z.lazy(() => DocumentUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUncheckedCreateNestedManyWithoutAddressInputSchema).optional()
}).strict();

export const UserCreateOrConnectWithoutTransactionsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutTransactionsInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserCreateWithoutTransactionsInputSchema),z.lazy(() => UserUncheckedCreateWithoutTransactionsInputSchema) ]),
}).strict();

export const SaleCreateWithoutTransactionsInputSchema: z.ZodType<Prisma.SaleCreateWithoutTransactionsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  status: z.lazy(() => SaleStatusSchema).optional(),
  saleCurrency: z.lazy(() => CurrencySchema).optional(),
  initialTokenQuantity: z.number().int(),
  availableTokenQuantity: z.number().int(),
  maximumTokenBuyPerUser: z.number().int().optional().nullable(),
  minimumTokenBuyPerUser: z.number().int().optional(),
  saleStartDate: z.coerce.date(),
  tokenContractAddress: z.string().optional().nullable(),
  tokenName: z.string(),
  tokenTotalSupply: z.string().optional().nullable(),
  tokenPricePerUnit: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  tokenSymbol: z.string(),
  toWalletsAddress: z.string(),
  saleClosingDate: z.coerce.date(),
  saftCheckbox: z.boolean().optional(),
  saftContract: z.string().optional().nullable(),
  blockchain: z.lazy(() => BlockchainCreateNestedOneWithoutSaleInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutSalesInputSchema),
  saleInformation: z.lazy(() => SaleInformationCreateNestedOneWithoutSaleInputSchema).optional(),
  documents: z.lazy(() => DocumentCreateNestedManyWithoutSaleInputSchema).optional(),
  token: z.lazy(() => TokenCreateNestedOneWithoutSalesInputSchema),
  vestingSchedules: z.lazy(() => VestingScheduleCreateNestedManyWithoutSaleInputSchema).optional()
}).strict();

export const SaleUncheckedCreateWithoutTransactionsInputSchema: z.ZodType<Prisma.SaleUncheckedCreateWithoutTransactionsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  status: z.lazy(() => SaleStatusSchema).optional(),
  saleCurrency: z.lazy(() => CurrencySchema).optional(),
  initialTokenQuantity: z.number().int(),
  availableTokenQuantity: z.number().int(),
  maximumTokenBuyPerUser: z.number().int().optional().nullable(),
  minimumTokenBuyPerUser: z.number().int().optional(),
  saleStartDate: z.coerce.date(),
  tokenContractAddress: z.string().optional().nullable(),
  tokenContractChainId: z.number().int().optional().nullable(),
  tokenName: z.string(),
  tokenTotalSupply: z.string().optional().nullable(),
  tokenPricePerUnit: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  tokenSymbol: z.string(),
  toWalletsAddress: z.string(),
  saleClosingDate: z.coerce.date(),
  createdBy: z.string(),
  saftCheckbox: z.boolean().optional(),
  saftContract: z.string().optional().nullable(),
  tokenId: z.string(),
  saleInformation: z.lazy(() => SaleInformationUncheckedCreateNestedOneWithoutSaleInputSchema).optional(),
  documents: z.lazy(() => DocumentUncheckedCreateNestedManyWithoutSaleInputSchema).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleUncheckedCreateNestedManyWithoutSaleInputSchema).optional()
}).strict();

export const SaleCreateOrConnectWithoutTransactionsInputSchema: z.ZodType<Prisma.SaleCreateOrConnectWithoutTransactionsInput> = z.object({
  where: z.lazy(() => SaleWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => SaleCreateWithoutTransactionsInputSchema),z.lazy(() => SaleUncheckedCreateWithoutTransactionsInputSchema) ]),
}).strict();

export const BlockchainCreateWithoutTransactionsInputSchema: z.ZodType<Prisma.BlockchainCreateWithoutTransactionsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  chainId: z.number().int(),
  rpcUrl: z.string(),
  explorerUrl: z.string().optional().nullable(),
  isTestnet: z.boolean().optional(),
  isEnabled: z.boolean().optional(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsCreateNestedManyWithoutBlockchainInputSchema).optional(),
  Sale: z.lazy(() => SaleCreateNestedManyWithoutBlockchainInputSchema).optional()
}).strict();

export const BlockchainUncheckedCreateWithoutTransactionsInputSchema: z.ZodType<Prisma.BlockchainUncheckedCreateWithoutTransactionsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  chainId: z.number().int(),
  rpcUrl: z.string(),
  explorerUrl: z.string().optional().nullable(),
  isTestnet: z.boolean().optional(),
  isEnabled: z.boolean().optional(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsUncheckedCreateNestedManyWithoutBlockchainInputSchema).optional(),
  Sale: z.lazy(() => SaleUncheckedCreateNestedManyWithoutBlockchainInputSchema).optional()
}).strict();

export const BlockchainCreateOrConnectWithoutTransactionsInputSchema: z.ZodType<Prisma.BlockchainCreateOrConnectWithoutTransactionsInput> = z.object({
  where: z.lazy(() => BlockchainWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => BlockchainCreateWithoutTransactionsInputSchema),z.lazy(() => BlockchainUncheckedCreateWithoutTransactionsInputSchema) ]),
}).strict();

export const UserCreateWithoutTransactionApprovalsInputSchema: z.ZodType<Prisma.UserCreateWithoutTransactionApprovalsInput> = z.object({
  id: z.string().cuid().optional(),
  externalId: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  walletAddress: z.string(),
  email: z.string(),
  emailVerified: z.boolean().optional(),
  image: z.string().optional().nullable(),
  isSiwe: z.boolean().optional().nullable(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutUserInputSchema).optional(),
  sales: z.lazy(() => SaleCreateNestedManyWithoutUserInputSchema).optional(),
  userRole: z.lazy(() => UserRoleCreateNestedManyWithoutUserInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditCreateNestedManyWithoutAdminInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationCreateNestedOneWithoutUserInputSchema).optional(),
  sessions: z.lazy(() => SessionCreateNestedManyWithoutUserInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsCreateNestedManyWithoutUserInputSchema).optional(),
  Document: z.lazy(() => DocumentCreateNestedManyWithoutUserInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressCreateNestedManyWithoutAddressInputSchema).optional()
}).strict();

export const UserUncheckedCreateWithoutTransactionApprovalsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutTransactionApprovalsInput> = z.object({
  id: z.string().cuid().optional(),
  externalId: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  walletAddress: z.string(),
  email: z.string(),
  emailVerified: z.boolean().optional(),
  image: z.string().optional().nullable(),
  isSiwe: z.boolean().optional().nullable(),
  profile: z.lazy(() => ProfileUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  sales: z.lazy(() => SaleUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUncheckedCreateNestedManyWithoutAdminInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  sessions: z.lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  Document: z.lazy(() => DocumentUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUncheckedCreateNestedManyWithoutAddressInputSchema).optional()
}).strict();

export const UserCreateOrConnectWithoutTransactionApprovalsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutTransactionApprovalsInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserCreateWithoutTransactionApprovalsInputSchema),z.lazy(() => UserUncheckedCreateWithoutTransactionApprovalsInputSchema) ]),
}).strict();

export const TransactionAuditCreateWithoutTransactionInputSchema: z.ZodType<Prisma.TransactionAuditCreateWithoutTransactionInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  actionType: z.string(),
  fromStatus: z.lazy(() => TransactionStatusSchema),
  toStatus: z.lazy(() => TransactionStatusSchema),
  comment: z.string().optional().nullable(),
  admin: z.lazy(() => UserCreateNestedOneWithoutTransactionAuditInputSchema)
}).strict();

export const TransactionAuditUncheckedCreateWithoutTransactionInputSchema: z.ZodType<Prisma.TransactionAuditUncheckedCreateWithoutTransactionInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  actionType: z.string(),
  fromStatus: z.lazy(() => TransactionStatusSchema),
  toStatus: z.lazy(() => TransactionStatusSchema),
  performedBy: z.string(),
  comment: z.string().optional().nullable()
}).strict();

export const TransactionAuditCreateOrConnectWithoutTransactionInputSchema: z.ZodType<Prisma.TransactionAuditCreateOrConnectWithoutTransactionInput> = z.object({
  where: z.lazy(() => TransactionAuditWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => TransactionAuditCreateWithoutTransactionInputSchema),z.lazy(() => TransactionAuditUncheckedCreateWithoutTransactionInputSchema) ]),
}).strict();

export const TransactionAuditCreateManyTransactionInputEnvelopeSchema: z.ZodType<Prisma.TransactionAuditCreateManyTransactionInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => TransactionAuditCreateManyTransactionInputSchema),z.lazy(() => TransactionAuditCreateManyTransactionInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const TokenDistributionCreateWithoutTransactionInputSchema: z.ZodType<Prisma.TokenDistributionCreateWithoutTransactionInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  amount: z.string(),
  distributionDate: z.coerce.date(),
  txHash: z.string().optional().nullable(),
  status: z.string()
}).strict();

export const TokenDistributionUncheckedCreateWithoutTransactionInputSchema: z.ZodType<Prisma.TokenDistributionUncheckedCreateWithoutTransactionInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  amount: z.string(),
  distributionDate: z.coerce.date(),
  txHash: z.string().optional().nullable(),
  status: z.string()
}).strict();

export const TokenDistributionCreateOrConnectWithoutTransactionInputSchema: z.ZodType<Prisma.TokenDistributionCreateOrConnectWithoutTransactionInput> = z.object({
  where: z.lazy(() => TokenDistributionWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => TokenDistributionCreateWithoutTransactionInputSchema),z.lazy(() => TokenDistributionUncheckedCreateWithoutTransactionInputSchema) ]),
}).strict();

export const TokenDistributionCreateManyTransactionInputEnvelopeSchema: z.ZodType<Prisma.TokenDistributionCreateManyTransactionInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => TokenDistributionCreateManyTransactionInputSchema),z.lazy(() => TokenDistributionCreateManyTransactionInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const UserUpsertWithoutTransactionsInputSchema: z.ZodType<Prisma.UserUpsertWithoutTransactionsInput> = z.object({
  update: z.union([ z.lazy(() => UserUpdateWithoutTransactionsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutTransactionsInputSchema) ]),
  create: z.union([ z.lazy(() => UserCreateWithoutTransactionsInputSchema),z.lazy(() => UserUncheckedCreateWithoutTransactionsInputSchema) ]),
  where: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const UserUpdateToOneWithWhereWithoutTransactionsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutTransactionsInput> = z.object({
  where: z.lazy(() => UserWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => UserUpdateWithoutTransactionsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutTransactionsInputSchema) ]),
}).strict();

export const UserUpdateWithoutTransactionsInputSchema: z.ZodType<Prisma.UserUpdateWithoutTransactionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  externalId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailVerified: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isSiwe: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profile: z.lazy(() => ProfileUpdateOneWithoutUserNestedInputSchema).optional(),
  sales: z.lazy(() => SaleUpdateManyWithoutUserNestedInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUpdateManyWithoutAdminNestedInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUpdateOneWithoutUserNestedInputSchema).optional(),
  sessions: z.lazy(() => SessionUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUpdateManyWithoutApproverNestedInputSchema).optional(),
  Document: z.lazy(() => DocumentUpdateManyWithoutUserNestedInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUpdateManyWithoutAddressNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateWithoutTransactionsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutTransactionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  externalId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailVerified: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isSiwe: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profile: z.lazy(() => ProfileUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  sales: z.lazy(() => SaleUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUncheckedUpdateManyWithoutAdminNestedInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  sessions: z.lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutApproverNestedInputSchema).optional(),
  Document: z.lazy(() => DocumentUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUncheckedUpdateManyWithoutAddressNestedInputSchema).optional()
}).strict();

export const SaleUpsertWithoutTransactionsInputSchema: z.ZodType<Prisma.SaleUpsertWithoutTransactionsInput> = z.object({
  update: z.union([ z.lazy(() => SaleUpdateWithoutTransactionsInputSchema),z.lazy(() => SaleUncheckedUpdateWithoutTransactionsInputSchema) ]),
  create: z.union([ z.lazy(() => SaleCreateWithoutTransactionsInputSchema),z.lazy(() => SaleUncheckedCreateWithoutTransactionsInputSchema) ]),
  where: z.lazy(() => SaleWhereInputSchema).optional()
}).strict();

export const SaleUpdateToOneWithWhereWithoutTransactionsInputSchema: z.ZodType<Prisma.SaleUpdateToOneWithWhereWithoutTransactionsInput> = z.object({
  where: z.lazy(() => SaleWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => SaleUpdateWithoutTransactionsInputSchema),z.lazy(() => SaleUncheckedUpdateWithoutTransactionsInputSchema) ]),
}).strict();

export const SaleUpdateWithoutTransactionsInputSchema: z.ZodType<Prisma.SaleUpdateWithoutTransactionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => EnumSaleStatusFieldUpdateOperationsInputSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  initialTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  availableTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  saleStartDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  tokenContractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenTotalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  toWalletsAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleClosingDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  saftCheckbox: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  saftContract: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  blockchain: z.lazy(() => BlockchainUpdateOneWithoutSaleNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutSalesNestedInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationUpdateOneWithoutSaleNestedInputSchema).optional(),
  documents: z.lazy(() => DocumentUpdateManyWithoutSaleNestedInputSchema).optional(),
  token: z.lazy(() => TokenUpdateOneRequiredWithoutSalesNestedInputSchema).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleUpdateManyWithoutSaleNestedInputSchema).optional()
}).strict();

export const SaleUncheckedUpdateWithoutTransactionsInputSchema: z.ZodType<Prisma.SaleUncheckedUpdateWithoutTransactionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => EnumSaleStatusFieldUpdateOperationsInputSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  initialTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  availableTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  saleStartDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  tokenContractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenContractChainId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenTotalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  toWalletsAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleClosingDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  createdBy: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saftCheckbox: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  saftContract: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleInformation: z.lazy(() => SaleInformationUncheckedUpdateOneWithoutSaleNestedInputSchema).optional(),
  documents: z.lazy(() => DocumentUncheckedUpdateManyWithoutSaleNestedInputSchema).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleUncheckedUpdateManyWithoutSaleNestedInputSchema).optional()
}).strict();

export const BlockchainUpsertWithoutTransactionsInputSchema: z.ZodType<Prisma.BlockchainUpsertWithoutTransactionsInput> = z.object({
  update: z.union([ z.lazy(() => BlockchainUpdateWithoutTransactionsInputSchema),z.lazy(() => BlockchainUncheckedUpdateWithoutTransactionsInputSchema) ]),
  create: z.union([ z.lazy(() => BlockchainCreateWithoutTransactionsInputSchema),z.lazy(() => BlockchainUncheckedCreateWithoutTransactionsInputSchema) ]),
  where: z.lazy(() => BlockchainWhereInputSchema).optional()
}).strict();

export const BlockchainUpdateToOneWithWhereWithoutTransactionsInputSchema: z.ZodType<Prisma.BlockchainUpdateToOneWithWhereWithoutTransactionsInput> = z.object({
  where: z.lazy(() => BlockchainWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => BlockchainUpdateWithoutTransactionsInputSchema),z.lazy(() => BlockchainUncheckedUpdateWithoutTransactionsInputSchema) ]),
}).strict();

export const BlockchainUpdateWithoutTransactionsInputSchema: z.ZodType<Prisma.BlockchainUpdateWithoutTransactionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  chainId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  rpcUrl: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  explorerUrl: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isTestnet: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  isEnabled: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsUpdateManyWithoutBlockchainNestedInputSchema).optional(),
  Sale: z.lazy(() => SaleUpdateManyWithoutBlockchainNestedInputSchema).optional()
}).strict();

export const BlockchainUncheckedUpdateWithoutTransactionsInputSchema: z.ZodType<Prisma.BlockchainUncheckedUpdateWithoutTransactionsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  chainId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  rpcUrl: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  explorerUrl: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isTestnet: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  isEnabled: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  TokensOnBlockchains: z.lazy(() => TokensOnBlockchainsUncheckedUpdateManyWithoutBlockchainNestedInputSchema).optional(),
  Sale: z.lazy(() => SaleUncheckedUpdateManyWithoutBlockchainNestedInputSchema).optional()
}).strict();

export const UserUpsertWithoutTransactionApprovalsInputSchema: z.ZodType<Prisma.UserUpsertWithoutTransactionApprovalsInput> = z.object({
  update: z.union([ z.lazy(() => UserUpdateWithoutTransactionApprovalsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutTransactionApprovalsInputSchema) ]),
  create: z.union([ z.lazy(() => UserCreateWithoutTransactionApprovalsInputSchema),z.lazy(() => UserUncheckedCreateWithoutTransactionApprovalsInputSchema) ]),
  where: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const UserUpdateToOneWithWhereWithoutTransactionApprovalsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutTransactionApprovalsInput> = z.object({
  where: z.lazy(() => UserWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => UserUpdateWithoutTransactionApprovalsInputSchema),z.lazy(() => UserUncheckedUpdateWithoutTransactionApprovalsInputSchema) ]),
}).strict();

export const UserUpdateWithoutTransactionApprovalsInputSchema: z.ZodType<Prisma.UserUpdateWithoutTransactionApprovalsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  externalId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailVerified: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isSiwe: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profile: z.lazy(() => ProfileUpdateOneWithoutUserNestedInputSchema).optional(),
  sales: z.lazy(() => SaleUpdateManyWithoutUserNestedInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUpdateManyWithoutAdminNestedInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUpdateOneWithoutUserNestedInputSchema).optional(),
  sessions: z.lazy(() => SessionUpdateManyWithoutUserNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUpdateManyWithoutUserNestedInputSchema).optional(),
  Document: z.lazy(() => DocumentUpdateManyWithoutUserNestedInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUpdateManyWithoutAddressNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateWithoutTransactionApprovalsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutTransactionApprovalsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  externalId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailVerified: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isSiwe: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profile: z.lazy(() => ProfileUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  sales: z.lazy(() => SaleUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUncheckedUpdateManyWithoutAdminNestedInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  sessions: z.lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  Document: z.lazy(() => DocumentUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUncheckedUpdateManyWithoutAddressNestedInputSchema).optional()
}).strict();

export const TransactionAuditUpsertWithWhereUniqueWithoutTransactionInputSchema: z.ZodType<Prisma.TransactionAuditUpsertWithWhereUniqueWithoutTransactionInput> = z.object({
  where: z.lazy(() => TransactionAuditWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => TransactionAuditUpdateWithoutTransactionInputSchema),z.lazy(() => TransactionAuditUncheckedUpdateWithoutTransactionInputSchema) ]),
  create: z.union([ z.lazy(() => TransactionAuditCreateWithoutTransactionInputSchema),z.lazy(() => TransactionAuditUncheckedCreateWithoutTransactionInputSchema) ]),
}).strict();

export const TransactionAuditUpdateWithWhereUniqueWithoutTransactionInputSchema: z.ZodType<Prisma.TransactionAuditUpdateWithWhereUniqueWithoutTransactionInput> = z.object({
  where: z.lazy(() => TransactionAuditWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => TransactionAuditUpdateWithoutTransactionInputSchema),z.lazy(() => TransactionAuditUncheckedUpdateWithoutTransactionInputSchema) ]),
}).strict();

export const TransactionAuditUpdateManyWithWhereWithoutTransactionInputSchema: z.ZodType<Prisma.TransactionAuditUpdateManyWithWhereWithoutTransactionInput> = z.object({
  where: z.lazy(() => TransactionAuditScalarWhereInputSchema),
  data: z.union([ z.lazy(() => TransactionAuditUpdateManyMutationInputSchema),z.lazy(() => TransactionAuditUncheckedUpdateManyWithoutTransactionInputSchema) ]),
}).strict();

export const TokenDistributionUpsertWithWhereUniqueWithoutTransactionInputSchema: z.ZodType<Prisma.TokenDistributionUpsertWithWhereUniqueWithoutTransactionInput> = z.object({
  where: z.lazy(() => TokenDistributionWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => TokenDistributionUpdateWithoutTransactionInputSchema),z.lazy(() => TokenDistributionUncheckedUpdateWithoutTransactionInputSchema) ]),
  create: z.union([ z.lazy(() => TokenDistributionCreateWithoutTransactionInputSchema),z.lazy(() => TokenDistributionUncheckedCreateWithoutTransactionInputSchema) ]),
}).strict();

export const TokenDistributionUpdateWithWhereUniqueWithoutTransactionInputSchema: z.ZodType<Prisma.TokenDistributionUpdateWithWhereUniqueWithoutTransactionInput> = z.object({
  where: z.lazy(() => TokenDistributionWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => TokenDistributionUpdateWithoutTransactionInputSchema),z.lazy(() => TokenDistributionUncheckedUpdateWithoutTransactionInputSchema) ]),
}).strict();

export const TokenDistributionUpdateManyWithWhereWithoutTransactionInputSchema: z.ZodType<Prisma.TokenDistributionUpdateManyWithWhereWithoutTransactionInput> = z.object({
  where: z.lazy(() => TokenDistributionScalarWhereInputSchema),
  data: z.union([ z.lazy(() => TokenDistributionUpdateManyMutationInputSchema),z.lazy(() => TokenDistributionUncheckedUpdateManyWithoutTransactionInputSchema) ]),
}).strict();

export const TokenDistributionScalarWhereInputSchema: z.ZodType<Prisma.TokenDistributionScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => TokenDistributionScalarWhereInputSchema),z.lazy(() => TokenDistributionScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => TokenDistributionScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TokenDistributionScalarWhereInputSchema),z.lazy(() => TokenDistributionScalarWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  createdAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  updatedAt: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  deletedAt: z.union([ z.lazy(() => DateTimeNullableFilterSchema),z.coerce.date() ]).optional().nullable(),
  transactionId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  amount: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  distributionDate: z.union([ z.lazy(() => DateTimeFilterSchema),z.coerce.date() ]).optional(),
  txHash: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
  status: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
}).strict();

export const SaleTransactionsCreateWithoutBlockchainInputSchema: z.ZodType<Prisma.SaleTransactionsCreateWithoutBlockchainInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  tokenSymbol: z.string(),
  quantity: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rawPrice: z.string(),
  price: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  totalAmount: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  formOfPayment: z.lazy(() => FOPSchema),
  confirmationId: z.string().optional().nullable(),
  receivingWallet: z.string().optional().nullable(),
  status: z.lazy(() => TransactionStatusSchema).optional(),
  comment: z.string().optional().nullable(),
  amountPaid: z.string(),
  amountPaidCurrency: z.lazy(() => CurrencySchema),
  txHash: z.string().optional().nullable(),
  agreementId: z.string().optional().nullable(),
  rejectionReason: z.string().optional().nullable(),
  paymentEvidence: z.string().optional().nullable(),
  paymentDate: z.coerce.date().optional().nullable(),
  user: z.lazy(() => UserCreateNestedOneWithoutTransactionsInputSchema),
  sale: z.lazy(() => SaleCreateNestedOneWithoutTransactionsInputSchema),
  approver: z.lazy(() => UserCreateNestedOneWithoutTransactionApprovalsInputSchema).optional(),
  auditTrail: z.lazy(() => TransactionAuditCreateNestedManyWithoutTransactionInputSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionCreateNestedManyWithoutTransactionInputSchema).optional()
}).strict();

export const SaleTransactionsUncheckedCreateWithoutBlockchainInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedCreateWithoutBlockchainInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  tokenSymbol: z.string(),
  quantity: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rawPrice: z.string(),
  price: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  totalAmount: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  formOfPayment: z.lazy(() => FOPSchema),
  confirmationId: z.string().optional().nullable(),
  receivingWallet: z.string().optional().nullable(),
  status: z.lazy(() => TransactionStatusSchema).optional(),
  userId: z.string(),
  saleId: z.string(),
  comment: z.string().optional().nullable(),
  amountPaid: z.string(),
  amountPaidCurrency: z.lazy(() => CurrencySchema),
  txHash: z.string().optional().nullable(),
  agreementId: z.string().optional().nullable(),
  approvedBy: z.string().optional().nullable(),
  rejectionReason: z.string().optional().nullable(),
  paymentEvidence: z.string().optional().nullable(),
  paymentDate: z.coerce.date().optional().nullable(),
  auditTrail: z.lazy(() => TransactionAuditUncheckedCreateNestedManyWithoutTransactionInputSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionUncheckedCreateNestedManyWithoutTransactionInputSchema).optional()
}).strict();

export const SaleTransactionsCreateOrConnectWithoutBlockchainInputSchema: z.ZodType<Prisma.SaleTransactionsCreateOrConnectWithoutBlockchainInput> = z.object({
  where: z.lazy(() => SaleTransactionsWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutBlockchainInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutBlockchainInputSchema) ]),
}).strict();

export const SaleTransactionsCreateManyBlockchainInputEnvelopeSchema: z.ZodType<Prisma.SaleTransactionsCreateManyBlockchainInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => SaleTransactionsCreateManyBlockchainInputSchema),z.lazy(() => SaleTransactionsCreateManyBlockchainInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const TokensOnBlockchainsCreateWithoutBlockchainInputSchema: z.ZodType<Prisma.TokensOnBlockchainsCreateWithoutBlockchainInput> = z.object({
  id: z.string().cuid().optional(),
  tokenSymbol: z.string(),
  name: z.string(),
  isNative: z.boolean().optional(),
  decimals: z.number().int(),
  contractAddress: z.string().optional().nullable(),
  token: z.lazy(() => TokenCreateNestedOneWithoutTokensOnBlockchainsInputSchema)
}).strict();

export const TokensOnBlockchainsUncheckedCreateWithoutBlockchainInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUncheckedCreateWithoutBlockchainInput> = z.object({
  id: z.string().cuid().optional(),
  tokenId: z.string(),
  tokenSymbol: z.string(),
  name: z.string(),
  isNative: z.boolean().optional(),
  decimals: z.number().int(),
  contractAddress: z.string().optional().nullable()
}).strict();

export const TokensOnBlockchainsCreateOrConnectWithoutBlockchainInputSchema: z.ZodType<Prisma.TokensOnBlockchainsCreateOrConnectWithoutBlockchainInput> = z.object({
  where: z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => TokensOnBlockchainsCreateWithoutBlockchainInputSchema),z.lazy(() => TokensOnBlockchainsUncheckedCreateWithoutBlockchainInputSchema) ]),
}).strict();

export const TokensOnBlockchainsCreateManyBlockchainInputEnvelopeSchema: z.ZodType<Prisma.TokensOnBlockchainsCreateManyBlockchainInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => TokensOnBlockchainsCreateManyBlockchainInputSchema),z.lazy(() => TokensOnBlockchainsCreateManyBlockchainInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const SaleCreateWithoutBlockchainInputSchema: z.ZodType<Prisma.SaleCreateWithoutBlockchainInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  status: z.lazy(() => SaleStatusSchema).optional(),
  saleCurrency: z.lazy(() => CurrencySchema).optional(),
  initialTokenQuantity: z.number().int(),
  availableTokenQuantity: z.number().int(),
  maximumTokenBuyPerUser: z.number().int().optional().nullable(),
  minimumTokenBuyPerUser: z.number().int().optional(),
  saleStartDate: z.coerce.date(),
  tokenContractAddress: z.string().optional().nullable(),
  tokenName: z.string(),
  tokenTotalSupply: z.string().optional().nullable(),
  tokenPricePerUnit: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  tokenSymbol: z.string(),
  toWalletsAddress: z.string(),
  saleClosingDate: z.coerce.date(),
  saftCheckbox: z.boolean().optional(),
  saftContract: z.string().optional().nullable(),
  user: z.lazy(() => UserCreateNestedOneWithoutSalesInputSchema),
  transactions: z.lazy(() => SaleTransactionsCreateNestedManyWithoutSaleInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationCreateNestedOneWithoutSaleInputSchema).optional(),
  documents: z.lazy(() => DocumentCreateNestedManyWithoutSaleInputSchema).optional(),
  token: z.lazy(() => TokenCreateNestedOneWithoutSalesInputSchema),
  vestingSchedules: z.lazy(() => VestingScheduleCreateNestedManyWithoutSaleInputSchema).optional()
}).strict();

export const SaleUncheckedCreateWithoutBlockchainInputSchema: z.ZodType<Prisma.SaleUncheckedCreateWithoutBlockchainInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  status: z.lazy(() => SaleStatusSchema).optional(),
  saleCurrency: z.lazy(() => CurrencySchema).optional(),
  initialTokenQuantity: z.number().int(),
  availableTokenQuantity: z.number().int(),
  maximumTokenBuyPerUser: z.number().int().optional().nullable(),
  minimumTokenBuyPerUser: z.number().int().optional(),
  saleStartDate: z.coerce.date(),
  tokenContractAddress: z.string().optional().nullable(),
  tokenName: z.string(),
  tokenTotalSupply: z.string().optional().nullable(),
  tokenPricePerUnit: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  tokenSymbol: z.string(),
  toWalletsAddress: z.string(),
  saleClosingDate: z.coerce.date(),
  createdBy: z.string(),
  saftCheckbox: z.boolean().optional(),
  saftContract: z.string().optional().nullable(),
  tokenId: z.string(),
  transactions: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutSaleInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationUncheckedCreateNestedOneWithoutSaleInputSchema).optional(),
  documents: z.lazy(() => DocumentUncheckedCreateNestedManyWithoutSaleInputSchema).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleUncheckedCreateNestedManyWithoutSaleInputSchema).optional()
}).strict();

export const SaleCreateOrConnectWithoutBlockchainInputSchema: z.ZodType<Prisma.SaleCreateOrConnectWithoutBlockchainInput> = z.object({
  where: z.lazy(() => SaleWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => SaleCreateWithoutBlockchainInputSchema),z.lazy(() => SaleUncheckedCreateWithoutBlockchainInputSchema) ]),
}).strict();

export const SaleCreateManyBlockchainInputEnvelopeSchema: z.ZodType<Prisma.SaleCreateManyBlockchainInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => SaleCreateManyBlockchainInputSchema),z.lazy(() => SaleCreateManyBlockchainInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const SaleTransactionsUpsertWithWhereUniqueWithoutBlockchainInputSchema: z.ZodType<Prisma.SaleTransactionsUpsertWithWhereUniqueWithoutBlockchainInput> = z.object({
  where: z.lazy(() => SaleTransactionsWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => SaleTransactionsUpdateWithoutBlockchainInputSchema),z.lazy(() => SaleTransactionsUncheckedUpdateWithoutBlockchainInputSchema) ]),
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutBlockchainInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutBlockchainInputSchema) ]),
}).strict();

export const SaleTransactionsUpdateWithWhereUniqueWithoutBlockchainInputSchema: z.ZodType<Prisma.SaleTransactionsUpdateWithWhereUniqueWithoutBlockchainInput> = z.object({
  where: z.lazy(() => SaleTransactionsWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => SaleTransactionsUpdateWithoutBlockchainInputSchema),z.lazy(() => SaleTransactionsUncheckedUpdateWithoutBlockchainInputSchema) ]),
}).strict();

export const SaleTransactionsUpdateManyWithWhereWithoutBlockchainInputSchema: z.ZodType<Prisma.SaleTransactionsUpdateManyWithWhereWithoutBlockchainInput> = z.object({
  where: z.lazy(() => SaleTransactionsScalarWhereInputSchema),
  data: z.union([ z.lazy(() => SaleTransactionsUpdateManyMutationInputSchema),z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutBlockchainInputSchema) ]),
}).strict();

export const TokensOnBlockchainsUpsertWithWhereUniqueWithoutBlockchainInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUpsertWithWhereUniqueWithoutBlockchainInput> = z.object({
  where: z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => TokensOnBlockchainsUpdateWithoutBlockchainInputSchema),z.lazy(() => TokensOnBlockchainsUncheckedUpdateWithoutBlockchainInputSchema) ]),
  create: z.union([ z.lazy(() => TokensOnBlockchainsCreateWithoutBlockchainInputSchema),z.lazy(() => TokensOnBlockchainsUncheckedCreateWithoutBlockchainInputSchema) ]),
}).strict();

export const TokensOnBlockchainsUpdateWithWhereUniqueWithoutBlockchainInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUpdateWithWhereUniqueWithoutBlockchainInput> = z.object({
  where: z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => TokensOnBlockchainsUpdateWithoutBlockchainInputSchema),z.lazy(() => TokensOnBlockchainsUncheckedUpdateWithoutBlockchainInputSchema) ]),
}).strict();

export const TokensOnBlockchainsUpdateManyWithWhereWithoutBlockchainInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUpdateManyWithWhereWithoutBlockchainInput> = z.object({
  where: z.lazy(() => TokensOnBlockchainsScalarWhereInputSchema),
  data: z.union([ z.lazy(() => TokensOnBlockchainsUpdateManyMutationInputSchema),z.lazy(() => TokensOnBlockchainsUncheckedUpdateManyWithoutBlockchainInputSchema) ]),
}).strict();

export const TokensOnBlockchainsScalarWhereInputSchema: z.ZodType<Prisma.TokensOnBlockchainsScalarWhereInput> = z.object({
  AND: z.union([ z.lazy(() => TokensOnBlockchainsScalarWhereInputSchema),z.lazy(() => TokensOnBlockchainsScalarWhereInputSchema).array() ]).optional(),
  OR: z.lazy(() => TokensOnBlockchainsScalarWhereInputSchema).array().optional(),
  NOT: z.union([ z.lazy(() => TokensOnBlockchainsScalarWhereInputSchema),z.lazy(() => TokensOnBlockchainsScalarWhereInputSchema).array() ]).optional(),
  id: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  tokenId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  tokenSymbol: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  blockchainId: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  name: z.union([ z.lazy(() => StringFilterSchema),z.string() ]).optional(),
  isNative: z.union([ z.lazy(() => BoolFilterSchema),z.boolean() ]).optional(),
  decimals: z.union([ z.lazy(() => IntFilterSchema),z.number() ]).optional(),
  contractAddress: z.union([ z.lazy(() => StringNullableFilterSchema),z.string() ]).optional().nullable(),
}).strict();

export const SaleUpsertWithWhereUniqueWithoutBlockchainInputSchema: z.ZodType<Prisma.SaleUpsertWithWhereUniqueWithoutBlockchainInput> = z.object({
  where: z.lazy(() => SaleWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => SaleUpdateWithoutBlockchainInputSchema),z.lazy(() => SaleUncheckedUpdateWithoutBlockchainInputSchema) ]),
  create: z.union([ z.lazy(() => SaleCreateWithoutBlockchainInputSchema),z.lazy(() => SaleUncheckedCreateWithoutBlockchainInputSchema) ]),
}).strict();

export const SaleUpdateWithWhereUniqueWithoutBlockchainInputSchema: z.ZodType<Prisma.SaleUpdateWithWhereUniqueWithoutBlockchainInput> = z.object({
  where: z.lazy(() => SaleWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => SaleUpdateWithoutBlockchainInputSchema),z.lazy(() => SaleUncheckedUpdateWithoutBlockchainInputSchema) ]),
}).strict();

export const SaleUpdateManyWithWhereWithoutBlockchainInputSchema: z.ZodType<Prisma.SaleUpdateManyWithWhereWithoutBlockchainInput> = z.object({
  where: z.lazy(() => SaleScalarWhereInputSchema),
  data: z.union([ z.lazy(() => SaleUpdateManyMutationInputSchema),z.lazy(() => SaleUncheckedUpdateManyWithoutBlockchainInputSchema) ]),
}).strict();

export const SaleTransactionsCreateWithoutAuditTrailInputSchema: z.ZodType<Prisma.SaleTransactionsCreateWithoutAuditTrailInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  tokenSymbol: z.string(),
  quantity: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rawPrice: z.string(),
  price: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  totalAmount: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  formOfPayment: z.lazy(() => FOPSchema),
  confirmationId: z.string().optional().nullable(),
  receivingWallet: z.string().optional().nullable(),
  status: z.lazy(() => TransactionStatusSchema).optional(),
  comment: z.string().optional().nullable(),
  amountPaid: z.string(),
  amountPaidCurrency: z.lazy(() => CurrencySchema),
  txHash: z.string().optional().nullable(),
  agreementId: z.string().optional().nullable(),
  rejectionReason: z.string().optional().nullable(),
  paymentEvidence: z.string().optional().nullable(),
  paymentDate: z.coerce.date().optional().nullable(),
  user: z.lazy(() => UserCreateNestedOneWithoutTransactionsInputSchema),
  sale: z.lazy(() => SaleCreateNestedOneWithoutTransactionsInputSchema),
  blockchain: z.lazy(() => BlockchainCreateNestedOneWithoutTransactionsInputSchema).optional(),
  approver: z.lazy(() => UserCreateNestedOneWithoutTransactionApprovalsInputSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionCreateNestedManyWithoutTransactionInputSchema).optional()
}).strict();

export const SaleTransactionsUncheckedCreateWithoutAuditTrailInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedCreateWithoutAuditTrailInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  tokenSymbol: z.string(),
  quantity: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rawPrice: z.string(),
  price: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  totalAmount: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  formOfPayment: z.lazy(() => FOPSchema),
  confirmationId: z.string().optional().nullable(),
  receivingWallet: z.string().optional().nullable(),
  status: z.lazy(() => TransactionStatusSchema).optional(),
  userId: z.string(),
  saleId: z.string(),
  comment: z.string().optional().nullable(),
  amountPaid: z.string(),
  amountPaidCurrency: z.lazy(() => CurrencySchema),
  txHash: z.string().optional().nullable(),
  blockchainId: z.string().optional().nullable(),
  agreementId: z.string().optional().nullable(),
  approvedBy: z.string().optional().nullable(),
  rejectionReason: z.string().optional().nullable(),
  paymentEvidence: z.string().optional().nullable(),
  paymentDate: z.coerce.date().optional().nullable(),
  tokenDistributions: z.lazy(() => TokenDistributionUncheckedCreateNestedManyWithoutTransactionInputSchema).optional()
}).strict();

export const SaleTransactionsCreateOrConnectWithoutAuditTrailInputSchema: z.ZodType<Prisma.SaleTransactionsCreateOrConnectWithoutAuditTrailInput> = z.object({
  where: z.lazy(() => SaleTransactionsWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutAuditTrailInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutAuditTrailInputSchema) ]),
}).strict();

export const UserCreateWithoutTransactionAuditInputSchema: z.ZodType<Prisma.UserCreateWithoutTransactionAuditInput> = z.object({
  id: z.string().cuid().optional(),
  externalId: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  walletAddress: z.string(),
  email: z.string(),
  emailVerified: z.boolean().optional(),
  image: z.string().optional().nullable(),
  isSiwe: z.boolean().optional().nullable(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutUserInputSchema).optional(),
  sales: z.lazy(() => SaleCreateNestedManyWithoutUserInputSchema).optional(),
  userRole: z.lazy(() => UserRoleCreateNestedManyWithoutUserInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationCreateNestedOneWithoutUserInputSchema).optional(),
  sessions: z.lazy(() => SessionCreateNestedManyWithoutUserInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsCreateNestedManyWithoutUserInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsCreateNestedManyWithoutApproverInputSchema).optional(),
  Document: z.lazy(() => DocumentCreateNestedManyWithoutUserInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressCreateNestedManyWithoutAddressInputSchema).optional()
}).strict();

export const UserUncheckedCreateWithoutTransactionAuditInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutTransactionAuditInput> = z.object({
  id: z.string().cuid().optional(),
  externalId: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  walletAddress: z.string(),
  email: z.string(),
  emailVerified: z.boolean().optional(),
  image: z.string().optional().nullable(),
  isSiwe: z.boolean().optional().nullable(),
  profile: z.lazy(() => ProfileUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  sales: z.lazy(() => SaleUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  sessions: z.lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutApproverInputSchema).optional(),
  Document: z.lazy(() => DocumentUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUncheckedCreateNestedManyWithoutAddressInputSchema).optional()
}).strict();

export const UserCreateOrConnectWithoutTransactionAuditInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutTransactionAuditInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserCreateWithoutTransactionAuditInputSchema),z.lazy(() => UserUncheckedCreateWithoutTransactionAuditInputSchema) ]),
}).strict();

export const SaleTransactionsUpsertWithoutAuditTrailInputSchema: z.ZodType<Prisma.SaleTransactionsUpsertWithoutAuditTrailInput> = z.object({
  update: z.union([ z.lazy(() => SaleTransactionsUpdateWithoutAuditTrailInputSchema),z.lazy(() => SaleTransactionsUncheckedUpdateWithoutAuditTrailInputSchema) ]),
  create: z.union([ z.lazy(() => SaleTransactionsCreateWithoutAuditTrailInputSchema),z.lazy(() => SaleTransactionsUncheckedCreateWithoutAuditTrailInputSchema) ]),
  where: z.lazy(() => SaleTransactionsWhereInputSchema).optional()
}).strict();

export const SaleTransactionsUpdateToOneWithWhereWithoutAuditTrailInputSchema: z.ZodType<Prisma.SaleTransactionsUpdateToOneWithWhereWithoutAuditTrailInput> = z.object({
  where: z.lazy(() => SaleTransactionsWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => SaleTransactionsUpdateWithoutAuditTrailInputSchema),z.lazy(() => SaleTransactionsUncheckedUpdateWithoutAuditTrailInputSchema) ]),
}).strict();

export const SaleTransactionsUpdateWithoutAuditTrailInputSchema: z.ZodType<Prisma.SaleTransactionsUpdateWithoutAuditTrailInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  quantity: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rawPrice: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  price: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  totalAmount: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  formOfPayment: z.union([ z.lazy(() => FOPSchema),z.lazy(() => EnumFOPFieldUpdateOperationsInputSchema) ]).optional(),
  confirmationId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  receivingWallet: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amountPaid: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  amountPaidCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  agreementId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentEvidence: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentDate: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutTransactionsNestedInputSchema).optional(),
  sale: z.lazy(() => SaleUpdateOneRequiredWithoutTransactionsNestedInputSchema).optional(),
  blockchain: z.lazy(() => BlockchainUpdateOneWithoutTransactionsNestedInputSchema).optional(),
  approver: z.lazy(() => UserUpdateOneWithoutTransactionApprovalsNestedInputSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionUpdateManyWithoutTransactionNestedInputSchema).optional()
}).strict();

export const SaleTransactionsUncheckedUpdateWithoutAuditTrailInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedUpdateWithoutAuditTrailInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  quantity: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rawPrice: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  price: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  totalAmount: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  formOfPayment: z.union([ z.lazy(() => FOPSchema),z.lazy(() => EnumFOPFieldUpdateOperationsInputSchema) ]).optional(),
  confirmationId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  receivingWallet: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amountPaid: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  amountPaidCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  blockchainId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  agreementId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  approvedBy: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentEvidence: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentDate: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenDistributions: z.lazy(() => TokenDistributionUncheckedUpdateManyWithoutTransactionNestedInputSchema).optional()
}).strict();

export const UserUpsertWithoutTransactionAuditInputSchema: z.ZodType<Prisma.UserUpsertWithoutTransactionAuditInput> = z.object({
  update: z.union([ z.lazy(() => UserUpdateWithoutTransactionAuditInputSchema),z.lazy(() => UserUncheckedUpdateWithoutTransactionAuditInputSchema) ]),
  create: z.union([ z.lazy(() => UserCreateWithoutTransactionAuditInputSchema),z.lazy(() => UserUncheckedCreateWithoutTransactionAuditInputSchema) ]),
  where: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const UserUpdateToOneWithWhereWithoutTransactionAuditInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutTransactionAuditInput> = z.object({
  where: z.lazy(() => UserWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => UserUpdateWithoutTransactionAuditInputSchema),z.lazy(() => UserUncheckedUpdateWithoutTransactionAuditInputSchema) ]),
}).strict();

export const UserUpdateWithoutTransactionAuditInputSchema: z.ZodType<Prisma.UserUpdateWithoutTransactionAuditInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  externalId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailVerified: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isSiwe: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profile: z.lazy(() => ProfileUpdateOneWithoutUserNestedInputSchema).optional(),
  sales: z.lazy(() => SaleUpdateManyWithoutUserNestedInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUpdateManyWithoutUserNestedInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUpdateOneWithoutUserNestedInputSchema).optional(),
  sessions: z.lazy(() => SessionUpdateManyWithoutUserNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUpdateManyWithoutApproverNestedInputSchema).optional(),
  Document: z.lazy(() => DocumentUpdateManyWithoutUserNestedInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUpdateManyWithoutAddressNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateWithoutTransactionAuditInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutTransactionAuditInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  externalId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailVerified: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isSiwe: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profile: z.lazy(() => ProfileUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  sales: z.lazy(() => SaleUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  sessions: z.lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutApproverNestedInputSchema).optional(),
  Document: z.lazy(() => DocumentUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUncheckedUpdateManyWithoutAddressNestedInputSchema).optional()
}).strict();

export const UserCreateWithoutKycVerificationInputSchema: z.ZodType<Prisma.UserCreateWithoutKycVerificationInput> = z.object({
  id: z.string().cuid().optional(),
  externalId: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  walletAddress: z.string(),
  email: z.string(),
  emailVerified: z.boolean().optional(),
  image: z.string().optional().nullable(),
  isSiwe: z.boolean().optional().nullable(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutUserInputSchema).optional(),
  sales: z.lazy(() => SaleCreateNestedManyWithoutUserInputSchema).optional(),
  userRole: z.lazy(() => UserRoleCreateNestedManyWithoutUserInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditCreateNestedManyWithoutAdminInputSchema).optional(),
  sessions: z.lazy(() => SessionCreateNestedManyWithoutUserInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsCreateNestedManyWithoutUserInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsCreateNestedManyWithoutApproverInputSchema).optional(),
  Document: z.lazy(() => DocumentCreateNestedManyWithoutUserInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressCreateNestedManyWithoutAddressInputSchema).optional()
}).strict();

export const UserUncheckedCreateWithoutKycVerificationInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutKycVerificationInput> = z.object({
  id: z.string().cuid().optional(),
  externalId: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  walletAddress: z.string(),
  email: z.string(),
  emailVerified: z.boolean().optional(),
  image: z.string().optional().nullable(),
  isSiwe: z.boolean().optional().nullable(),
  profile: z.lazy(() => ProfileUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  sales: z.lazy(() => SaleUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUncheckedCreateNestedManyWithoutAdminInputSchema).optional(),
  sessions: z.lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutApproverInputSchema).optional(),
  Document: z.lazy(() => DocumentUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUncheckedCreateNestedManyWithoutAddressInputSchema).optional()
}).strict();

export const UserCreateOrConnectWithoutKycVerificationInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutKycVerificationInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserCreateWithoutKycVerificationInputSchema),z.lazy(() => UserUncheckedCreateWithoutKycVerificationInputSchema) ]),
}).strict();

export const UserUpsertWithoutKycVerificationInputSchema: z.ZodType<Prisma.UserUpsertWithoutKycVerificationInput> = z.object({
  update: z.union([ z.lazy(() => UserUpdateWithoutKycVerificationInputSchema),z.lazy(() => UserUncheckedUpdateWithoutKycVerificationInputSchema) ]),
  create: z.union([ z.lazy(() => UserCreateWithoutKycVerificationInputSchema),z.lazy(() => UserUncheckedCreateWithoutKycVerificationInputSchema) ]),
  where: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const UserUpdateToOneWithWhereWithoutKycVerificationInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutKycVerificationInput> = z.object({
  where: z.lazy(() => UserWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => UserUpdateWithoutKycVerificationInputSchema),z.lazy(() => UserUncheckedUpdateWithoutKycVerificationInputSchema) ]),
}).strict();

export const UserUpdateWithoutKycVerificationInputSchema: z.ZodType<Prisma.UserUpdateWithoutKycVerificationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  externalId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailVerified: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isSiwe: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profile: z.lazy(() => ProfileUpdateOneWithoutUserNestedInputSchema).optional(),
  sales: z.lazy(() => SaleUpdateManyWithoutUserNestedInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUpdateManyWithoutAdminNestedInputSchema).optional(),
  sessions: z.lazy(() => SessionUpdateManyWithoutUserNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUpdateManyWithoutApproverNestedInputSchema).optional(),
  Document: z.lazy(() => DocumentUpdateManyWithoutUserNestedInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUpdateManyWithoutAddressNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateWithoutKycVerificationInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutKycVerificationInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  externalId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailVerified: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isSiwe: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profile: z.lazy(() => ProfileUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  sales: z.lazy(() => SaleUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  userRole: z.lazy(() => UserRoleUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUncheckedUpdateManyWithoutAdminNestedInputSchema).optional(),
  sessions: z.lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutApproverNestedInputSchema).optional(),
  Document: z.lazy(() => DocumentUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUncheckedUpdateManyWithoutAddressNestedInputSchema).optional()
}).strict();

export const UserRoleCreateWithoutRoleInputSchema: z.ZodType<Prisma.UserRoleCreateWithoutRoleInput> = z.object({
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  user: z.lazy(() => UserCreateNestedOneWithoutUserRoleInputSchema)
}).strict();

export const UserRoleUncheckedCreateWithoutRoleInputSchema: z.ZodType<Prisma.UserRoleUncheckedCreateWithoutRoleInput> = z.object({
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  userId: z.string()
}).strict();

export const UserRoleCreateOrConnectWithoutRoleInputSchema: z.ZodType<Prisma.UserRoleCreateOrConnectWithoutRoleInput> = z.object({
  where: z.lazy(() => UserRoleWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserRoleCreateWithoutRoleInputSchema),z.lazy(() => UserRoleUncheckedCreateWithoutRoleInputSchema) ]),
}).strict();

export const UserRoleCreateManyRoleInputEnvelopeSchema: z.ZodType<Prisma.UserRoleCreateManyRoleInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => UserRoleCreateManyRoleInputSchema),z.lazy(() => UserRoleCreateManyRoleInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const UserRoleUpsertWithWhereUniqueWithoutRoleInputSchema: z.ZodType<Prisma.UserRoleUpsertWithWhereUniqueWithoutRoleInput> = z.object({
  where: z.lazy(() => UserRoleWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => UserRoleUpdateWithoutRoleInputSchema),z.lazy(() => UserRoleUncheckedUpdateWithoutRoleInputSchema) ]),
  create: z.union([ z.lazy(() => UserRoleCreateWithoutRoleInputSchema),z.lazy(() => UserRoleUncheckedCreateWithoutRoleInputSchema) ]),
}).strict();

export const UserRoleUpdateWithWhereUniqueWithoutRoleInputSchema: z.ZodType<Prisma.UserRoleUpdateWithWhereUniqueWithoutRoleInput> = z.object({
  where: z.lazy(() => UserRoleWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => UserRoleUpdateWithoutRoleInputSchema),z.lazy(() => UserRoleUncheckedUpdateWithoutRoleInputSchema) ]),
}).strict();

export const UserRoleUpdateManyWithWhereWithoutRoleInputSchema: z.ZodType<Prisma.UserRoleUpdateManyWithWhereWithoutRoleInput> = z.object({
  where: z.lazy(() => UserRoleScalarWhereInputSchema),
  data: z.union([ z.lazy(() => UserRoleUpdateManyMutationInputSchema),z.lazy(() => UserRoleUncheckedUpdateManyWithoutRoleInputSchema) ]),
}).strict();

export const UserCreateWithoutUserRoleInputSchema: z.ZodType<Prisma.UserCreateWithoutUserRoleInput> = z.object({
  id: z.string().cuid().optional(),
  externalId: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  walletAddress: z.string(),
  email: z.string(),
  emailVerified: z.boolean().optional(),
  image: z.string().optional().nullable(),
  isSiwe: z.boolean().optional().nullable(),
  profile: z.lazy(() => ProfileCreateNestedOneWithoutUserInputSchema).optional(),
  sales: z.lazy(() => SaleCreateNestedManyWithoutUserInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditCreateNestedManyWithoutAdminInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationCreateNestedOneWithoutUserInputSchema).optional(),
  sessions: z.lazy(() => SessionCreateNestedManyWithoutUserInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsCreateNestedManyWithoutUserInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsCreateNestedManyWithoutApproverInputSchema).optional(),
  Document: z.lazy(() => DocumentCreateNestedManyWithoutUserInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressCreateNestedManyWithoutAddressInputSchema).optional()
}).strict();

export const UserUncheckedCreateWithoutUserRoleInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutUserRoleInput> = z.object({
  id: z.string().cuid().optional(),
  externalId: z.string().optional().nullable(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  walletAddress: z.string(),
  email: z.string(),
  emailVerified: z.boolean().optional(),
  image: z.string().optional().nullable(),
  isSiwe: z.boolean().optional().nullable(),
  profile: z.lazy(() => ProfileUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  sales: z.lazy(() => SaleUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUncheckedCreateNestedManyWithoutAdminInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUncheckedCreateNestedOneWithoutUserInputSchema).optional(),
  sessions: z.lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutApproverInputSchema).optional(),
  Document: z.lazy(() => DocumentUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUncheckedCreateNestedManyWithoutAddressInputSchema).optional()
}).strict();

export const UserCreateOrConnectWithoutUserRoleInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutUserRoleInput> = z.object({
  where: z.lazy(() => UserWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => UserCreateWithoutUserRoleInputSchema),z.lazy(() => UserUncheckedCreateWithoutUserRoleInputSchema) ]),
}).strict();

export const RoleCreateWithoutUsersInputSchema: z.ZodType<Prisma.RoleCreateWithoutUsersInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  description: z.string().optional().nullable()
}).strict();

export const RoleUncheckedCreateWithoutUsersInputSchema: z.ZodType<Prisma.RoleUncheckedCreateWithoutUsersInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  description: z.string().optional().nullable()
}).strict();

export const RoleCreateOrConnectWithoutUsersInputSchema: z.ZodType<Prisma.RoleCreateOrConnectWithoutUsersInput> = z.object({
  where: z.lazy(() => RoleWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => RoleCreateWithoutUsersInputSchema),z.lazy(() => RoleUncheckedCreateWithoutUsersInputSchema) ]),
}).strict();

export const UserUpsertWithoutUserRoleInputSchema: z.ZodType<Prisma.UserUpsertWithoutUserRoleInput> = z.object({
  update: z.union([ z.lazy(() => UserUpdateWithoutUserRoleInputSchema),z.lazy(() => UserUncheckedUpdateWithoutUserRoleInputSchema) ]),
  create: z.union([ z.lazy(() => UserCreateWithoutUserRoleInputSchema),z.lazy(() => UserUncheckedCreateWithoutUserRoleInputSchema) ]),
  where: z.lazy(() => UserWhereInputSchema).optional()
}).strict();

export const UserUpdateToOneWithWhereWithoutUserRoleInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutUserRoleInput> = z.object({
  where: z.lazy(() => UserWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => UserUpdateWithoutUserRoleInputSchema),z.lazy(() => UserUncheckedUpdateWithoutUserRoleInputSchema) ]),
}).strict();

export const UserUpdateWithoutUserRoleInputSchema: z.ZodType<Prisma.UserUpdateWithoutUserRoleInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  externalId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailVerified: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isSiwe: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profile: z.lazy(() => ProfileUpdateOneWithoutUserNestedInputSchema).optional(),
  sales: z.lazy(() => SaleUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUpdateManyWithoutAdminNestedInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUpdateOneWithoutUserNestedInputSchema).optional(),
  sessions: z.lazy(() => SessionUpdateManyWithoutUserNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUpdateManyWithoutApproverNestedInputSchema).optional(),
  Document: z.lazy(() => DocumentUpdateManyWithoutUserNestedInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUpdateManyWithoutAddressNestedInputSchema).optional()
}).strict();

export const UserUncheckedUpdateWithoutUserRoleInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutUserRoleInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  externalId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  walletAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  email: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  emailVerified: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isSiwe: z.union([ z.boolean(),z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  profile: z.lazy(() => ProfileUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  sales: z.lazy(() => SaleUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionAudit: z.lazy(() => TransactionAuditUncheckedUpdateManyWithoutAdminNestedInputSchema).optional(),
  kycVerification: z.lazy(() => KycVerificationUncheckedUpdateOneWithoutUserNestedInputSchema).optional(),
  sessions: z.lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  transactionApprovals: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutApproverNestedInputSchema).optional(),
  Document: z.lazy(() => DocumentUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
  WalletAddress: z.lazy(() => WalletAddressUncheckedUpdateManyWithoutAddressNestedInputSchema).optional()
}).strict();

export const RoleUpsertWithoutUsersInputSchema: z.ZodType<Prisma.RoleUpsertWithoutUsersInput> = z.object({
  update: z.union([ z.lazy(() => RoleUpdateWithoutUsersInputSchema),z.lazy(() => RoleUncheckedUpdateWithoutUsersInputSchema) ]),
  create: z.union([ z.lazy(() => RoleCreateWithoutUsersInputSchema),z.lazy(() => RoleUncheckedCreateWithoutUsersInputSchema) ]),
  where: z.lazy(() => RoleWhereInputSchema).optional()
}).strict();

export const RoleUpdateToOneWithWhereWithoutUsersInputSchema: z.ZodType<Prisma.RoleUpdateToOneWithWhereWithoutUsersInput> = z.object({
  where: z.lazy(() => RoleWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => RoleUpdateWithoutUsersInputSchema),z.lazy(() => RoleUncheckedUpdateWithoutUsersInputSchema) ]),
}).strict();

export const RoleUpdateWithoutUsersInputSchema: z.ZodType<Prisma.RoleUpdateWithoutUsersInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  description: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const RoleUncheckedUpdateWithoutUsersInputSchema: z.ZodType<Prisma.RoleUncheckedUpdateWithoutUsersInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  description: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const SaleCreateWithoutTokenInputSchema: z.ZodType<Prisma.SaleCreateWithoutTokenInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  status: z.lazy(() => SaleStatusSchema).optional(),
  saleCurrency: z.lazy(() => CurrencySchema).optional(),
  initialTokenQuantity: z.number().int(),
  availableTokenQuantity: z.number().int(),
  maximumTokenBuyPerUser: z.number().int().optional().nullable(),
  minimumTokenBuyPerUser: z.number().int().optional(),
  saleStartDate: z.coerce.date(),
  tokenContractAddress: z.string().optional().nullable(),
  tokenName: z.string(),
  tokenTotalSupply: z.string().optional().nullable(),
  tokenPricePerUnit: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  tokenSymbol: z.string(),
  toWalletsAddress: z.string(),
  saleClosingDate: z.coerce.date(),
  saftCheckbox: z.boolean().optional(),
  saftContract: z.string().optional().nullable(),
  blockchain: z.lazy(() => BlockchainCreateNestedOneWithoutSaleInputSchema).optional(),
  user: z.lazy(() => UserCreateNestedOneWithoutSalesInputSchema),
  transactions: z.lazy(() => SaleTransactionsCreateNestedManyWithoutSaleInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationCreateNestedOneWithoutSaleInputSchema).optional(),
  documents: z.lazy(() => DocumentCreateNestedManyWithoutSaleInputSchema).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleCreateNestedManyWithoutSaleInputSchema).optional()
}).strict();

export const SaleUncheckedCreateWithoutTokenInputSchema: z.ZodType<Prisma.SaleUncheckedCreateWithoutTokenInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  status: z.lazy(() => SaleStatusSchema).optional(),
  saleCurrency: z.lazy(() => CurrencySchema).optional(),
  initialTokenQuantity: z.number().int(),
  availableTokenQuantity: z.number().int(),
  maximumTokenBuyPerUser: z.number().int().optional().nullable(),
  minimumTokenBuyPerUser: z.number().int().optional(),
  saleStartDate: z.coerce.date(),
  tokenContractAddress: z.string().optional().nullable(),
  tokenContractChainId: z.number().int().optional().nullable(),
  tokenName: z.string(),
  tokenTotalSupply: z.string().optional().nullable(),
  tokenPricePerUnit: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  tokenSymbol: z.string(),
  toWalletsAddress: z.string(),
  saleClosingDate: z.coerce.date(),
  createdBy: z.string(),
  saftCheckbox: z.boolean().optional(),
  saftContract: z.string().optional().nullable(),
  transactions: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutSaleInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationUncheckedCreateNestedOneWithoutSaleInputSchema).optional(),
  documents: z.lazy(() => DocumentUncheckedCreateNestedManyWithoutSaleInputSchema).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleUncheckedCreateNestedManyWithoutSaleInputSchema).optional()
}).strict();

export const SaleCreateOrConnectWithoutTokenInputSchema: z.ZodType<Prisma.SaleCreateOrConnectWithoutTokenInput> = z.object({
  where: z.lazy(() => SaleWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => SaleCreateWithoutTokenInputSchema),z.lazy(() => SaleUncheckedCreateWithoutTokenInputSchema) ]),
}).strict();

export const SaleCreateManyTokenInputEnvelopeSchema: z.ZodType<Prisma.SaleCreateManyTokenInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => SaleCreateManyTokenInputSchema),z.lazy(() => SaleCreateManyTokenInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const TokensOnBlockchainsCreateWithoutTokenInputSchema: z.ZodType<Prisma.TokensOnBlockchainsCreateWithoutTokenInput> = z.object({
  id: z.string().cuid().optional(),
  tokenSymbol: z.string(),
  name: z.string(),
  isNative: z.boolean().optional(),
  decimals: z.number().int(),
  contractAddress: z.string().optional().nullable(),
  blockchain: z.lazy(() => BlockchainCreateNestedOneWithoutTokensOnBlockchainsInputSchema)
}).strict();

export const TokensOnBlockchainsUncheckedCreateWithoutTokenInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUncheckedCreateWithoutTokenInput> = z.object({
  id: z.string().cuid().optional(),
  tokenSymbol: z.string(),
  blockchainId: z.string(),
  name: z.string(),
  isNative: z.boolean().optional(),
  decimals: z.number().int(),
  contractAddress: z.string().optional().nullable()
}).strict();

export const TokensOnBlockchainsCreateOrConnectWithoutTokenInputSchema: z.ZodType<Prisma.TokensOnBlockchainsCreateOrConnectWithoutTokenInput> = z.object({
  where: z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => TokensOnBlockchainsCreateWithoutTokenInputSchema),z.lazy(() => TokensOnBlockchainsUncheckedCreateWithoutTokenInputSchema) ]),
}).strict();

export const TokensOnBlockchainsCreateManyTokenInputEnvelopeSchema: z.ZodType<Prisma.TokensOnBlockchainsCreateManyTokenInputEnvelope> = z.object({
  data: z.union([ z.lazy(() => TokensOnBlockchainsCreateManyTokenInputSchema),z.lazy(() => TokensOnBlockchainsCreateManyTokenInputSchema).array() ]),
  skipDuplicates: z.boolean().optional()
}).strict();

export const SaleUpsertWithWhereUniqueWithoutTokenInputSchema: z.ZodType<Prisma.SaleUpsertWithWhereUniqueWithoutTokenInput> = z.object({
  where: z.lazy(() => SaleWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => SaleUpdateWithoutTokenInputSchema),z.lazy(() => SaleUncheckedUpdateWithoutTokenInputSchema) ]),
  create: z.union([ z.lazy(() => SaleCreateWithoutTokenInputSchema),z.lazy(() => SaleUncheckedCreateWithoutTokenInputSchema) ]),
}).strict();

export const SaleUpdateWithWhereUniqueWithoutTokenInputSchema: z.ZodType<Prisma.SaleUpdateWithWhereUniqueWithoutTokenInput> = z.object({
  where: z.lazy(() => SaleWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => SaleUpdateWithoutTokenInputSchema),z.lazy(() => SaleUncheckedUpdateWithoutTokenInputSchema) ]),
}).strict();

export const SaleUpdateManyWithWhereWithoutTokenInputSchema: z.ZodType<Prisma.SaleUpdateManyWithWhereWithoutTokenInput> = z.object({
  where: z.lazy(() => SaleScalarWhereInputSchema),
  data: z.union([ z.lazy(() => SaleUpdateManyMutationInputSchema),z.lazy(() => SaleUncheckedUpdateManyWithoutTokenInputSchema) ]),
}).strict();

export const TokensOnBlockchainsUpsertWithWhereUniqueWithoutTokenInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUpsertWithWhereUniqueWithoutTokenInput> = z.object({
  where: z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),
  update: z.union([ z.lazy(() => TokensOnBlockchainsUpdateWithoutTokenInputSchema),z.lazy(() => TokensOnBlockchainsUncheckedUpdateWithoutTokenInputSchema) ]),
  create: z.union([ z.lazy(() => TokensOnBlockchainsCreateWithoutTokenInputSchema),z.lazy(() => TokensOnBlockchainsUncheckedCreateWithoutTokenInputSchema) ]),
}).strict();

export const TokensOnBlockchainsUpdateWithWhereUniqueWithoutTokenInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUpdateWithWhereUniqueWithoutTokenInput> = z.object({
  where: z.lazy(() => TokensOnBlockchainsWhereUniqueInputSchema),
  data: z.union([ z.lazy(() => TokensOnBlockchainsUpdateWithoutTokenInputSchema),z.lazy(() => TokensOnBlockchainsUncheckedUpdateWithoutTokenInputSchema) ]),
}).strict();

export const TokensOnBlockchainsUpdateManyWithWhereWithoutTokenInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUpdateManyWithWhereWithoutTokenInput> = z.object({
  where: z.lazy(() => TokensOnBlockchainsScalarWhereInputSchema),
  data: z.union([ z.lazy(() => TokensOnBlockchainsUpdateManyMutationInputSchema),z.lazy(() => TokensOnBlockchainsUncheckedUpdateManyWithoutTokenInputSchema) ]),
}).strict();

export const TokenCreateWithoutTokensOnBlockchainsInputSchema: z.ZodType<Prisma.TokenCreateWithoutTokensOnBlockchainsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  symbol: z.string(),
  totalSupply: z.string().optional().nullable(),
  image: z.string().optional().nullable(),
  sales: z.lazy(() => SaleCreateNestedManyWithoutTokenInputSchema).optional()
}).strict();

export const TokenUncheckedCreateWithoutTokensOnBlockchainsInputSchema: z.ZodType<Prisma.TokenUncheckedCreateWithoutTokensOnBlockchainsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  symbol: z.string(),
  totalSupply: z.string().optional().nullable(),
  image: z.string().optional().nullable(),
  sales: z.lazy(() => SaleUncheckedCreateNestedManyWithoutTokenInputSchema).optional()
}).strict();

export const TokenCreateOrConnectWithoutTokensOnBlockchainsInputSchema: z.ZodType<Prisma.TokenCreateOrConnectWithoutTokensOnBlockchainsInput> = z.object({
  where: z.lazy(() => TokenWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => TokenCreateWithoutTokensOnBlockchainsInputSchema),z.lazy(() => TokenUncheckedCreateWithoutTokensOnBlockchainsInputSchema) ]),
}).strict();

export const BlockchainCreateWithoutTokensOnBlockchainsInputSchema: z.ZodType<Prisma.BlockchainCreateWithoutTokensOnBlockchainsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  chainId: z.number().int(),
  rpcUrl: z.string(),
  explorerUrl: z.string().optional().nullable(),
  isTestnet: z.boolean().optional(),
  isEnabled: z.boolean().optional(),
  transactions: z.lazy(() => SaleTransactionsCreateNestedManyWithoutBlockchainInputSchema).optional(),
  Sale: z.lazy(() => SaleCreateNestedManyWithoutBlockchainInputSchema).optional()
}).strict();

export const BlockchainUncheckedCreateWithoutTokensOnBlockchainsInputSchema: z.ZodType<Prisma.BlockchainUncheckedCreateWithoutTokensOnBlockchainsInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  chainId: z.number().int(),
  rpcUrl: z.string(),
  explorerUrl: z.string().optional().nullable(),
  isTestnet: z.boolean().optional(),
  isEnabled: z.boolean().optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedCreateNestedManyWithoutBlockchainInputSchema).optional(),
  Sale: z.lazy(() => SaleUncheckedCreateNestedManyWithoutBlockchainInputSchema).optional()
}).strict();

export const BlockchainCreateOrConnectWithoutTokensOnBlockchainsInputSchema: z.ZodType<Prisma.BlockchainCreateOrConnectWithoutTokensOnBlockchainsInput> = z.object({
  where: z.lazy(() => BlockchainWhereUniqueInputSchema),
  create: z.union([ z.lazy(() => BlockchainCreateWithoutTokensOnBlockchainsInputSchema),z.lazy(() => BlockchainUncheckedCreateWithoutTokensOnBlockchainsInputSchema) ]),
}).strict();

export const TokenUpsertWithoutTokensOnBlockchainsInputSchema: z.ZodType<Prisma.TokenUpsertWithoutTokensOnBlockchainsInput> = z.object({
  update: z.union([ z.lazy(() => TokenUpdateWithoutTokensOnBlockchainsInputSchema),z.lazy(() => TokenUncheckedUpdateWithoutTokensOnBlockchainsInputSchema) ]),
  create: z.union([ z.lazy(() => TokenCreateWithoutTokensOnBlockchainsInputSchema),z.lazy(() => TokenUncheckedCreateWithoutTokensOnBlockchainsInputSchema) ]),
  where: z.lazy(() => TokenWhereInputSchema).optional()
}).strict();

export const TokenUpdateToOneWithWhereWithoutTokensOnBlockchainsInputSchema: z.ZodType<Prisma.TokenUpdateToOneWithWhereWithoutTokensOnBlockchainsInput> = z.object({
  where: z.lazy(() => TokenWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => TokenUpdateWithoutTokensOnBlockchainsInputSchema),z.lazy(() => TokenUncheckedUpdateWithoutTokensOnBlockchainsInputSchema) ]),
}).strict();

export const TokenUpdateWithoutTokensOnBlockchainsInputSchema: z.ZodType<Prisma.TokenUpdateWithoutTokensOnBlockchainsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  symbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  totalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sales: z.lazy(() => SaleUpdateManyWithoutTokenNestedInputSchema).optional()
}).strict();

export const TokenUncheckedUpdateWithoutTokensOnBlockchainsInputSchema: z.ZodType<Prisma.TokenUncheckedUpdateWithoutTokensOnBlockchainsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  symbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  totalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  image: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sales: z.lazy(() => SaleUncheckedUpdateManyWithoutTokenNestedInputSchema).optional()
}).strict();

export const BlockchainUpsertWithoutTokensOnBlockchainsInputSchema: z.ZodType<Prisma.BlockchainUpsertWithoutTokensOnBlockchainsInput> = z.object({
  update: z.union([ z.lazy(() => BlockchainUpdateWithoutTokensOnBlockchainsInputSchema),z.lazy(() => BlockchainUncheckedUpdateWithoutTokensOnBlockchainsInputSchema) ]),
  create: z.union([ z.lazy(() => BlockchainCreateWithoutTokensOnBlockchainsInputSchema),z.lazy(() => BlockchainUncheckedCreateWithoutTokensOnBlockchainsInputSchema) ]),
  where: z.lazy(() => BlockchainWhereInputSchema).optional()
}).strict();

export const BlockchainUpdateToOneWithWhereWithoutTokensOnBlockchainsInputSchema: z.ZodType<Prisma.BlockchainUpdateToOneWithWhereWithoutTokensOnBlockchainsInput> = z.object({
  where: z.lazy(() => BlockchainWhereInputSchema).optional(),
  data: z.union([ z.lazy(() => BlockchainUpdateWithoutTokensOnBlockchainsInputSchema),z.lazy(() => BlockchainUncheckedUpdateWithoutTokensOnBlockchainsInputSchema) ]),
}).strict();

export const BlockchainUpdateWithoutTokensOnBlockchainsInputSchema: z.ZodType<Prisma.BlockchainUpdateWithoutTokensOnBlockchainsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  chainId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  rpcUrl: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  explorerUrl: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isTestnet: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  isEnabled: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  transactions: z.lazy(() => SaleTransactionsUpdateManyWithoutBlockchainNestedInputSchema).optional(),
  Sale: z.lazy(() => SaleUpdateManyWithoutBlockchainNestedInputSchema).optional()
}).strict();

export const BlockchainUncheckedUpdateWithoutTokensOnBlockchainsInputSchema: z.ZodType<Prisma.BlockchainUncheckedUpdateWithoutTokensOnBlockchainsInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  chainId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  rpcUrl: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  explorerUrl: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  isTestnet: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  isEnabled: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutBlockchainNestedInputSchema).optional(),
  Sale: z.lazy(() => SaleUncheckedUpdateManyWithoutBlockchainNestedInputSchema).optional()
}).strict();

export const SaleCreateManyUserInputSchema: z.ZodType<Prisma.SaleCreateManyUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  status: z.lazy(() => SaleStatusSchema).optional(),
  saleCurrency: z.lazy(() => CurrencySchema).optional(),
  initialTokenQuantity: z.number().int(),
  availableTokenQuantity: z.number().int(),
  maximumTokenBuyPerUser: z.number().int().optional().nullable(),
  minimumTokenBuyPerUser: z.number().int().optional(),
  saleStartDate: z.coerce.date(),
  tokenContractAddress: z.string().optional().nullable(),
  tokenContractChainId: z.number().int().optional().nullable(),
  tokenName: z.string(),
  tokenTotalSupply: z.string().optional().nullable(),
  tokenPricePerUnit: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  tokenSymbol: z.string(),
  toWalletsAddress: z.string(),
  saleClosingDate: z.coerce.date(),
  saftCheckbox: z.boolean().optional(),
  saftContract: z.string().optional().nullable(),
  tokenId: z.string()
}).strict();

export const UserRoleCreateManyUserInputSchema: z.ZodType<Prisma.UserRoleCreateManyUserInput> = z.object({
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  roleId: z.string()
}).strict();

export const TransactionAuditCreateManyAdminInputSchema: z.ZodType<Prisma.TransactionAuditCreateManyAdminInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  transactionId: z.string(),
  actionType: z.string(),
  fromStatus: z.lazy(() => TransactionStatusSchema),
  toStatus: z.lazy(() => TransactionStatusSchema),
  comment: z.string().optional().nullable()
}).strict();

export const SessionCreateManyUserInputSchema: z.ZodType<Prisma.SessionCreateManyUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  expiresAt: z.coerce.date(),
  token: z.string(),
  ipAddress: z.string().optional().nullable(),
  userAgent: z.string().optional().nullable()
}).strict();

export const SaleTransactionsCreateManyUserInputSchema: z.ZodType<Prisma.SaleTransactionsCreateManyUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  tokenSymbol: z.string(),
  quantity: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rawPrice: z.string(),
  price: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  totalAmount: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  formOfPayment: z.lazy(() => FOPSchema),
  confirmationId: z.string().optional().nullable(),
  receivingWallet: z.string().optional().nullable(),
  status: z.lazy(() => TransactionStatusSchema).optional(),
  saleId: z.string(),
  comment: z.string().optional().nullable(),
  amountPaid: z.string(),
  amountPaidCurrency: z.lazy(() => CurrencySchema),
  txHash: z.string().optional().nullable(),
  blockchainId: z.string().optional().nullable(),
  agreementId: z.string().optional().nullable(),
  approvedBy: z.string().optional().nullable(),
  rejectionReason: z.string().optional().nullable(),
  paymentEvidence: z.string().optional().nullable(),
  paymentDate: z.coerce.date().optional().nullable()
}).strict();

export const SaleTransactionsCreateManyApproverInputSchema: z.ZodType<Prisma.SaleTransactionsCreateManyApproverInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  tokenSymbol: z.string(),
  quantity: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rawPrice: z.string(),
  price: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  totalAmount: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  formOfPayment: z.lazy(() => FOPSchema),
  confirmationId: z.string().optional().nullable(),
  receivingWallet: z.string().optional().nullable(),
  status: z.lazy(() => TransactionStatusSchema).optional(),
  userId: z.string(),
  saleId: z.string(),
  comment: z.string().optional().nullable(),
  amountPaid: z.string(),
  amountPaidCurrency: z.lazy(() => CurrencySchema),
  txHash: z.string().optional().nullable(),
  blockchainId: z.string().optional().nullable(),
  agreementId: z.string().optional().nullable(),
  rejectionReason: z.string().optional().nullable(),
  paymentEvidence: z.string().optional().nullable(),
  paymentDate: z.coerce.date().optional().nullable()
}).strict();

export const DocumentCreateManyUserInputSchema: z.ZodType<Prisma.DocumentCreateManyUserInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  fileName: z.string(),
  url: z.string(),
  type: z.string(),
  saleId: z.string().optional().nullable()
}).strict();

export const WalletAddressCreateManyAddressInputSchema: z.ZodType<Prisma.WalletAddressCreateManyAddressInput> = z.object({
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  chainId: z.number().int()
}).strict();

export const SaleUpdateWithoutUserInputSchema: z.ZodType<Prisma.SaleUpdateWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => EnumSaleStatusFieldUpdateOperationsInputSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  initialTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  availableTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  saleStartDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  tokenContractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenTotalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  toWalletsAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleClosingDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  saftCheckbox: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  saftContract: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  blockchain: z.lazy(() => BlockchainUpdateOneWithoutSaleNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUpdateManyWithoutSaleNestedInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationUpdateOneWithoutSaleNestedInputSchema).optional(),
  documents: z.lazy(() => DocumentUpdateManyWithoutSaleNestedInputSchema).optional(),
  token: z.lazy(() => TokenUpdateOneRequiredWithoutSalesNestedInputSchema).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleUpdateManyWithoutSaleNestedInputSchema).optional()
}).strict();

export const SaleUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.SaleUncheckedUpdateWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => EnumSaleStatusFieldUpdateOperationsInputSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  initialTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  availableTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  saleStartDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  tokenContractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenContractChainId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenTotalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  toWalletsAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleClosingDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  saftCheckbox: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  saftContract: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutSaleNestedInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationUncheckedUpdateOneWithoutSaleNestedInputSchema).optional(),
  documents: z.lazy(() => DocumentUncheckedUpdateManyWithoutSaleNestedInputSchema).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleUncheckedUpdateManyWithoutSaleNestedInputSchema).optional()
}).strict();

export const SaleUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.SaleUncheckedUpdateManyWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => EnumSaleStatusFieldUpdateOperationsInputSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  initialTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  availableTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  saleStartDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  tokenContractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenContractChainId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenTotalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  toWalletsAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleClosingDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  saftCheckbox: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  saftContract: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const UserRoleUpdateWithoutUserInputSchema: z.ZodType<Prisma.UserRoleUpdateWithoutUserInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  role: z.lazy(() => RoleUpdateOneRequiredWithoutUsersNestedInputSchema).optional()
}).strict();

export const UserRoleUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.UserRoleUncheckedUpdateWithoutUserInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  roleId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const UserRoleUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.UserRoleUncheckedUpdateManyWithoutUserInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  roleId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const TransactionAuditUpdateWithoutAdminInputSchema: z.ZodType<Prisma.TransactionAuditUpdateWithoutAdminInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  actionType: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  fromStatus: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  toStatus: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  transaction: z.lazy(() => SaleTransactionsUpdateOneRequiredWithoutAuditTrailNestedInputSchema).optional()
}).strict();

export const TransactionAuditUncheckedUpdateWithoutAdminInputSchema: z.ZodType<Prisma.TransactionAuditUncheckedUpdateWithoutAdminInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  transactionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  actionType: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  fromStatus: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  toStatus: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const TransactionAuditUncheckedUpdateManyWithoutAdminInputSchema: z.ZodType<Prisma.TransactionAuditUncheckedUpdateManyWithoutAdminInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  transactionId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  actionType: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  fromStatus: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  toStatus: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const SessionUpdateWithoutUserInputSchema: z.ZodType<Prisma.SessionUpdateWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  expiresAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  token: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  ipAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userAgent: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const SessionUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.SessionUncheckedUpdateWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  expiresAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  token: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  ipAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userAgent: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const SessionUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.SessionUncheckedUpdateManyWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  expiresAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  token: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  ipAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userAgent: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const SaleTransactionsUpdateWithoutUserInputSchema: z.ZodType<Prisma.SaleTransactionsUpdateWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  quantity: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rawPrice: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  price: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  totalAmount: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  formOfPayment: z.union([ z.lazy(() => FOPSchema),z.lazy(() => EnumFOPFieldUpdateOperationsInputSchema) ]).optional(),
  confirmationId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  receivingWallet: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amountPaid: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  amountPaidCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  agreementId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentEvidence: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentDate: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  sale: z.lazy(() => SaleUpdateOneRequiredWithoutTransactionsNestedInputSchema).optional(),
  blockchain: z.lazy(() => BlockchainUpdateOneWithoutTransactionsNestedInputSchema).optional(),
  approver: z.lazy(() => UserUpdateOneWithoutTransactionApprovalsNestedInputSchema).optional(),
  auditTrail: z.lazy(() => TransactionAuditUpdateManyWithoutTransactionNestedInputSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionUpdateManyWithoutTransactionNestedInputSchema).optional()
}).strict();

export const SaleTransactionsUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedUpdateWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  quantity: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rawPrice: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  price: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  totalAmount: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  formOfPayment: z.union([ z.lazy(() => FOPSchema),z.lazy(() => EnumFOPFieldUpdateOperationsInputSchema) ]).optional(),
  confirmationId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  receivingWallet: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  saleId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amountPaid: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  amountPaidCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  blockchainId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  agreementId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  approvedBy: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentEvidence: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentDate: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  auditTrail: z.lazy(() => TransactionAuditUncheckedUpdateManyWithoutTransactionNestedInputSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionUncheckedUpdateManyWithoutTransactionNestedInputSchema).optional()
}).strict();

export const SaleTransactionsUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedUpdateManyWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  quantity: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rawPrice: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  price: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  totalAmount: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  formOfPayment: z.union([ z.lazy(() => FOPSchema),z.lazy(() => EnumFOPFieldUpdateOperationsInputSchema) ]).optional(),
  confirmationId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  receivingWallet: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  saleId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amountPaid: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  amountPaidCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  blockchainId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  agreementId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  approvedBy: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentEvidence: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentDate: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const SaleTransactionsUpdateWithoutApproverInputSchema: z.ZodType<Prisma.SaleTransactionsUpdateWithoutApproverInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  quantity: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rawPrice: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  price: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  totalAmount: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  formOfPayment: z.union([ z.lazy(() => FOPSchema),z.lazy(() => EnumFOPFieldUpdateOperationsInputSchema) ]).optional(),
  confirmationId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  receivingWallet: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amountPaid: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  amountPaidCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  agreementId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentEvidence: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentDate: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutTransactionsNestedInputSchema).optional(),
  sale: z.lazy(() => SaleUpdateOneRequiredWithoutTransactionsNestedInputSchema).optional(),
  blockchain: z.lazy(() => BlockchainUpdateOneWithoutTransactionsNestedInputSchema).optional(),
  auditTrail: z.lazy(() => TransactionAuditUpdateManyWithoutTransactionNestedInputSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionUpdateManyWithoutTransactionNestedInputSchema).optional()
}).strict();

export const SaleTransactionsUncheckedUpdateWithoutApproverInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedUpdateWithoutApproverInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  quantity: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rawPrice: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  price: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  totalAmount: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  formOfPayment: z.union([ z.lazy(() => FOPSchema),z.lazy(() => EnumFOPFieldUpdateOperationsInputSchema) ]).optional(),
  confirmationId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  receivingWallet: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amountPaid: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  amountPaidCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  blockchainId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  agreementId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentEvidence: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentDate: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  auditTrail: z.lazy(() => TransactionAuditUncheckedUpdateManyWithoutTransactionNestedInputSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionUncheckedUpdateManyWithoutTransactionNestedInputSchema).optional()
}).strict();

export const SaleTransactionsUncheckedUpdateManyWithoutApproverInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedUpdateManyWithoutApproverInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  quantity: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rawPrice: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  price: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  totalAmount: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  formOfPayment: z.union([ z.lazy(() => FOPSchema),z.lazy(() => EnumFOPFieldUpdateOperationsInputSchema) ]).optional(),
  confirmationId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  receivingWallet: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amountPaid: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  amountPaidCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  blockchainId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  agreementId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentEvidence: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentDate: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const DocumentUpdateWithoutUserInputSchema: z.ZodType<Prisma.DocumentUpdateWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  fileName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  url: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  sale: z.lazy(() => SaleUpdateOneWithoutDocumentsNestedInputSchema).optional()
}).strict();

export const DocumentUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.DocumentUncheckedUpdateWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  fileName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  url: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const DocumentUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.DocumentUncheckedUpdateManyWithoutUserInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  fileName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  url: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const WalletAddressUpdateWithoutAddressInputSchema: z.ZodType<Prisma.WalletAddressUpdateWithoutAddressInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  chainId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const WalletAddressUncheckedUpdateWithoutAddressInputSchema: z.ZodType<Prisma.WalletAddressUncheckedUpdateWithoutAddressInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  chainId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const WalletAddressUncheckedUpdateManyWithoutAddressInputSchema: z.ZodType<Prisma.WalletAddressUncheckedUpdateManyWithoutAddressInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  chainId: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const SaleTransactionsCreateManySaleInputSchema: z.ZodType<Prisma.SaleTransactionsCreateManySaleInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  tokenSymbol: z.string(),
  quantity: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rawPrice: z.string(),
  price: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  totalAmount: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  formOfPayment: z.lazy(() => FOPSchema),
  confirmationId: z.string().optional().nullable(),
  receivingWallet: z.string().optional().nullable(),
  status: z.lazy(() => TransactionStatusSchema).optional(),
  userId: z.string(),
  comment: z.string().optional().nullable(),
  amountPaid: z.string(),
  amountPaidCurrency: z.lazy(() => CurrencySchema),
  txHash: z.string().optional().nullable(),
  blockchainId: z.string().optional().nullable(),
  agreementId: z.string().optional().nullable(),
  approvedBy: z.string().optional().nullable(),
  rejectionReason: z.string().optional().nullable(),
  paymentEvidence: z.string().optional().nullable(),
  paymentDate: z.coerce.date().optional().nullable()
}).strict();

export const DocumentCreateManySaleInputSchema: z.ZodType<Prisma.DocumentCreateManySaleInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  fileName: z.string(),
  url: z.string(),
  type: z.string(),
  userId: z.string().optional().nullable()
}).strict();

export const VestingScheduleCreateManySaleInputSchema: z.ZodType<Prisma.VestingScheduleCreateManySaleInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  cliffPeriod: z.number().int(),
  vestingPeriod: z.number().int(),
  releaseFrequency: z.number().int(),
  initialRelease: z.number(),
  isEnabled: z.boolean().optional()
}).strict();

export const SaleTransactionsUpdateWithoutSaleInputSchema: z.ZodType<Prisma.SaleTransactionsUpdateWithoutSaleInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  quantity: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rawPrice: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  price: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  totalAmount: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  formOfPayment: z.union([ z.lazy(() => FOPSchema),z.lazy(() => EnumFOPFieldUpdateOperationsInputSchema) ]).optional(),
  confirmationId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  receivingWallet: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amountPaid: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  amountPaidCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  agreementId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentEvidence: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentDate: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutTransactionsNestedInputSchema).optional(),
  blockchain: z.lazy(() => BlockchainUpdateOneWithoutTransactionsNestedInputSchema).optional(),
  approver: z.lazy(() => UserUpdateOneWithoutTransactionApprovalsNestedInputSchema).optional(),
  auditTrail: z.lazy(() => TransactionAuditUpdateManyWithoutTransactionNestedInputSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionUpdateManyWithoutTransactionNestedInputSchema).optional()
}).strict();

export const SaleTransactionsUncheckedUpdateWithoutSaleInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedUpdateWithoutSaleInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  quantity: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rawPrice: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  price: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  totalAmount: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  formOfPayment: z.union([ z.lazy(() => FOPSchema),z.lazy(() => EnumFOPFieldUpdateOperationsInputSchema) ]).optional(),
  confirmationId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  receivingWallet: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amountPaid: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  amountPaidCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  blockchainId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  agreementId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  approvedBy: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentEvidence: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentDate: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  auditTrail: z.lazy(() => TransactionAuditUncheckedUpdateManyWithoutTransactionNestedInputSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionUncheckedUpdateManyWithoutTransactionNestedInputSchema).optional()
}).strict();

export const SaleTransactionsUncheckedUpdateManyWithoutSaleInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedUpdateManyWithoutSaleInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  quantity: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rawPrice: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  price: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  totalAmount: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  formOfPayment: z.union([ z.lazy(() => FOPSchema),z.lazy(() => EnumFOPFieldUpdateOperationsInputSchema) ]).optional(),
  confirmationId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  receivingWallet: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amountPaid: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  amountPaidCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  blockchainId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  agreementId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  approvedBy: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentEvidence: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentDate: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const DocumentUpdateWithoutSaleInputSchema: z.ZodType<Prisma.DocumentUpdateWithoutSaleInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  fileName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  url: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  user: z.lazy(() => UserUpdateOneWithoutDocumentNestedInputSchema).optional()
}).strict();

export const DocumentUncheckedUpdateWithoutSaleInputSchema: z.ZodType<Prisma.DocumentUncheckedUpdateWithoutSaleInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  fileName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  url: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const DocumentUncheckedUpdateManyWithoutSaleInputSchema: z.ZodType<Prisma.DocumentUncheckedUpdateManyWithoutSaleInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  fileName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  url: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  type: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const VestingScheduleUpdateWithoutSaleInputSchema: z.ZodType<Prisma.VestingScheduleUpdateWithoutSaleInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  cliffPeriod: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  vestingPeriod: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  releaseFrequency: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  initialRelease: z.union([ z.number(),z.lazy(() => FloatFieldUpdateOperationsInputSchema) ]).optional(),
  isEnabled: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const VestingScheduleUncheckedUpdateWithoutSaleInputSchema: z.ZodType<Prisma.VestingScheduleUncheckedUpdateWithoutSaleInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  cliffPeriod: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  vestingPeriod: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  releaseFrequency: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  initialRelease: z.union([ z.number(),z.lazy(() => FloatFieldUpdateOperationsInputSchema) ]).optional(),
  isEnabled: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const VestingScheduleUncheckedUpdateManyWithoutSaleInputSchema: z.ZodType<Prisma.VestingScheduleUncheckedUpdateManyWithoutSaleInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  cliffPeriod: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  vestingPeriod: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  releaseFrequency: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  initialRelease: z.union([ z.number(),z.lazy(() => FloatFieldUpdateOperationsInputSchema) ]).optional(),
  isEnabled: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const TransactionAuditCreateManyTransactionInputSchema: z.ZodType<Prisma.TransactionAuditCreateManyTransactionInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  actionType: z.string(),
  fromStatus: z.lazy(() => TransactionStatusSchema),
  toStatus: z.lazy(() => TransactionStatusSchema),
  performedBy: z.string(),
  comment: z.string().optional().nullable()
}).strict();

export const TokenDistributionCreateManyTransactionInputSchema: z.ZodType<Prisma.TokenDistributionCreateManyTransactionInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  amount: z.string(),
  distributionDate: z.coerce.date(),
  txHash: z.string().optional().nullable(),
  status: z.string()
}).strict();

export const TransactionAuditUpdateWithoutTransactionInputSchema: z.ZodType<Prisma.TransactionAuditUpdateWithoutTransactionInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  actionType: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  fromStatus: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  toStatus: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  admin: z.lazy(() => UserUpdateOneRequiredWithoutTransactionAuditNestedInputSchema).optional()
}).strict();

export const TransactionAuditUncheckedUpdateWithoutTransactionInputSchema: z.ZodType<Prisma.TransactionAuditUncheckedUpdateWithoutTransactionInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  actionType: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  fromStatus: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  toStatus: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  performedBy: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const TransactionAuditUncheckedUpdateManyWithoutTransactionInputSchema: z.ZodType<Prisma.TransactionAuditUncheckedUpdateManyWithoutTransactionInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  actionType: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  fromStatus: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  toStatus: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  performedBy: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const TokenDistributionUpdateWithoutTransactionInputSchema: z.ZodType<Prisma.TokenDistributionUpdateWithoutTransactionInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amount: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  distributionDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const TokenDistributionUncheckedUpdateWithoutTransactionInputSchema: z.ZodType<Prisma.TokenDistributionUncheckedUpdateWithoutTransactionInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amount: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  distributionDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const TokenDistributionUncheckedUpdateManyWithoutTransactionInputSchema: z.ZodType<Prisma.TokenDistributionUncheckedUpdateManyWithoutTransactionInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amount: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  distributionDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const SaleTransactionsCreateManyBlockchainInputSchema: z.ZodType<Prisma.SaleTransactionsCreateManyBlockchainInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  tokenSymbol: z.string(),
  quantity: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  rawPrice: z.string(),
  price: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  totalAmount: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  formOfPayment: z.lazy(() => FOPSchema),
  confirmationId: z.string().optional().nullable(),
  receivingWallet: z.string().optional().nullable(),
  status: z.lazy(() => TransactionStatusSchema).optional(),
  userId: z.string(),
  saleId: z.string(),
  comment: z.string().optional().nullable(),
  amountPaid: z.string(),
  amountPaidCurrency: z.lazy(() => CurrencySchema),
  txHash: z.string().optional().nullable(),
  agreementId: z.string().optional().nullable(),
  approvedBy: z.string().optional().nullable(),
  rejectionReason: z.string().optional().nullable(),
  paymentEvidence: z.string().optional().nullable(),
  paymentDate: z.coerce.date().optional().nullable()
}).strict();

export const TokensOnBlockchainsCreateManyBlockchainInputSchema: z.ZodType<Prisma.TokensOnBlockchainsCreateManyBlockchainInput> = z.object({
  id: z.string().cuid().optional(),
  tokenId: z.string(),
  tokenSymbol: z.string(),
  name: z.string(),
  isNative: z.boolean().optional(),
  decimals: z.number().int(),
  contractAddress: z.string().optional().nullable()
}).strict();

export const SaleCreateManyBlockchainInputSchema: z.ZodType<Prisma.SaleCreateManyBlockchainInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  status: z.lazy(() => SaleStatusSchema).optional(),
  saleCurrency: z.lazy(() => CurrencySchema).optional(),
  initialTokenQuantity: z.number().int(),
  availableTokenQuantity: z.number().int(),
  maximumTokenBuyPerUser: z.number().int().optional().nullable(),
  minimumTokenBuyPerUser: z.number().int().optional(),
  saleStartDate: z.coerce.date(),
  tokenContractAddress: z.string().optional().nullable(),
  tokenName: z.string(),
  tokenTotalSupply: z.string().optional().nullable(),
  tokenPricePerUnit: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  tokenSymbol: z.string(),
  toWalletsAddress: z.string(),
  saleClosingDate: z.coerce.date(),
  createdBy: z.string(),
  saftCheckbox: z.boolean().optional(),
  saftContract: z.string().optional().nullable(),
  tokenId: z.string()
}).strict();

export const SaleTransactionsUpdateWithoutBlockchainInputSchema: z.ZodType<Prisma.SaleTransactionsUpdateWithoutBlockchainInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  quantity: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rawPrice: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  price: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  totalAmount: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  formOfPayment: z.union([ z.lazy(() => FOPSchema),z.lazy(() => EnumFOPFieldUpdateOperationsInputSchema) ]).optional(),
  confirmationId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  receivingWallet: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amountPaid: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  amountPaidCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  agreementId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentEvidence: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentDate: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutTransactionsNestedInputSchema).optional(),
  sale: z.lazy(() => SaleUpdateOneRequiredWithoutTransactionsNestedInputSchema).optional(),
  approver: z.lazy(() => UserUpdateOneWithoutTransactionApprovalsNestedInputSchema).optional(),
  auditTrail: z.lazy(() => TransactionAuditUpdateManyWithoutTransactionNestedInputSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionUpdateManyWithoutTransactionNestedInputSchema).optional()
}).strict();

export const SaleTransactionsUncheckedUpdateWithoutBlockchainInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedUpdateWithoutBlockchainInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  quantity: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rawPrice: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  price: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  totalAmount: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  formOfPayment: z.union([ z.lazy(() => FOPSchema),z.lazy(() => EnumFOPFieldUpdateOperationsInputSchema) ]).optional(),
  confirmationId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  receivingWallet: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amountPaid: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  amountPaidCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  agreementId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  approvedBy: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentEvidence: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentDate: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  auditTrail: z.lazy(() => TransactionAuditUncheckedUpdateManyWithoutTransactionNestedInputSchema).optional(),
  tokenDistributions: z.lazy(() => TokenDistributionUncheckedUpdateManyWithoutTransactionNestedInputSchema).optional()
}).strict();

export const SaleTransactionsUncheckedUpdateManyWithoutBlockchainInputSchema: z.ZodType<Prisma.SaleTransactionsUncheckedUpdateManyWithoutBlockchainInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  quantity: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  rawPrice: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  price: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  totalAmount: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  formOfPayment: z.union([ z.lazy(() => FOPSchema),z.lazy(() => EnumFOPFieldUpdateOperationsInputSchema) ]).optional(),
  confirmationId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  receivingWallet: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  status: z.union([ z.lazy(() => TransactionStatusSchema),z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema) ]).optional(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  comment: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  amountPaid: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  amountPaidCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  txHash: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  agreementId: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  approvedBy: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  rejectionReason: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentEvidence: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  paymentDate: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const TokensOnBlockchainsUpdateWithoutBlockchainInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUpdateWithoutBlockchainInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  isNative: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  decimals: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  contractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  token: z.lazy(() => TokenUpdateOneRequiredWithoutTokensOnBlockchainsNestedInputSchema).optional()
}).strict();

export const TokensOnBlockchainsUncheckedUpdateWithoutBlockchainInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUncheckedUpdateWithoutBlockchainInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  isNative: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  decimals: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  contractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const TokensOnBlockchainsUncheckedUpdateManyWithoutBlockchainInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUncheckedUpdateManyWithoutBlockchainInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  isNative: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  decimals: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  contractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const SaleUpdateWithoutBlockchainInputSchema: z.ZodType<Prisma.SaleUpdateWithoutBlockchainInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => EnumSaleStatusFieldUpdateOperationsInputSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  initialTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  availableTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  saleStartDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  tokenContractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenTotalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  toWalletsAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleClosingDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  saftCheckbox: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  saftContract: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutSalesNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUpdateManyWithoutSaleNestedInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationUpdateOneWithoutSaleNestedInputSchema).optional(),
  documents: z.lazy(() => DocumentUpdateManyWithoutSaleNestedInputSchema).optional(),
  token: z.lazy(() => TokenUpdateOneRequiredWithoutSalesNestedInputSchema).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleUpdateManyWithoutSaleNestedInputSchema).optional()
}).strict();

export const SaleUncheckedUpdateWithoutBlockchainInputSchema: z.ZodType<Prisma.SaleUncheckedUpdateWithoutBlockchainInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => EnumSaleStatusFieldUpdateOperationsInputSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  initialTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  availableTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  saleStartDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  tokenContractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenTotalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  toWalletsAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleClosingDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  createdBy: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saftCheckbox: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  saftContract: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  transactions: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutSaleNestedInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationUncheckedUpdateOneWithoutSaleNestedInputSchema).optional(),
  documents: z.lazy(() => DocumentUncheckedUpdateManyWithoutSaleNestedInputSchema).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleUncheckedUpdateManyWithoutSaleNestedInputSchema).optional()
}).strict();

export const SaleUncheckedUpdateManyWithoutBlockchainInputSchema: z.ZodType<Prisma.SaleUncheckedUpdateManyWithoutBlockchainInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => EnumSaleStatusFieldUpdateOperationsInputSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  initialTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  availableTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  saleStartDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  tokenContractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenTotalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  toWalletsAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleClosingDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  createdBy: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saftCheckbox: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  saftContract: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const UserRoleCreateManyRoleInputSchema: z.ZodType<Prisma.UserRoleCreateManyRoleInput> = z.object({
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  userId: z.string()
}).strict();

export const UserRoleUpdateWithoutRoleInputSchema: z.ZodType<Prisma.UserRoleUpdateWithoutRoleInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutUserRoleNestedInputSchema).optional()
}).strict();

export const UserRoleUncheckedUpdateWithoutRoleInputSchema: z.ZodType<Prisma.UserRoleUncheckedUpdateWithoutRoleInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const UserRoleUncheckedUpdateManyWithoutRoleInputSchema: z.ZodType<Prisma.UserRoleUncheckedUpdateManyWithoutRoleInput> = z.object({
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  userId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
}).strict();

export const SaleCreateManyTokenInputSchema: z.ZodType<Prisma.SaleCreateManyTokenInput> = z.object({
  id: z.string().cuid().optional(),
  createdAt: z.coerce.date().optional(),
  updatedAt: z.coerce.date().optional(),
  deletedAt: z.coerce.date().optional().nullable(),
  name: z.string(),
  status: z.lazy(() => SaleStatusSchema).optional(),
  saleCurrency: z.lazy(() => CurrencySchema).optional(),
  initialTokenQuantity: z.number().int(),
  availableTokenQuantity: z.number().int(),
  maximumTokenBuyPerUser: z.number().int().optional().nullable(),
  minimumTokenBuyPerUser: z.number().int().optional(),
  saleStartDate: z.coerce.date(),
  tokenContractAddress: z.string().optional().nullable(),
  tokenContractChainId: z.number().int().optional().nullable(),
  tokenName: z.string(),
  tokenTotalSupply: z.string().optional().nullable(),
  tokenPricePerUnit: z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
  tokenSymbol: z.string(),
  toWalletsAddress: z.string(),
  saleClosingDate: z.coerce.date(),
  createdBy: z.string(),
  saftCheckbox: z.boolean().optional(),
  saftContract: z.string().optional().nullable()
}).strict();

export const TokensOnBlockchainsCreateManyTokenInputSchema: z.ZodType<Prisma.TokensOnBlockchainsCreateManyTokenInput> = z.object({
  id: z.string().cuid().optional(),
  tokenSymbol: z.string(),
  blockchainId: z.string(),
  name: z.string(),
  isNative: z.boolean().optional(),
  decimals: z.number().int(),
  contractAddress: z.string().optional().nullable()
}).strict();

export const SaleUpdateWithoutTokenInputSchema: z.ZodType<Prisma.SaleUpdateWithoutTokenInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => EnumSaleStatusFieldUpdateOperationsInputSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  initialTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  availableTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  saleStartDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  tokenContractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenTotalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  toWalletsAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleClosingDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  saftCheckbox: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  saftContract: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  blockchain: z.lazy(() => BlockchainUpdateOneWithoutSaleNestedInputSchema).optional(),
  user: z.lazy(() => UserUpdateOneRequiredWithoutSalesNestedInputSchema).optional(),
  transactions: z.lazy(() => SaleTransactionsUpdateManyWithoutSaleNestedInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationUpdateOneWithoutSaleNestedInputSchema).optional(),
  documents: z.lazy(() => DocumentUpdateManyWithoutSaleNestedInputSchema).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleUpdateManyWithoutSaleNestedInputSchema).optional()
}).strict();

export const SaleUncheckedUpdateWithoutTokenInputSchema: z.ZodType<Prisma.SaleUncheckedUpdateWithoutTokenInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => EnumSaleStatusFieldUpdateOperationsInputSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  initialTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  availableTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  saleStartDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  tokenContractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenContractChainId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenTotalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  toWalletsAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleClosingDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  createdBy: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saftCheckbox: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  saftContract: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  transactions: z.lazy(() => SaleTransactionsUncheckedUpdateManyWithoutSaleNestedInputSchema).optional(),
  saleInformation: z.lazy(() => SaleInformationUncheckedUpdateOneWithoutSaleNestedInputSchema).optional(),
  documents: z.lazy(() => DocumentUncheckedUpdateManyWithoutSaleNestedInputSchema).optional(),
  vestingSchedules: z.lazy(() => VestingScheduleUncheckedUpdateManyWithoutSaleNestedInputSchema).optional()
}).strict();

export const SaleUncheckedUpdateManyWithoutTokenInputSchema: z.ZodType<Prisma.SaleUncheckedUpdateManyWithoutTokenInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  createdAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  updatedAt: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  deletedAt: z.union([ z.coerce.date(),z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  status: z.union([ z.lazy(() => SaleStatusSchema),z.lazy(() => EnumSaleStatusFieldUpdateOperationsInputSchema) ]).optional(),
  saleCurrency: z.union([ z.lazy(() => CurrencySchema),z.lazy(() => EnumCurrencyFieldUpdateOperationsInputSchema) ]).optional(),
  initialTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  availableTokenQuantity: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  maximumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  minimumTokenBuyPerUser: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  saleStartDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  tokenContractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenContractChainId: z.union([ z.number().int(),z.lazy(() => NullableIntFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenName: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenTotalSupply: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  tokenPricePerUnit: z.union([ z.union([z.number(),z.string(),z.instanceof(Decimal),z.instanceof(Prisma.Decimal),DecimalJsLikeSchema,]).refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),z.lazy(() => DecimalFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  toWalletsAddress: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saleClosingDate: z.union([ z.coerce.date(),z.lazy(() => DateTimeFieldUpdateOperationsInputSchema) ]).optional(),
  createdBy: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  saftCheckbox: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  saftContract: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const TokensOnBlockchainsUpdateWithoutTokenInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUpdateWithoutTokenInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  isNative: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  decimals: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  contractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
  blockchain: z.lazy(() => BlockchainUpdateOneRequiredWithoutTokensOnBlockchainsNestedInputSchema).optional()
}).strict();

export const TokensOnBlockchainsUncheckedUpdateWithoutTokenInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUncheckedUpdateWithoutTokenInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  blockchainId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  isNative: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  decimals: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  contractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

export const TokensOnBlockchainsUncheckedUpdateManyWithoutTokenInputSchema: z.ZodType<Prisma.TokensOnBlockchainsUncheckedUpdateManyWithoutTokenInput> = z.object({
  id: z.union([ z.string().cuid(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  tokenSymbol: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  blockchainId: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  name: z.union([ z.string(),z.lazy(() => StringFieldUpdateOperationsInputSchema) ]).optional(),
  isNative: z.union([ z.boolean(),z.lazy(() => BoolFieldUpdateOperationsInputSchema) ]).optional(),
  decimals: z.union([ z.number().int(),z.lazy(() => IntFieldUpdateOperationsInputSchema) ]).optional(),
  contractAddress: z.union([ z.string(),z.lazy(() => NullableStringFieldUpdateOperationsInputSchema) ]).optional().nullable(),
}).strict();

/////////////////////////////////////////
// ARGS
/////////////////////////////////////////

export const UserFindFirstArgsSchema: z.ZodType<Prisma.UserFindFirstArgs> = z.object({
  select: UserSelectSchema.optional(),
  include: UserIncludeSchema.optional(),
  where: UserWhereInputSchema.optional(),
  orderBy: z.union([ UserOrderByWithRelationInputSchema.array(),UserOrderByWithRelationInputSchema ]).optional(),
  cursor: UserWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ UserScalarFieldEnumSchema,UserScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const UserFindFirstOrThrowArgsSchema: z.ZodType<Prisma.UserFindFirstOrThrowArgs> = z.object({
  select: UserSelectSchema.optional(),
  include: UserIncludeSchema.optional(),
  where: UserWhereInputSchema.optional(),
  orderBy: z.union([ UserOrderByWithRelationInputSchema.array(),UserOrderByWithRelationInputSchema ]).optional(),
  cursor: UserWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ UserScalarFieldEnumSchema,UserScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const UserFindManyArgsSchema: z.ZodType<Prisma.UserFindManyArgs> = z.object({
  select: UserSelectSchema.optional(),
  include: UserIncludeSchema.optional(),
  where: UserWhereInputSchema.optional(),
  orderBy: z.union([ UserOrderByWithRelationInputSchema.array(),UserOrderByWithRelationInputSchema ]).optional(),
  cursor: UserWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ UserScalarFieldEnumSchema,UserScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const UserAggregateArgsSchema: z.ZodType<Prisma.UserAggregateArgs> = z.object({
  where: UserWhereInputSchema.optional(),
  orderBy: z.union([ UserOrderByWithRelationInputSchema.array(),UserOrderByWithRelationInputSchema ]).optional(),
  cursor: UserWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const UserGroupByArgsSchema: z.ZodType<Prisma.UserGroupByArgs> = z.object({
  where: UserWhereInputSchema.optional(),
  orderBy: z.union([ UserOrderByWithAggregationInputSchema.array(),UserOrderByWithAggregationInputSchema ]).optional(),
  by: UserScalarFieldEnumSchema.array(),
  having: UserScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const UserFindUniqueArgsSchema: z.ZodType<Prisma.UserFindUniqueArgs> = z.object({
  select: UserSelectSchema.optional(),
  include: UserIncludeSchema.optional(),
  where: UserWhereUniqueInputSchema,
}).strict() ;

export const UserFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.UserFindUniqueOrThrowArgs> = z.object({
  select: UserSelectSchema.optional(),
  include: UserIncludeSchema.optional(),
  where: UserWhereUniqueInputSchema,
}).strict() ;

export const WalletAddressFindFirstArgsSchema: z.ZodType<Prisma.WalletAddressFindFirstArgs> = z.object({
  select: WalletAddressSelectSchema.optional(),
  include: WalletAddressIncludeSchema.optional(),
  where: WalletAddressWhereInputSchema.optional(),
  orderBy: z.union([ WalletAddressOrderByWithRelationInputSchema.array(),WalletAddressOrderByWithRelationInputSchema ]).optional(),
  cursor: WalletAddressWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ WalletAddressScalarFieldEnumSchema,WalletAddressScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const WalletAddressFindFirstOrThrowArgsSchema: z.ZodType<Prisma.WalletAddressFindFirstOrThrowArgs> = z.object({
  select: WalletAddressSelectSchema.optional(),
  include: WalletAddressIncludeSchema.optional(),
  where: WalletAddressWhereInputSchema.optional(),
  orderBy: z.union([ WalletAddressOrderByWithRelationInputSchema.array(),WalletAddressOrderByWithRelationInputSchema ]).optional(),
  cursor: WalletAddressWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ WalletAddressScalarFieldEnumSchema,WalletAddressScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const WalletAddressFindManyArgsSchema: z.ZodType<Prisma.WalletAddressFindManyArgs> = z.object({
  select: WalletAddressSelectSchema.optional(),
  include: WalletAddressIncludeSchema.optional(),
  where: WalletAddressWhereInputSchema.optional(),
  orderBy: z.union([ WalletAddressOrderByWithRelationInputSchema.array(),WalletAddressOrderByWithRelationInputSchema ]).optional(),
  cursor: WalletAddressWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ WalletAddressScalarFieldEnumSchema,WalletAddressScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const WalletAddressAggregateArgsSchema: z.ZodType<Prisma.WalletAddressAggregateArgs> = z.object({
  where: WalletAddressWhereInputSchema.optional(),
  orderBy: z.union([ WalletAddressOrderByWithRelationInputSchema.array(),WalletAddressOrderByWithRelationInputSchema ]).optional(),
  cursor: WalletAddressWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const WalletAddressGroupByArgsSchema: z.ZodType<Prisma.WalletAddressGroupByArgs> = z.object({
  where: WalletAddressWhereInputSchema.optional(),
  orderBy: z.union([ WalletAddressOrderByWithAggregationInputSchema.array(),WalletAddressOrderByWithAggregationInputSchema ]).optional(),
  by: WalletAddressScalarFieldEnumSchema.array(),
  having: WalletAddressScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const WalletAddressFindUniqueArgsSchema: z.ZodType<Prisma.WalletAddressFindUniqueArgs> = z.object({
  select: WalletAddressSelectSchema.optional(),
  include: WalletAddressIncludeSchema.optional(),
  where: WalletAddressWhereUniqueInputSchema,
}).strict() ;

export const WalletAddressFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.WalletAddressFindUniqueOrThrowArgs> = z.object({
  select: WalletAddressSelectSchema.optional(),
  include: WalletAddressIncludeSchema.optional(),
  where: WalletAddressWhereUniqueInputSchema,
}).strict() ;

export const SessionFindFirstArgsSchema: z.ZodType<Prisma.SessionFindFirstArgs> = z.object({
  select: SessionSelectSchema.optional(),
  include: SessionIncludeSchema.optional(),
  where: SessionWhereInputSchema.optional(),
  orderBy: z.union([ SessionOrderByWithRelationInputSchema.array(),SessionOrderByWithRelationInputSchema ]).optional(),
  cursor: SessionWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ SessionScalarFieldEnumSchema,SessionScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const SessionFindFirstOrThrowArgsSchema: z.ZodType<Prisma.SessionFindFirstOrThrowArgs> = z.object({
  select: SessionSelectSchema.optional(),
  include: SessionIncludeSchema.optional(),
  where: SessionWhereInputSchema.optional(),
  orderBy: z.union([ SessionOrderByWithRelationInputSchema.array(),SessionOrderByWithRelationInputSchema ]).optional(),
  cursor: SessionWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ SessionScalarFieldEnumSchema,SessionScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const SessionFindManyArgsSchema: z.ZodType<Prisma.SessionFindManyArgs> = z.object({
  select: SessionSelectSchema.optional(),
  include: SessionIncludeSchema.optional(),
  where: SessionWhereInputSchema.optional(),
  orderBy: z.union([ SessionOrderByWithRelationInputSchema.array(),SessionOrderByWithRelationInputSchema ]).optional(),
  cursor: SessionWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ SessionScalarFieldEnumSchema,SessionScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const SessionAggregateArgsSchema: z.ZodType<Prisma.SessionAggregateArgs> = z.object({
  where: SessionWhereInputSchema.optional(),
  orderBy: z.union([ SessionOrderByWithRelationInputSchema.array(),SessionOrderByWithRelationInputSchema ]).optional(),
  cursor: SessionWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const SessionGroupByArgsSchema: z.ZodType<Prisma.SessionGroupByArgs> = z.object({
  where: SessionWhereInputSchema.optional(),
  orderBy: z.union([ SessionOrderByWithAggregationInputSchema.array(),SessionOrderByWithAggregationInputSchema ]).optional(),
  by: SessionScalarFieldEnumSchema.array(),
  having: SessionScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const SessionFindUniqueArgsSchema: z.ZodType<Prisma.SessionFindUniqueArgs> = z.object({
  select: SessionSelectSchema.optional(),
  include: SessionIncludeSchema.optional(),
  where: SessionWhereUniqueInputSchema,
}).strict() ;

export const SessionFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.SessionFindUniqueOrThrowArgs> = z.object({
  select: SessionSelectSchema.optional(),
  include: SessionIncludeSchema.optional(),
  where: SessionWhereUniqueInputSchema,
}).strict() ;

export const VerificationFindFirstArgsSchema: z.ZodType<Prisma.VerificationFindFirstArgs> = z.object({
  select: VerificationSelectSchema.optional(),
  where: VerificationWhereInputSchema.optional(),
  orderBy: z.union([ VerificationOrderByWithRelationInputSchema.array(),VerificationOrderByWithRelationInputSchema ]).optional(),
  cursor: VerificationWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ VerificationScalarFieldEnumSchema,VerificationScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const VerificationFindFirstOrThrowArgsSchema: z.ZodType<Prisma.VerificationFindFirstOrThrowArgs> = z.object({
  select: VerificationSelectSchema.optional(),
  where: VerificationWhereInputSchema.optional(),
  orderBy: z.union([ VerificationOrderByWithRelationInputSchema.array(),VerificationOrderByWithRelationInputSchema ]).optional(),
  cursor: VerificationWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ VerificationScalarFieldEnumSchema,VerificationScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const VerificationFindManyArgsSchema: z.ZodType<Prisma.VerificationFindManyArgs> = z.object({
  select: VerificationSelectSchema.optional(),
  where: VerificationWhereInputSchema.optional(),
  orderBy: z.union([ VerificationOrderByWithRelationInputSchema.array(),VerificationOrderByWithRelationInputSchema ]).optional(),
  cursor: VerificationWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ VerificationScalarFieldEnumSchema,VerificationScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const VerificationAggregateArgsSchema: z.ZodType<Prisma.VerificationAggregateArgs> = z.object({
  where: VerificationWhereInputSchema.optional(),
  orderBy: z.union([ VerificationOrderByWithRelationInputSchema.array(),VerificationOrderByWithRelationInputSchema ]).optional(),
  cursor: VerificationWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const VerificationGroupByArgsSchema: z.ZodType<Prisma.VerificationGroupByArgs> = z.object({
  where: VerificationWhereInputSchema.optional(),
  orderBy: z.union([ VerificationOrderByWithAggregationInputSchema.array(),VerificationOrderByWithAggregationInputSchema ]).optional(),
  by: VerificationScalarFieldEnumSchema.array(),
  having: VerificationScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const VerificationFindUniqueArgsSchema: z.ZodType<Prisma.VerificationFindUniqueArgs> = z.object({
  select: VerificationSelectSchema.optional(),
  where: VerificationWhereUniqueInputSchema,
}).strict() ;

export const VerificationFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.VerificationFindUniqueOrThrowArgs> = z.object({
  select: VerificationSelectSchema.optional(),
  where: VerificationWhereUniqueInputSchema,
}).strict() ;

export const ProfileFindFirstArgsSchema: z.ZodType<Prisma.ProfileFindFirstArgs> = z.object({
  select: ProfileSelectSchema.optional(),
  include: ProfileIncludeSchema.optional(),
  where: ProfileWhereInputSchema.optional(),
  orderBy: z.union([ ProfileOrderByWithRelationInputSchema.array(),ProfileOrderByWithRelationInputSchema ]).optional(),
  cursor: ProfileWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ ProfileScalarFieldEnumSchema,ProfileScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const ProfileFindFirstOrThrowArgsSchema: z.ZodType<Prisma.ProfileFindFirstOrThrowArgs> = z.object({
  select: ProfileSelectSchema.optional(),
  include: ProfileIncludeSchema.optional(),
  where: ProfileWhereInputSchema.optional(),
  orderBy: z.union([ ProfileOrderByWithRelationInputSchema.array(),ProfileOrderByWithRelationInputSchema ]).optional(),
  cursor: ProfileWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ ProfileScalarFieldEnumSchema,ProfileScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const ProfileFindManyArgsSchema: z.ZodType<Prisma.ProfileFindManyArgs> = z.object({
  select: ProfileSelectSchema.optional(),
  include: ProfileIncludeSchema.optional(),
  where: ProfileWhereInputSchema.optional(),
  orderBy: z.union([ ProfileOrderByWithRelationInputSchema.array(),ProfileOrderByWithRelationInputSchema ]).optional(),
  cursor: ProfileWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ ProfileScalarFieldEnumSchema,ProfileScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const ProfileAggregateArgsSchema: z.ZodType<Prisma.ProfileAggregateArgs> = z.object({
  where: ProfileWhereInputSchema.optional(),
  orderBy: z.union([ ProfileOrderByWithRelationInputSchema.array(),ProfileOrderByWithRelationInputSchema ]).optional(),
  cursor: ProfileWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const ProfileGroupByArgsSchema: z.ZodType<Prisma.ProfileGroupByArgs> = z.object({
  where: ProfileWhereInputSchema.optional(),
  orderBy: z.union([ ProfileOrderByWithAggregationInputSchema.array(),ProfileOrderByWithAggregationInputSchema ]).optional(),
  by: ProfileScalarFieldEnumSchema.array(),
  having: ProfileScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const ProfileFindUniqueArgsSchema: z.ZodType<Prisma.ProfileFindUniqueArgs> = z.object({
  select: ProfileSelectSchema.optional(),
  include: ProfileIncludeSchema.optional(),
  where: ProfileWhereUniqueInputSchema,
}).strict() ;

export const ProfileFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.ProfileFindUniqueOrThrowArgs> = z.object({
  select: ProfileSelectSchema.optional(),
  include: ProfileIncludeSchema.optional(),
  where: ProfileWhereUniqueInputSchema,
}).strict() ;

export const AddressFindFirstArgsSchema: z.ZodType<Prisma.AddressFindFirstArgs> = z.object({
  select: AddressSelectSchema.optional(),
  include: AddressIncludeSchema.optional(),
  where: AddressWhereInputSchema.optional(),
  orderBy: z.union([ AddressOrderByWithRelationInputSchema.array(),AddressOrderByWithRelationInputSchema ]).optional(),
  cursor: AddressWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ AddressScalarFieldEnumSchema,AddressScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const AddressFindFirstOrThrowArgsSchema: z.ZodType<Prisma.AddressFindFirstOrThrowArgs> = z.object({
  select: AddressSelectSchema.optional(),
  include: AddressIncludeSchema.optional(),
  where: AddressWhereInputSchema.optional(),
  orderBy: z.union([ AddressOrderByWithRelationInputSchema.array(),AddressOrderByWithRelationInputSchema ]).optional(),
  cursor: AddressWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ AddressScalarFieldEnumSchema,AddressScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const AddressFindManyArgsSchema: z.ZodType<Prisma.AddressFindManyArgs> = z.object({
  select: AddressSelectSchema.optional(),
  include: AddressIncludeSchema.optional(),
  where: AddressWhereInputSchema.optional(),
  orderBy: z.union([ AddressOrderByWithRelationInputSchema.array(),AddressOrderByWithRelationInputSchema ]).optional(),
  cursor: AddressWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ AddressScalarFieldEnumSchema,AddressScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const AddressAggregateArgsSchema: z.ZodType<Prisma.AddressAggregateArgs> = z.object({
  where: AddressWhereInputSchema.optional(),
  orderBy: z.union([ AddressOrderByWithRelationInputSchema.array(),AddressOrderByWithRelationInputSchema ]).optional(),
  cursor: AddressWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const AddressGroupByArgsSchema: z.ZodType<Prisma.AddressGroupByArgs> = z.object({
  where: AddressWhereInputSchema.optional(),
  orderBy: z.union([ AddressOrderByWithAggregationInputSchema.array(),AddressOrderByWithAggregationInputSchema ]).optional(),
  by: AddressScalarFieldEnumSchema.array(),
  having: AddressScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const AddressFindUniqueArgsSchema: z.ZodType<Prisma.AddressFindUniqueArgs> = z.object({
  select: AddressSelectSchema.optional(),
  include: AddressIncludeSchema.optional(),
  where: AddressWhereUniqueInputSchema,
}).strict() ;

export const AddressFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.AddressFindUniqueOrThrowArgs> = z.object({
  select: AddressSelectSchema.optional(),
  include: AddressIncludeSchema.optional(),
  where: AddressWhereUniqueInputSchema,
}).strict() ;

export const SaleFindFirstArgsSchema: z.ZodType<Prisma.SaleFindFirstArgs> = z.object({
  select: SaleSelectSchema.optional(),
  include: SaleIncludeSchema.optional(),
  where: SaleWhereInputSchema.optional(),
  orderBy: z.union([ SaleOrderByWithRelationInputSchema.array(),SaleOrderByWithRelationInputSchema ]).optional(),
  cursor: SaleWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ SaleScalarFieldEnumSchema,SaleScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const SaleFindFirstOrThrowArgsSchema: z.ZodType<Prisma.SaleFindFirstOrThrowArgs> = z.object({
  select: SaleSelectSchema.optional(),
  include: SaleIncludeSchema.optional(),
  where: SaleWhereInputSchema.optional(),
  orderBy: z.union([ SaleOrderByWithRelationInputSchema.array(),SaleOrderByWithRelationInputSchema ]).optional(),
  cursor: SaleWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ SaleScalarFieldEnumSchema,SaleScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const SaleFindManyArgsSchema: z.ZodType<Prisma.SaleFindManyArgs> = z.object({
  select: SaleSelectSchema.optional(),
  include: SaleIncludeSchema.optional(),
  where: SaleWhereInputSchema.optional(),
  orderBy: z.union([ SaleOrderByWithRelationInputSchema.array(),SaleOrderByWithRelationInputSchema ]).optional(),
  cursor: SaleWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ SaleScalarFieldEnumSchema,SaleScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const SaleAggregateArgsSchema: z.ZodType<Prisma.SaleAggregateArgs> = z.object({
  where: SaleWhereInputSchema.optional(),
  orderBy: z.union([ SaleOrderByWithRelationInputSchema.array(),SaleOrderByWithRelationInputSchema ]).optional(),
  cursor: SaleWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const SaleGroupByArgsSchema: z.ZodType<Prisma.SaleGroupByArgs> = z.object({
  where: SaleWhereInputSchema.optional(),
  orderBy: z.union([ SaleOrderByWithAggregationInputSchema.array(),SaleOrderByWithAggregationInputSchema ]).optional(),
  by: SaleScalarFieldEnumSchema.array(),
  having: SaleScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const SaleFindUniqueArgsSchema: z.ZodType<Prisma.SaleFindUniqueArgs> = z.object({
  select: SaleSelectSchema.optional(),
  include: SaleIncludeSchema.optional(),
  where: SaleWhereUniqueInputSchema,
}).strict() ;

export const SaleFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.SaleFindUniqueOrThrowArgs> = z.object({
  select: SaleSelectSchema.optional(),
  include: SaleIncludeSchema.optional(),
  where: SaleWhereUniqueInputSchema,
}).strict() ;

export const DocumentFindFirstArgsSchema: z.ZodType<Prisma.DocumentFindFirstArgs> = z.object({
  select: DocumentSelectSchema.optional(),
  include: DocumentIncludeSchema.optional(),
  where: DocumentWhereInputSchema.optional(),
  orderBy: z.union([ DocumentOrderByWithRelationInputSchema.array(),DocumentOrderByWithRelationInputSchema ]).optional(),
  cursor: DocumentWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ DocumentScalarFieldEnumSchema,DocumentScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const DocumentFindFirstOrThrowArgsSchema: z.ZodType<Prisma.DocumentFindFirstOrThrowArgs> = z.object({
  select: DocumentSelectSchema.optional(),
  include: DocumentIncludeSchema.optional(),
  where: DocumentWhereInputSchema.optional(),
  orderBy: z.union([ DocumentOrderByWithRelationInputSchema.array(),DocumentOrderByWithRelationInputSchema ]).optional(),
  cursor: DocumentWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ DocumentScalarFieldEnumSchema,DocumentScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const DocumentFindManyArgsSchema: z.ZodType<Prisma.DocumentFindManyArgs> = z.object({
  select: DocumentSelectSchema.optional(),
  include: DocumentIncludeSchema.optional(),
  where: DocumentWhereInputSchema.optional(),
  orderBy: z.union([ DocumentOrderByWithRelationInputSchema.array(),DocumentOrderByWithRelationInputSchema ]).optional(),
  cursor: DocumentWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ DocumentScalarFieldEnumSchema,DocumentScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const DocumentAggregateArgsSchema: z.ZodType<Prisma.DocumentAggregateArgs> = z.object({
  where: DocumentWhereInputSchema.optional(),
  orderBy: z.union([ DocumentOrderByWithRelationInputSchema.array(),DocumentOrderByWithRelationInputSchema ]).optional(),
  cursor: DocumentWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const DocumentGroupByArgsSchema: z.ZodType<Prisma.DocumentGroupByArgs> = z.object({
  where: DocumentWhereInputSchema.optional(),
  orderBy: z.union([ DocumentOrderByWithAggregationInputSchema.array(),DocumentOrderByWithAggregationInputSchema ]).optional(),
  by: DocumentScalarFieldEnumSchema.array(),
  having: DocumentScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const DocumentFindUniqueArgsSchema: z.ZodType<Prisma.DocumentFindUniqueArgs> = z.object({
  select: DocumentSelectSchema.optional(),
  include: DocumentIncludeSchema.optional(),
  where: DocumentWhereUniqueInputSchema,
}).strict() ;

export const DocumentFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.DocumentFindUniqueOrThrowArgs> = z.object({
  select: DocumentSelectSchema.optional(),
  include: DocumentIncludeSchema.optional(),
  where: DocumentWhereUniqueInputSchema,
}).strict() ;

export const VestingScheduleFindFirstArgsSchema: z.ZodType<Prisma.VestingScheduleFindFirstArgs> = z.object({
  select: VestingScheduleSelectSchema.optional(),
  include: VestingScheduleIncludeSchema.optional(),
  where: VestingScheduleWhereInputSchema.optional(),
  orderBy: z.union([ VestingScheduleOrderByWithRelationInputSchema.array(),VestingScheduleOrderByWithRelationInputSchema ]).optional(),
  cursor: VestingScheduleWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ VestingScheduleScalarFieldEnumSchema,VestingScheduleScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const VestingScheduleFindFirstOrThrowArgsSchema: z.ZodType<Prisma.VestingScheduleFindFirstOrThrowArgs> = z.object({
  select: VestingScheduleSelectSchema.optional(),
  include: VestingScheduleIncludeSchema.optional(),
  where: VestingScheduleWhereInputSchema.optional(),
  orderBy: z.union([ VestingScheduleOrderByWithRelationInputSchema.array(),VestingScheduleOrderByWithRelationInputSchema ]).optional(),
  cursor: VestingScheduleWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ VestingScheduleScalarFieldEnumSchema,VestingScheduleScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const VestingScheduleFindManyArgsSchema: z.ZodType<Prisma.VestingScheduleFindManyArgs> = z.object({
  select: VestingScheduleSelectSchema.optional(),
  include: VestingScheduleIncludeSchema.optional(),
  where: VestingScheduleWhereInputSchema.optional(),
  orderBy: z.union([ VestingScheduleOrderByWithRelationInputSchema.array(),VestingScheduleOrderByWithRelationInputSchema ]).optional(),
  cursor: VestingScheduleWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ VestingScheduleScalarFieldEnumSchema,VestingScheduleScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const VestingScheduleAggregateArgsSchema: z.ZodType<Prisma.VestingScheduleAggregateArgs> = z.object({
  where: VestingScheduleWhereInputSchema.optional(),
  orderBy: z.union([ VestingScheduleOrderByWithRelationInputSchema.array(),VestingScheduleOrderByWithRelationInputSchema ]).optional(),
  cursor: VestingScheduleWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const VestingScheduleGroupByArgsSchema: z.ZodType<Prisma.VestingScheduleGroupByArgs> = z.object({
  where: VestingScheduleWhereInputSchema.optional(),
  orderBy: z.union([ VestingScheduleOrderByWithAggregationInputSchema.array(),VestingScheduleOrderByWithAggregationInputSchema ]).optional(),
  by: VestingScheduleScalarFieldEnumSchema.array(),
  having: VestingScheduleScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const VestingScheduleFindUniqueArgsSchema: z.ZodType<Prisma.VestingScheduleFindUniqueArgs> = z.object({
  select: VestingScheduleSelectSchema.optional(),
  include: VestingScheduleIncludeSchema.optional(),
  where: VestingScheduleWhereUniqueInputSchema,
}).strict() ;

export const VestingScheduleFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.VestingScheduleFindUniqueOrThrowArgs> = z.object({
  select: VestingScheduleSelectSchema.optional(),
  include: VestingScheduleIncludeSchema.optional(),
  where: VestingScheduleWhereUniqueInputSchema,
}).strict() ;

export const TokenDistributionFindFirstArgsSchema: z.ZodType<Prisma.TokenDistributionFindFirstArgs> = z.object({
  select: TokenDistributionSelectSchema.optional(),
  include: TokenDistributionIncludeSchema.optional(),
  where: TokenDistributionWhereInputSchema.optional(),
  orderBy: z.union([ TokenDistributionOrderByWithRelationInputSchema.array(),TokenDistributionOrderByWithRelationInputSchema ]).optional(),
  cursor: TokenDistributionWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ TokenDistributionScalarFieldEnumSchema,TokenDistributionScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const TokenDistributionFindFirstOrThrowArgsSchema: z.ZodType<Prisma.TokenDistributionFindFirstOrThrowArgs> = z.object({
  select: TokenDistributionSelectSchema.optional(),
  include: TokenDistributionIncludeSchema.optional(),
  where: TokenDistributionWhereInputSchema.optional(),
  orderBy: z.union([ TokenDistributionOrderByWithRelationInputSchema.array(),TokenDistributionOrderByWithRelationInputSchema ]).optional(),
  cursor: TokenDistributionWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ TokenDistributionScalarFieldEnumSchema,TokenDistributionScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const TokenDistributionFindManyArgsSchema: z.ZodType<Prisma.TokenDistributionFindManyArgs> = z.object({
  select: TokenDistributionSelectSchema.optional(),
  include: TokenDistributionIncludeSchema.optional(),
  where: TokenDistributionWhereInputSchema.optional(),
  orderBy: z.union([ TokenDistributionOrderByWithRelationInputSchema.array(),TokenDistributionOrderByWithRelationInputSchema ]).optional(),
  cursor: TokenDistributionWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ TokenDistributionScalarFieldEnumSchema,TokenDistributionScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const TokenDistributionAggregateArgsSchema: z.ZodType<Prisma.TokenDistributionAggregateArgs> = z.object({
  where: TokenDistributionWhereInputSchema.optional(),
  orderBy: z.union([ TokenDistributionOrderByWithRelationInputSchema.array(),TokenDistributionOrderByWithRelationInputSchema ]).optional(),
  cursor: TokenDistributionWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const TokenDistributionGroupByArgsSchema: z.ZodType<Prisma.TokenDistributionGroupByArgs> = z.object({
  where: TokenDistributionWhereInputSchema.optional(),
  orderBy: z.union([ TokenDistributionOrderByWithAggregationInputSchema.array(),TokenDistributionOrderByWithAggregationInputSchema ]).optional(),
  by: TokenDistributionScalarFieldEnumSchema.array(),
  having: TokenDistributionScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const TokenDistributionFindUniqueArgsSchema: z.ZodType<Prisma.TokenDistributionFindUniqueArgs> = z.object({
  select: TokenDistributionSelectSchema.optional(),
  include: TokenDistributionIncludeSchema.optional(),
  where: TokenDistributionWhereUniqueInputSchema,
}).strict() ;

export const TokenDistributionFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.TokenDistributionFindUniqueOrThrowArgs> = z.object({
  select: TokenDistributionSelectSchema.optional(),
  include: TokenDistributionIncludeSchema.optional(),
  where: TokenDistributionWhereUniqueInputSchema,
}).strict() ;

export const SaleInformationFindFirstArgsSchema: z.ZodType<Prisma.SaleInformationFindFirstArgs> = z.object({
  select: SaleInformationSelectSchema.optional(),
  include: SaleInformationIncludeSchema.optional(),
  where: SaleInformationWhereInputSchema.optional(),
  orderBy: z.union([ SaleInformationOrderByWithRelationInputSchema.array(),SaleInformationOrderByWithRelationInputSchema ]).optional(),
  cursor: SaleInformationWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ SaleInformationScalarFieldEnumSchema,SaleInformationScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const SaleInformationFindFirstOrThrowArgsSchema: z.ZodType<Prisma.SaleInformationFindFirstOrThrowArgs> = z.object({
  select: SaleInformationSelectSchema.optional(),
  include: SaleInformationIncludeSchema.optional(),
  where: SaleInformationWhereInputSchema.optional(),
  orderBy: z.union([ SaleInformationOrderByWithRelationInputSchema.array(),SaleInformationOrderByWithRelationInputSchema ]).optional(),
  cursor: SaleInformationWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ SaleInformationScalarFieldEnumSchema,SaleInformationScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const SaleInformationFindManyArgsSchema: z.ZodType<Prisma.SaleInformationFindManyArgs> = z.object({
  select: SaleInformationSelectSchema.optional(),
  include: SaleInformationIncludeSchema.optional(),
  where: SaleInformationWhereInputSchema.optional(),
  orderBy: z.union([ SaleInformationOrderByWithRelationInputSchema.array(),SaleInformationOrderByWithRelationInputSchema ]).optional(),
  cursor: SaleInformationWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ SaleInformationScalarFieldEnumSchema,SaleInformationScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const SaleInformationAggregateArgsSchema: z.ZodType<Prisma.SaleInformationAggregateArgs> = z.object({
  where: SaleInformationWhereInputSchema.optional(),
  orderBy: z.union([ SaleInformationOrderByWithRelationInputSchema.array(),SaleInformationOrderByWithRelationInputSchema ]).optional(),
  cursor: SaleInformationWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const SaleInformationGroupByArgsSchema: z.ZodType<Prisma.SaleInformationGroupByArgs> = z.object({
  where: SaleInformationWhereInputSchema.optional(),
  orderBy: z.union([ SaleInformationOrderByWithAggregationInputSchema.array(),SaleInformationOrderByWithAggregationInputSchema ]).optional(),
  by: SaleInformationScalarFieldEnumSchema.array(),
  having: SaleInformationScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const SaleInformationFindUniqueArgsSchema: z.ZodType<Prisma.SaleInformationFindUniqueArgs> = z.object({
  select: SaleInformationSelectSchema.optional(),
  include: SaleInformationIncludeSchema.optional(),
  where: SaleInformationWhereUniqueInputSchema,
}).strict() ;

export const SaleInformationFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.SaleInformationFindUniqueOrThrowArgs> = z.object({
  select: SaleInformationSelectSchema.optional(),
  include: SaleInformationIncludeSchema.optional(),
  where: SaleInformationWhereUniqueInputSchema,
}).strict() ;

export const SaleTransactionsFindFirstArgsSchema: z.ZodType<Prisma.SaleTransactionsFindFirstArgs> = z.object({
  select: SaleTransactionsSelectSchema.optional(),
  include: SaleTransactionsIncludeSchema.optional(),
  where: SaleTransactionsWhereInputSchema.optional(),
  orderBy: z.union([ SaleTransactionsOrderByWithRelationInputSchema.array(),SaleTransactionsOrderByWithRelationInputSchema ]).optional(),
  cursor: SaleTransactionsWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ SaleTransactionsScalarFieldEnumSchema,SaleTransactionsScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const SaleTransactionsFindFirstOrThrowArgsSchema: z.ZodType<Prisma.SaleTransactionsFindFirstOrThrowArgs> = z.object({
  select: SaleTransactionsSelectSchema.optional(),
  include: SaleTransactionsIncludeSchema.optional(),
  where: SaleTransactionsWhereInputSchema.optional(),
  orderBy: z.union([ SaleTransactionsOrderByWithRelationInputSchema.array(),SaleTransactionsOrderByWithRelationInputSchema ]).optional(),
  cursor: SaleTransactionsWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ SaleTransactionsScalarFieldEnumSchema,SaleTransactionsScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const SaleTransactionsFindManyArgsSchema: z.ZodType<Prisma.SaleTransactionsFindManyArgs> = z.object({
  select: SaleTransactionsSelectSchema.optional(),
  include: SaleTransactionsIncludeSchema.optional(),
  where: SaleTransactionsWhereInputSchema.optional(),
  orderBy: z.union([ SaleTransactionsOrderByWithRelationInputSchema.array(),SaleTransactionsOrderByWithRelationInputSchema ]).optional(),
  cursor: SaleTransactionsWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ SaleTransactionsScalarFieldEnumSchema,SaleTransactionsScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const SaleTransactionsAggregateArgsSchema: z.ZodType<Prisma.SaleTransactionsAggregateArgs> = z.object({
  where: SaleTransactionsWhereInputSchema.optional(),
  orderBy: z.union([ SaleTransactionsOrderByWithRelationInputSchema.array(),SaleTransactionsOrderByWithRelationInputSchema ]).optional(),
  cursor: SaleTransactionsWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const SaleTransactionsGroupByArgsSchema: z.ZodType<Prisma.SaleTransactionsGroupByArgs> = z.object({
  where: SaleTransactionsWhereInputSchema.optional(),
  orderBy: z.union([ SaleTransactionsOrderByWithAggregationInputSchema.array(),SaleTransactionsOrderByWithAggregationInputSchema ]).optional(),
  by: SaleTransactionsScalarFieldEnumSchema.array(),
  having: SaleTransactionsScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const SaleTransactionsFindUniqueArgsSchema: z.ZodType<Prisma.SaleTransactionsFindUniqueArgs> = z.object({
  select: SaleTransactionsSelectSchema.optional(),
  include: SaleTransactionsIncludeSchema.optional(),
  where: SaleTransactionsWhereUniqueInputSchema,
}).strict() ;

export const SaleTransactionsFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.SaleTransactionsFindUniqueOrThrowArgs> = z.object({
  select: SaleTransactionsSelectSchema.optional(),
  include: SaleTransactionsIncludeSchema.optional(),
  where: SaleTransactionsWhereUniqueInputSchema,
}).strict() ;

export const BlockchainFindFirstArgsSchema: z.ZodType<Prisma.BlockchainFindFirstArgs> = z.object({
  select: BlockchainSelectSchema.optional(),
  include: BlockchainIncludeSchema.optional(),
  where: BlockchainWhereInputSchema.optional(),
  orderBy: z.union([ BlockchainOrderByWithRelationInputSchema.array(),BlockchainOrderByWithRelationInputSchema ]).optional(),
  cursor: BlockchainWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ BlockchainScalarFieldEnumSchema,BlockchainScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const BlockchainFindFirstOrThrowArgsSchema: z.ZodType<Prisma.BlockchainFindFirstOrThrowArgs> = z.object({
  select: BlockchainSelectSchema.optional(),
  include: BlockchainIncludeSchema.optional(),
  where: BlockchainWhereInputSchema.optional(),
  orderBy: z.union([ BlockchainOrderByWithRelationInputSchema.array(),BlockchainOrderByWithRelationInputSchema ]).optional(),
  cursor: BlockchainWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ BlockchainScalarFieldEnumSchema,BlockchainScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const BlockchainFindManyArgsSchema: z.ZodType<Prisma.BlockchainFindManyArgs> = z.object({
  select: BlockchainSelectSchema.optional(),
  include: BlockchainIncludeSchema.optional(),
  where: BlockchainWhereInputSchema.optional(),
  orderBy: z.union([ BlockchainOrderByWithRelationInputSchema.array(),BlockchainOrderByWithRelationInputSchema ]).optional(),
  cursor: BlockchainWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ BlockchainScalarFieldEnumSchema,BlockchainScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const BlockchainAggregateArgsSchema: z.ZodType<Prisma.BlockchainAggregateArgs> = z.object({
  where: BlockchainWhereInputSchema.optional(),
  orderBy: z.union([ BlockchainOrderByWithRelationInputSchema.array(),BlockchainOrderByWithRelationInputSchema ]).optional(),
  cursor: BlockchainWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const BlockchainGroupByArgsSchema: z.ZodType<Prisma.BlockchainGroupByArgs> = z.object({
  where: BlockchainWhereInputSchema.optional(),
  orderBy: z.union([ BlockchainOrderByWithAggregationInputSchema.array(),BlockchainOrderByWithAggregationInputSchema ]).optional(),
  by: BlockchainScalarFieldEnumSchema.array(),
  having: BlockchainScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const BlockchainFindUniqueArgsSchema: z.ZodType<Prisma.BlockchainFindUniqueArgs> = z.object({
  select: BlockchainSelectSchema.optional(),
  include: BlockchainIncludeSchema.optional(),
  where: BlockchainWhereUniqueInputSchema,
}).strict() ;

export const BlockchainFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.BlockchainFindUniqueOrThrowArgs> = z.object({
  select: BlockchainSelectSchema.optional(),
  include: BlockchainIncludeSchema.optional(),
  where: BlockchainWhereUniqueInputSchema,
}).strict() ;

export const ContractStatusFindFirstArgsSchema: z.ZodType<Prisma.ContractStatusFindFirstArgs> = z.object({
  select: ContractStatusSelectSchema.optional(),
  where: ContractStatusWhereInputSchema.optional(),
  orderBy: z.union([ ContractStatusOrderByWithRelationInputSchema.array(),ContractStatusOrderByWithRelationInputSchema ]).optional(),
  cursor: ContractStatusWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ ContractStatusScalarFieldEnumSchema,ContractStatusScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const ContractStatusFindFirstOrThrowArgsSchema: z.ZodType<Prisma.ContractStatusFindFirstOrThrowArgs> = z.object({
  select: ContractStatusSelectSchema.optional(),
  where: ContractStatusWhereInputSchema.optional(),
  orderBy: z.union([ ContractStatusOrderByWithRelationInputSchema.array(),ContractStatusOrderByWithRelationInputSchema ]).optional(),
  cursor: ContractStatusWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ ContractStatusScalarFieldEnumSchema,ContractStatusScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const ContractStatusFindManyArgsSchema: z.ZodType<Prisma.ContractStatusFindManyArgs> = z.object({
  select: ContractStatusSelectSchema.optional(),
  where: ContractStatusWhereInputSchema.optional(),
  orderBy: z.union([ ContractStatusOrderByWithRelationInputSchema.array(),ContractStatusOrderByWithRelationInputSchema ]).optional(),
  cursor: ContractStatusWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ ContractStatusScalarFieldEnumSchema,ContractStatusScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const ContractStatusAggregateArgsSchema: z.ZodType<Prisma.ContractStatusAggregateArgs> = z.object({
  where: ContractStatusWhereInputSchema.optional(),
  orderBy: z.union([ ContractStatusOrderByWithRelationInputSchema.array(),ContractStatusOrderByWithRelationInputSchema ]).optional(),
  cursor: ContractStatusWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const ContractStatusGroupByArgsSchema: z.ZodType<Prisma.ContractStatusGroupByArgs> = z.object({
  where: ContractStatusWhereInputSchema.optional(),
  orderBy: z.union([ ContractStatusOrderByWithAggregationInputSchema.array(),ContractStatusOrderByWithAggregationInputSchema ]).optional(),
  by: ContractStatusScalarFieldEnumSchema.array(),
  having: ContractStatusScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const ContractStatusFindUniqueArgsSchema: z.ZodType<Prisma.ContractStatusFindUniqueArgs> = z.object({
  select: ContractStatusSelectSchema.optional(),
  where: ContractStatusWhereUniqueInputSchema,
}).strict() ;

export const ContractStatusFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.ContractStatusFindUniqueOrThrowArgs> = z.object({
  select: ContractStatusSelectSchema.optional(),
  where: ContractStatusWhereUniqueInputSchema,
}).strict() ;

export const TransactionAuditFindFirstArgsSchema: z.ZodType<Prisma.TransactionAuditFindFirstArgs> = z.object({
  select: TransactionAuditSelectSchema.optional(),
  include: TransactionAuditIncludeSchema.optional(),
  where: TransactionAuditWhereInputSchema.optional(),
  orderBy: z.union([ TransactionAuditOrderByWithRelationInputSchema.array(),TransactionAuditOrderByWithRelationInputSchema ]).optional(),
  cursor: TransactionAuditWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ TransactionAuditScalarFieldEnumSchema,TransactionAuditScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const TransactionAuditFindFirstOrThrowArgsSchema: z.ZodType<Prisma.TransactionAuditFindFirstOrThrowArgs> = z.object({
  select: TransactionAuditSelectSchema.optional(),
  include: TransactionAuditIncludeSchema.optional(),
  where: TransactionAuditWhereInputSchema.optional(),
  orderBy: z.union([ TransactionAuditOrderByWithRelationInputSchema.array(),TransactionAuditOrderByWithRelationInputSchema ]).optional(),
  cursor: TransactionAuditWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ TransactionAuditScalarFieldEnumSchema,TransactionAuditScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const TransactionAuditFindManyArgsSchema: z.ZodType<Prisma.TransactionAuditFindManyArgs> = z.object({
  select: TransactionAuditSelectSchema.optional(),
  include: TransactionAuditIncludeSchema.optional(),
  where: TransactionAuditWhereInputSchema.optional(),
  orderBy: z.union([ TransactionAuditOrderByWithRelationInputSchema.array(),TransactionAuditOrderByWithRelationInputSchema ]).optional(),
  cursor: TransactionAuditWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ TransactionAuditScalarFieldEnumSchema,TransactionAuditScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const TransactionAuditAggregateArgsSchema: z.ZodType<Prisma.TransactionAuditAggregateArgs> = z.object({
  where: TransactionAuditWhereInputSchema.optional(),
  orderBy: z.union([ TransactionAuditOrderByWithRelationInputSchema.array(),TransactionAuditOrderByWithRelationInputSchema ]).optional(),
  cursor: TransactionAuditWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const TransactionAuditGroupByArgsSchema: z.ZodType<Prisma.TransactionAuditGroupByArgs> = z.object({
  where: TransactionAuditWhereInputSchema.optional(),
  orderBy: z.union([ TransactionAuditOrderByWithAggregationInputSchema.array(),TransactionAuditOrderByWithAggregationInputSchema ]).optional(),
  by: TransactionAuditScalarFieldEnumSchema.array(),
  having: TransactionAuditScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const TransactionAuditFindUniqueArgsSchema: z.ZodType<Prisma.TransactionAuditFindUniqueArgs> = z.object({
  select: TransactionAuditSelectSchema.optional(),
  include: TransactionAuditIncludeSchema.optional(),
  where: TransactionAuditWhereUniqueInputSchema,
}).strict() ;

export const TransactionAuditFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.TransactionAuditFindUniqueOrThrowArgs> = z.object({
  select: TransactionAuditSelectSchema.optional(),
  include: TransactionAuditIncludeSchema.optional(),
  where: TransactionAuditWhereUniqueInputSchema,
}).strict() ;

export const KycVerificationFindFirstArgsSchema: z.ZodType<Prisma.KycVerificationFindFirstArgs> = z.object({
  select: KycVerificationSelectSchema.optional(),
  include: KycVerificationIncludeSchema.optional(),
  where: KycVerificationWhereInputSchema.optional(),
  orderBy: z.union([ KycVerificationOrderByWithRelationInputSchema.array(),KycVerificationOrderByWithRelationInputSchema ]).optional(),
  cursor: KycVerificationWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ KycVerificationScalarFieldEnumSchema,KycVerificationScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const KycVerificationFindFirstOrThrowArgsSchema: z.ZodType<Prisma.KycVerificationFindFirstOrThrowArgs> = z.object({
  select: KycVerificationSelectSchema.optional(),
  include: KycVerificationIncludeSchema.optional(),
  where: KycVerificationWhereInputSchema.optional(),
  orderBy: z.union([ KycVerificationOrderByWithRelationInputSchema.array(),KycVerificationOrderByWithRelationInputSchema ]).optional(),
  cursor: KycVerificationWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ KycVerificationScalarFieldEnumSchema,KycVerificationScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const KycVerificationFindManyArgsSchema: z.ZodType<Prisma.KycVerificationFindManyArgs> = z.object({
  select: KycVerificationSelectSchema.optional(),
  include: KycVerificationIncludeSchema.optional(),
  where: KycVerificationWhereInputSchema.optional(),
  orderBy: z.union([ KycVerificationOrderByWithRelationInputSchema.array(),KycVerificationOrderByWithRelationInputSchema ]).optional(),
  cursor: KycVerificationWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ KycVerificationScalarFieldEnumSchema,KycVerificationScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const KycVerificationAggregateArgsSchema: z.ZodType<Prisma.KycVerificationAggregateArgs> = z.object({
  where: KycVerificationWhereInputSchema.optional(),
  orderBy: z.union([ KycVerificationOrderByWithRelationInputSchema.array(),KycVerificationOrderByWithRelationInputSchema ]).optional(),
  cursor: KycVerificationWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const KycVerificationGroupByArgsSchema: z.ZodType<Prisma.KycVerificationGroupByArgs> = z.object({
  where: KycVerificationWhereInputSchema.optional(),
  orderBy: z.union([ KycVerificationOrderByWithAggregationInputSchema.array(),KycVerificationOrderByWithAggregationInputSchema ]).optional(),
  by: KycVerificationScalarFieldEnumSchema.array(),
  having: KycVerificationScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const KycVerificationFindUniqueArgsSchema: z.ZodType<Prisma.KycVerificationFindUniqueArgs> = z.object({
  select: KycVerificationSelectSchema.optional(),
  include: KycVerificationIncludeSchema.optional(),
  where: KycVerificationWhereUniqueInputSchema,
}).strict() ;

export const KycVerificationFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.KycVerificationFindUniqueOrThrowArgs> = z.object({
  select: KycVerificationSelectSchema.optional(),
  include: KycVerificationIncludeSchema.optional(),
  where: KycVerificationWhereUniqueInputSchema,
}).strict() ;

export const RoleFindFirstArgsSchema: z.ZodType<Prisma.RoleFindFirstArgs> = z.object({
  select: RoleSelectSchema.optional(),
  include: RoleIncludeSchema.optional(),
  where: RoleWhereInputSchema.optional(),
  orderBy: z.union([ RoleOrderByWithRelationInputSchema.array(),RoleOrderByWithRelationInputSchema ]).optional(),
  cursor: RoleWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ RoleScalarFieldEnumSchema,RoleScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const RoleFindFirstOrThrowArgsSchema: z.ZodType<Prisma.RoleFindFirstOrThrowArgs> = z.object({
  select: RoleSelectSchema.optional(),
  include: RoleIncludeSchema.optional(),
  where: RoleWhereInputSchema.optional(),
  orderBy: z.union([ RoleOrderByWithRelationInputSchema.array(),RoleOrderByWithRelationInputSchema ]).optional(),
  cursor: RoleWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ RoleScalarFieldEnumSchema,RoleScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const RoleFindManyArgsSchema: z.ZodType<Prisma.RoleFindManyArgs> = z.object({
  select: RoleSelectSchema.optional(),
  include: RoleIncludeSchema.optional(),
  where: RoleWhereInputSchema.optional(),
  orderBy: z.union([ RoleOrderByWithRelationInputSchema.array(),RoleOrderByWithRelationInputSchema ]).optional(),
  cursor: RoleWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ RoleScalarFieldEnumSchema,RoleScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const RoleAggregateArgsSchema: z.ZodType<Prisma.RoleAggregateArgs> = z.object({
  where: RoleWhereInputSchema.optional(),
  orderBy: z.union([ RoleOrderByWithRelationInputSchema.array(),RoleOrderByWithRelationInputSchema ]).optional(),
  cursor: RoleWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const RoleGroupByArgsSchema: z.ZodType<Prisma.RoleGroupByArgs> = z.object({
  where: RoleWhereInputSchema.optional(),
  orderBy: z.union([ RoleOrderByWithAggregationInputSchema.array(),RoleOrderByWithAggregationInputSchema ]).optional(),
  by: RoleScalarFieldEnumSchema.array(),
  having: RoleScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const RoleFindUniqueArgsSchema: z.ZodType<Prisma.RoleFindUniqueArgs> = z.object({
  select: RoleSelectSchema.optional(),
  include: RoleIncludeSchema.optional(),
  where: RoleWhereUniqueInputSchema,
}).strict() ;

export const RoleFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.RoleFindUniqueOrThrowArgs> = z.object({
  select: RoleSelectSchema.optional(),
  include: RoleIncludeSchema.optional(),
  where: RoleWhereUniqueInputSchema,
}).strict() ;

export const UserRoleFindFirstArgsSchema: z.ZodType<Prisma.UserRoleFindFirstArgs> = z.object({
  select: UserRoleSelectSchema.optional(),
  include: UserRoleIncludeSchema.optional(),
  where: UserRoleWhereInputSchema.optional(),
  orderBy: z.union([ UserRoleOrderByWithRelationInputSchema.array(),UserRoleOrderByWithRelationInputSchema ]).optional(),
  cursor: UserRoleWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ UserRoleScalarFieldEnumSchema,UserRoleScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const UserRoleFindFirstOrThrowArgsSchema: z.ZodType<Prisma.UserRoleFindFirstOrThrowArgs> = z.object({
  select: UserRoleSelectSchema.optional(),
  include: UserRoleIncludeSchema.optional(),
  where: UserRoleWhereInputSchema.optional(),
  orderBy: z.union([ UserRoleOrderByWithRelationInputSchema.array(),UserRoleOrderByWithRelationInputSchema ]).optional(),
  cursor: UserRoleWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ UserRoleScalarFieldEnumSchema,UserRoleScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const UserRoleFindManyArgsSchema: z.ZodType<Prisma.UserRoleFindManyArgs> = z.object({
  select: UserRoleSelectSchema.optional(),
  include: UserRoleIncludeSchema.optional(),
  where: UserRoleWhereInputSchema.optional(),
  orderBy: z.union([ UserRoleOrderByWithRelationInputSchema.array(),UserRoleOrderByWithRelationInputSchema ]).optional(),
  cursor: UserRoleWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ UserRoleScalarFieldEnumSchema,UserRoleScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const UserRoleAggregateArgsSchema: z.ZodType<Prisma.UserRoleAggregateArgs> = z.object({
  where: UserRoleWhereInputSchema.optional(),
  orderBy: z.union([ UserRoleOrderByWithRelationInputSchema.array(),UserRoleOrderByWithRelationInputSchema ]).optional(),
  cursor: UserRoleWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const UserRoleGroupByArgsSchema: z.ZodType<Prisma.UserRoleGroupByArgs> = z.object({
  where: UserRoleWhereInputSchema.optional(),
  orderBy: z.union([ UserRoleOrderByWithAggregationInputSchema.array(),UserRoleOrderByWithAggregationInputSchema ]).optional(),
  by: UserRoleScalarFieldEnumSchema.array(),
  having: UserRoleScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const UserRoleFindUniqueArgsSchema: z.ZodType<Prisma.UserRoleFindUniqueArgs> = z.object({
  select: UserRoleSelectSchema.optional(),
  include: UserRoleIncludeSchema.optional(),
  where: UserRoleWhereUniqueInputSchema,
}).strict() ;

export const UserRoleFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.UserRoleFindUniqueOrThrowArgs> = z.object({
  select: UserRoleSelectSchema.optional(),
  include: UserRoleIncludeSchema.optional(),
  where: UserRoleWhereUniqueInputSchema,
}).strict() ;

export const TokenFindFirstArgsSchema: z.ZodType<Prisma.TokenFindFirstArgs> = z.object({
  select: TokenSelectSchema.optional(),
  include: TokenIncludeSchema.optional(),
  where: TokenWhereInputSchema.optional(),
  orderBy: z.union([ TokenOrderByWithRelationInputSchema.array(),TokenOrderByWithRelationInputSchema ]).optional(),
  cursor: TokenWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ TokenScalarFieldEnumSchema,TokenScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const TokenFindFirstOrThrowArgsSchema: z.ZodType<Prisma.TokenFindFirstOrThrowArgs> = z.object({
  select: TokenSelectSchema.optional(),
  include: TokenIncludeSchema.optional(),
  where: TokenWhereInputSchema.optional(),
  orderBy: z.union([ TokenOrderByWithRelationInputSchema.array(),TokenOrderByWithRelationInputSchema ]).optional(),
  cursor: TokenWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ TokenScalarFieldEnumSchema,TokenScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const TokenFindManyArgsSchema: z.ZodType<Prisma.TokenFindManyArgs> = z.object({
  select: TokenSelectSchema.optional(),
  include: TokenIncludeSchema.optional(),
  where: TokenWhereInputSchema.optional(),
  orderBy: z.union([ TokenOrderByWithRelationInputSchema.array(),TokenOrderByWithRelationInputSchema ]).optional(),
  cursor: TokenWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ TokenScalarFieldEnumSchema,TokenScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const TokenAggregateArgsSchema: z.ZodType<Prisma.TokenAggregateArgs> = z.object({
  where: TokenWhereInputSchema.optional(),
  orderBy: z.union([ TokenOrderByWithRelationInputSchema.array(),TokenOrderByWithRelationInputSchema ]).optional(),
  cursor: TokenWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const TokenGroupByArgsSchema: z.ZodType<Prisma.TokenGroupByArgs> = z.object({
  where: TokenWhereInputSchema.optional(),
  orderBy: z.union([ TokenOrderByWithAggregationInputSchema.array(),TokenOrderByWithAggregationInputSchema ]).optional(),
  by: TokenScalarFieldEnumSchema.array(),
  having: TokenScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const TokenFindUniqueArgsSchema: z.ZodType<Prisma.TokenFindUniqueArgs> = z.object({
  select: TokenSelectSchema.optional(),
  include: TokenIncludeSchema.optional(),
  where: TokenWhereUniqueInputSchema,
}).strict() ;

export const TokenFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.TokenFindUniqueOrThrowArgs> = z.object({
  select: TokenSelectSchema.optional(),
  include: TokenIncludeSchema.optional(),
  where: TokenWhereUniqueInputSchema,
}).strict() ;

export const TokensOnBlockchainsFindFirstArgsSchema: z.ZodType<Prisma.TokensOnBlockchainsFindFirstArgs> = z.object({
  select: TokensOnBlockchainsSelectSchema.optional(),
  include: TokensOnBlockchainsIncludeSchema.optional(),
  where: TokensOnBlockchainsWhereInputSchema.optional(),
  orderBy: z.union([ TokensOnBlockchainsOrderByWithRelationInputSchema.array(),TokensOnBlockchainsOrderByWithRelationInputSchema ]).optional(),
  cursor: TokensOnBlockchainsWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ TokensOnBlockchainsScalarFieldEnumSchema,TokensOnBlockchainsScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const TokensOnBlockchainsFindFirstOrThrowArgsSchema: z.ZodType<Prisma.TokensOnBlockchainsFindFirstOrThrowArgs> = z.object({
  select: TokensOnBlockchainsSelectSchema.optional(),
  include: TokensOnBlockchainsIncludeSchema.optional(),
  where: TokensOnBlockchainsWhereInputSchema.optional(),
  orderBy: z.union([ TokensOnBlockchainsOrderByWithRelationInputSchema.array(),TokensOnBlockchainsOrderByWithRelationInputSchema ]).optional(),
  cursor: TokensOnBlockchainsWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ TokensOnBlockchainsScalarFieldEnumSchema,TokensOnBlockchainsScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const TokensOnBlockchainsFindManyArgsSchema: z.ZodType<Prisma.TokensOnBlockchainsFindManyArgs> = z.object({
  select: TokensOnBlockchainsSelectSchema.optional(),
  include: TokensOnBlockchainsIncludeSchema.optional(),
  where: TokensOnBlockchainsWhereInputSchema.optional(),
  orderBy: z.union([ TokensOnBlockchainsOrderByWithRelationInputSchema.array(),TokensOnBlockchainsOrderByWithRelationInputSchema ]).optional(),
  cursor: TokensOnBlockchainsWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
  distinct: z.union([ TokensOnBlockchainsScalarFieldEnumSchema,TokensOnBlockchainsScalarFieldEnumSchema.array() ]).optional(),
}).strict() ;

export const TokensOnBlockchainsAggregateArgsSchema: z.ZodType<Prisma.TokensOnBlockchainsAggregateArgs> = z.object({
  where: TokensOnBlockchainsWhereInputSchema.optional(),
  orderBy: z.union([ TokensOnBlockchainsOrderByWithRelationInputSchema.array(),TokensOnBlockchainsOrderByWithRelationInputSchema ]).optional(),
  cursor: TokensOnBlockchainsWhereUniqueInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const TokensOnBlockchainsGroupByArgsSchema: z.ZodType<Prisma.TokensOnBlockchainsGroupByArgs> = z.object({
  where: TokensOnBlockchainsWhereInputSchema.optional(),
  orderBy: z.union([ TokensOnBlockchainsOrderByWithAggregationInputSchema.array(),TokensOnBlockchainsOrderByWithAggregationInputSchema ]).optional(),
  by: TokensOnBlockchainsScalarFieldEnumSchema.array(),
  having: TokensOnBlockchainsScalarWhereWithAggregatesInputSchema.optional(),
  take: z.number().optional(),
  skip: z.number().optional(),
}).strict() ;

export const TokensOnBlockchainsFindUniqueArgsSchema: z.ZodType<Prisma.TokensOnBlockchainsFindUniqueArgs> = z.object({
  select: TokensOnBlockchainsSelectSchema.optional(),
  include: TokensOnBlockchainsIncludeSchema.optional(),
  where: TokensOnBlockchainsWhereUniqueInputSchema,
}).strict() ;

export const TokensOnBlockchainsFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.TokensOnBlockchainsFindUniqueOrThrowArgs> = z.object({
  select: TokensOnBlockchainsSelectSchema.optional(),
  include: TokensOnBlockchainsIncludeSchema.optional(),
  where: TokensOnBlockchainsWhereUniqueInputSchema,
}).strict() ;

export const UserCreateArgsSchema: z.ZodType<Prisma.UserCreateArgs> = z.object({
  select: UserSelectSchema.optional(),
  include: UserIncludeSchema.optional(),
  data: z.union([ UserCreateInputSchema,UserUncheckedCreateInputSchema ]),
}).strict() ;

export const UserUpsertArgsSchema: z.ZodType<Prisma.UserUpsertArgs> = z.object({
  select: UserSelectSchema.optional(),
  include: UserIncludeSchema.optional(),
  where: UserWhereUniqueInputSchema,
  create: z.union([ UserCreateInputSchema,UserUncheckedCreateInputSchema ]),
  update: z.union([ UserUpdateInputSchema,UserUncheckedUpdateInputSchema ]),
}).strict() ;

export const UserCreateManyArgsSchema: z.ZodType<Prisma.UserCreateManyArgs> = z.object({
  data: z.union([ UserCreateManyInputSchema,UserCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const UserCreateManyAndReturnArgsSchema: z.ZodType<Prisma.UserCreateManyAndReturnArgs> = z.object({
  data: z.union([ UserCreateManyInputSchema,UserCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const UserDeleteArgsSchema: z.ZodType<Prisma.UserDeleteArgs> = z.object({
  select: UserSelectSchema.optional(),
  include: UserIncludeSchema.optional(),
  where: UserWhereUniqueInputSchema,
}).strict() ;

export const UserUpdateArgsSchema: z.ZodType<Prisma.UserUpdateArgs> = z.object({
  select: UserSelectSchema.optional(),
  include: UserIncludeSchema.optional(),
  data: z.union([ UserUpdateInputSchema,UserUncheckedUpdateInputSchema ]),
  where: UserWhereUniqueInputSchema,
}).strict() ;

export const UserUpdateManyArgsSchema: z.ZodType<Prisma.UserUpdateManyArgs> = z.object({
  data: z.union([ UserUpdateManyMutationInputSchema,UserUncheckedUpdateManyInputSchema ]),
  where: UserWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const UserUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.UserUpdateManyAndReturnArgs> = z.object({
  data: z.union([ UserUpdateManyMutationInputSchema,UserUncheckedUpdateManyInputSchema ]),
  where: UserWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const UserDeleteManyArgsSchema: z.ZodType<Prisma.UserDeleteManyArgs> = z.object({
  where: UserWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const WalletAddressCreateArgsSchema: z.ZodType<Prisma.WalletAddressCreateArgs> = z.object({
  select: WalletAddressSelectSchema.optional(),
  include: WalletAddressIncludeSchema.optional(),
  data: z.union([ WalletAddressCreateInputSchema,WalletAddressUncheckedCreateInputSchema ]),
}).strict() ;

export const WalletAddressUpsertArgsSchema: z.ZodType<Prisma.WalletAddressUpsertArgs> = z.object({
  select: WalletAddressSelectSchema.optional(),
  include: WalletAddressIncludeSchema.optional(),
  where: WalletAddressWhereUniqueInputSchema,
  create: z.union([ WalletAddressCreateInputSchema,WalletAddressUncheckedCreateInputSchema ]),
  update: z.union([ WalletAddressUpdateInputSchema,WalletAddressUncheckedUpdateInputSchema ]),
}).strict() ;

export const WalletAddressCreateManyArgsSchema: z.ZodType<Prisma.WalletAddressCreateManyArgs> = z.object({
  data: z.union([ WalletAddressCreateManyInputSchema,WalletAddressCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const WalletAddressCreateManyAndReturnArgsSchema: z.ZodType<Prisma.WalletAddressCreateManyAndReturnArgs> = z.object({
  data: z.union([ WalletAddressCreateManyInputSchema,WalletAddressCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const WalletAddressDeleteArgsSchema: z.ZodType<Prisma.WalletAddressDeleteArgs> = z.object({
  select: WalletAddressSelectSchema.optional(),
  include: WalletAddressIncludeSchema.optional(),
  where: WalletAddressWhereUniqueInputSchema,
}).strict() ;

export const WalletAddressUpdateArgsSchema: z.ZodType<Prisma.WalletAddressUpdateArgs> = z.object({
  select: WalletAddressSelectSchema.optional(),
  include: WalletAddressIncludeSchema.optional(),
  data: z.union([ WalletAddressUpdateInputSchema,WalletAddressUncheckedUpdateInputSchema ]),
  where: WalletAddressWhereUniqueInputSchema,
}).strict() ;

export const WalletAddressUpdateManyArgsSchema: z.ZodType<Prisma.WalletAddressUpdateManyArgs> = z.object({
  data: z.union([ WalletAddressUpdateManyMutationInputSchema,WalletAddressUncheckedUpdateManyInputSchema ]),
  where: WalletAddressWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const WalletAddressUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.WalletAddressUpdateManyAndReturnArgs> = z.object({
  data: z.union([ WalletAddressUpdateManyMutationInputSchema,WalletAddressUncheckedUpdateManyInputSchema ]),
  where: WalletAddressWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const WalletAddressDeleteManyArgsSchema: z.ZodType<Prisma.WalletAddressDeleteManyArgs> = z.object({
  where: WalletAddressWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const SessionCreateArgsSchema: z.ZodType<Prisma.SessionCreateArgs> = z.object({
  select: SessionSelectSchema.optional(),
  include: SessionIncludeSchema.optional(),
  data: z.union([ SessionCreateInputSchema,SessionUncheckedCreateInputSchema ]),
}).strict() ;

export const SessionUpsertArgsSchema: z.ZodType<Prisma.SessionUpsertArgs> = z.object({
  select: SessionSelectSchema.optional(),
  include: SessionIncludeSchema.optional(),
  where: SessionWhereUniqueInputSchema,
  create: z.union([ SessionCreateInputSchema,SessionUncheckedCreateInputSchema ]),
  update: z.union([ SessionUpdateInputSchema,SessionUncheckedUpdateInputSchema ]),
}).strict() ;

export const SessionCreateManyArgsSchema: z.ZodType<Prisma.SessionCreateManyArgs> = z.object({
  data: z.union([ SessionCreateManyInputSchema,SessionCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const SessionCreateManyAndReturnArgsSchema: z.ZodType<Prisma.SessionCreateManyAndReturnArgs> = z.object({
  data: z.union([ SessionCreateManyInputSchema,SessionCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const SessionDeleteArgsSchema: z.ZodType<Prisma.SessionDeleteArgs> = z.object({
  select: SessionSelectSchema.optional(),
  include: SessionIncludeSchema.optional(),
  where: SessionWhereUniqueInputSchema,
}).strict() ;

export const SessionUpdateArgsSchema: z.ZodType<Prisma.SessionUpdateArgs> = z.object({
  select: SessionSelectSchema.optional(),
  include: SessionIncludeSchema.optional(),
  data: z.union([ SessionUpdateInputSchema,SessionUncheckedUpdateInputSchema ]),
  where: SessionWhereUniqueInputSchema,
}).strict() ;

export const SessionUpdateManyArgsSchema: z.ZodType<Prisma.SessionUpdateManyArgs> = z.object({
  data: z.union([ SessionUpdateManyMutationInputSchema,SessionUncheckedUpdateManyInputSchema ]),
  where: SessionWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const SessionUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.SessionUpdateManyAndReturnArgs> = z.object({
  data: z.union([ SessionUpdateManyMutationInputSchema,SessionUncheckedUpdateManyInputSchema ]),
  where: SessionWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const SessionDeleteManyArgsSchema: z.ZodType<Prisma.SessionDeleteManyArgs> = z.object({
  where: SessionWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const VerificationCreateArgsSchema: z.ZodType<Prisma.VerificationCreateArgs> = z.object({
  select: VerificationSelectSchema.optional(),
  data: z.union([ VerificationCreateInputSchema,VerificationUncheckedCreateInputSchema ]),
}).strict() ;

export const VerificationUpsertArgsSchema: z.ZodType<Prisma.VerificationUpsertArgs> = z.object({
  select: VerificationSelectSchema.optional(),
  where: VerificationWhereUniqueInputSchema,
  create: z.union([ VerificationCreateInputSchema,VerificationUncheckedCreateInputSchema ]),
  update: z.union([ VerificationUpdateInputSchema,VerificationUncheckedUpdateInputSchema ]),
}).strict() ;

export const VerificationCreateManyArgsSchema: z.ZodType<Prisma.VerificationCreateManyArgs> = z.object({
  data: z.union([ VerificationCreateManyInputSchema,VerificationCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const VerificationCreateManyAndReturnArgsSchema: z.ZodType<Prisma.VerificationCreateManyAndReturnArgs> = z.object({
  data: z.union([ VerificationCreateManyInputSchema,VerificationCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const VerificationDeleteArgsSchema: z.ZodType<Prisma.VerificationDeleteArgs> = z.object({
  select: VerificationSelectSchema.optional(),
  where: VerificationWhereUniqueInputSchema,
}).strict() ;

export const VerificationUpdateArgsSchema: z.ZodType<Prisma.VerificationUpdateArgs> = z.object({
  select: VerificationSelectSchema.optional(),
  data: z.union([ VerificationUpdateInputSchema,VerificationUncheckedUpdateInputSchema ]),
  where: VerificationWhereUniqueInputSchema,
}).strict() ;

export const VerificationUpdateManyArgsSchema: z.ZodType<Prisma.VerificationUpdateManyArgs> = z.object({
  data: z.union([ VerificationUpdateManyMutationInputSchema,VerificationUncheckedUpdateManyInputSchema ]),
  where: VerificationWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const VerificationUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.VerificationUpdateManyAndReturnArgs> = z.object({
  data: z.union([ VerificationUpdateManyMutationInputSchema,VerificationUncheckedUpdateManyInputSchema ]),
  where: VerificationWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const VerificationDeleteManyArgsSchema: z.ZodType<Prisma.VerificationDeleteManyArgs> = z.object({
  where: VerificationWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const ProfileCreateArgsSchema: z.ZodType<Prisma.ProfileCreateArgs> = z.object({
  select: ProfileSelectSchema.optional(),
  include: ProfileIncludeSchema.optional(),
  data: z.union([ ProfileCreateInputSchema,ProfileUncheckedCreateInputSchema ]),
}).strict() ;

export const ProfileUpsertArgsSchema: z.ZodType<Prisma.ProfileUpsertArgs> = z.object({
  select: ProfileSelectSchema.optional(),
  include: ProfileIncludeSchema.optional(),
  where: ProfileWhereUniqueInputSchema,
  create: z.union([ ProfileCreateInputSchema,ProfileUncheckedCreateInputSchema ]),
  update: z.union([ ProfileUpdateInputSchema,ProfileUncheckedUpdateInputSchema ]),
}).strict() ;

export const ProfileCreateManyArgsSchema: z.ZodType<Prisma.ProfileCreateManyArgs> = z.object({
  data: z.union([ ProfileCreateManyInputSchema,ProfileCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const ProfileCreateManyAndReturnArgsSchema: z.ZodType<Prisma.ProfileCreateManyAndReturnArgs> = z.object({
  data: z.union([ ProfileCreateManyInputSchema,ProfileCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const ProfileDeleteArgsSchema: z.ZodType<Prisma.ProfileDeleteArgs> = z.object({
  select: ProfileSelectSchema.optional(),
  include: ProfileIncludeSchema.optional(),
  where: ProfileWhereUniqueInputSchema,
}).strict() ;

export const ProfileUpdateArgsSchema: z.ZodType<Prisma.ProfileUpdateArgs> = z.object({
  select: ProfileSelectSchema.optional(),
  include: ProfileIncludeSchema.optional(),
  data: z.union([ ProfileUpdateInputSchema,ProfileUncheckedUpdateInputSchema ]),
  where: ProfileWhereUniqueInputSchema,
}).strict() ;

export const ProfileUpdateManyArgsSchema: z.ZodType<Prisma.ProfileUpdateManyArgs> = z.object({
  data: z.union([ ProfileUpdateManyMutationInputSchema,ProfileUncheckedUpdateManyInputSchema ]),
  where: ProfileWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const ProfileUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.ProfileUpdateManyAndReturnArgs> = z.object({
  data: z.union([ ProfileUpdateManyMutationInputSchema,ProfileUncheckedUpdateManyInputSchema ]),
  where: ProfileWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const ProfileDeleteManyArgsSchema: z.ZodType<Prisma.ProfileDeleteManyArgs> = z.object({
  where: ProfileWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const AddressCreateArgsSchema: z.ZodType<Prisma.AddressCreateArgs> = z.object({
  select: AddressSelectSchema.optional(),
  include: AddressIncludeSchema.optional(),
  data: z.union([ AddressCreateInputSchema,AddressUncheckedCreateInputSchema ]),
}).strict() ;

export const AddressUpsertArgsSchema: z.ZodType<Prisma.AddressUpsertArgs> = z.object({
  select: AddressSelectSchema.optional(),
  include: AddressIncludeSchema.optional(),
  where: AddressWhereUniqueInputSchema,
  create: z.union([ AddressCreateInputSchema,AddressUncheckedCreateInputSchema ]),
  update: z.union([ AddressUpdateInputSchema,AddressUncheckedUpdateInputSchema ]),
}).strict() ;

export const AddressCreateManyArgsSchema: z.ZodType<Prisma.AddressCreateManyArgs> = z.object({
  data: z.union([ AddressCreateManyInputSchema,AddressCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const AddressCreateManyAndReturnArgsSchema: z.ZodType<Prisma.AddressCreateManyAndReturnArgs> = z.object({
  data: z.union([ AddressCreateManyInputSchema,AddressCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const AddressDeleteArgsSchema: z.ZodType<Prisma.AddressDeleteArgs> = z.object({
  select: AddressSelectSchema.optional(),
  include: AddressIncludeSchema.optional(),
  where: AddressWhereUniqueInputSchema,
}).strict() ;

export const AddressUpdateArgsSchema: z.ZodType<Prisma.AddressUpdateArgs> = z.object({
  select: AddressSelectSchema.optional(),
  include: AddressIncludeSchema.optional(),
  data: z.union([ AddressUpdateInputSchema,AddressUncheckedUpdateInputSchema ]),
  where: AddressWhereUniqueInputSchema,
}).strict() ;

export const AddressUpdateManyArgsSchema: z.ZodType<Prisma.AddressUpdateManyArgs> = z.object({
  data: z.union([ AddressUpdateManyMutationInputSchema,AddressUncheckedUpdateManyInputSchema ]),
  where: AddressWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const AddressUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.AddressUpdateManyAndReturnArgs> = z.object({
  data: z.union([ AddressUpdateManyMutationInputSchema,AddressUncheckedUpdateManyInputSchema ]),
  where: AddressWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const AddressDeleteManyArgsSchema: z.ZodType<Prisma.AddressDeleteManyArgs> = z.object({
  where: AddressWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const SaleCreateArgsSchema: z.ZodType<Prisma.SaleCreateArgs> = z.object({
  select: SaleSelectSchema.optional(),
  include: SaleIncludeSchema.optional(),
  data: z.union([ SaleCreateInputSchema,SaleUncheckedCreateInputSchema ]),
}).strict() ;

export const SaleUpsertArgsSchema: z.ZodType<Prisma.SaleUpsertArgs> = z.object({
  select: SaleSelectSchema.optional(),
  include: SaleIncludeSchema.optional(),
  where: SaleWhereUniqueInputSchema,
  create: z.union([ SaleCreateInputSchema,SaleUncheckedCreateInputSchema ]),
  update: z.union([ SaleUpdateInputSchema,SaleUncheckedUpdateInputSchema ]),
}).strict() ;

export const SaleCreateManyArgsSchema: z.ZodType<Prisma.SaleCreateManyArgs> = z.object({
  data: z.union([ SaleCreateManyInputSchema,SaleCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const SaleCreateManyAndReturnArgsSchema: z.ZodType<Prisma.SaleCreateManyAndReturnArgs> = z.object({
  data: z.union([ SaleCreateManyInputSchema,SaleCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const SaleDeleteArgsSchema: z.ZodType<Prisma.SaleDeleteArgs> = z.object({
  select: SaleSelectSchema.optional(),
  include: SaleIncludeSchema.optional(),
  where: SaleWhereUniqueInputSchema,
}).strict() ;

export const SaleUpdateArgsSchema: z.ZodType<Prisma.SaleUpdateArgs> = z.object({
  select: SaleSelectSchema.optional(),
  include: SaleIncludeSchema.optional(),
  data: z.union([ SaleUpdateInputSchema,SaleUncheckedUpdateInputSchema ]),
  where: SaleWhereUniqueInputSchema,
}).strict() ;

export const SaleUpdateManyArgsSchema: z.ZodType<Prisma.SaleUpdateManyArgs> = z.object({
  data: z.union([ SaleUpdateManyMutationInputSchema,SaleUncheckedUpdateManyInputSchema ]),
  where: SaleWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const SaleUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.SaleUpdateManyAndReturnArgs> = z.object({
  data: z.union([ SaleUpdateManyMutationInputSchema,SaleUncheckedUpdateManyInputSchema ]),
  where: SaleWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const SaleDeleteManyArgsSchema: z.ZodType<Prisma.SaleDeleteManyArgs> = z.object({
  where: SaleWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const DocumentCreateArgsSchema: z.ZodType<Prisma.DocumentCreateArgs> = z.object({
  select: DocumentSelectSchema.optional(),
  include: DocumentIncludeSchema.optional(),
  data: z.union([ DocumentCreateInputSchema,DocumentUncheckedCreateInputSchema ]),
}).strict() ;

export const DocumentUpsertArgsSchema: z.ZodType<Prisma.DocumentUpsertArgs> = z.object({
  select: DocumentSelectSchema.optional(),
  include: DocumentIncludeSchema.optional(),
  where: DocumentWhereUniqueInputSchema,
  create: z.union([ DocumentCreateInputSchema,DocumentUncheckedCreateInputSchema ]),
  update: z.union([ DocumentUpdateInputSchema,DocumentUncheckedUpdateInputSchema ]),
}).strict() ;

export const DocumentCreateManyArgsSchema: z.ZodType<Prisma.DocumentCreateManyArgs> = z.object({
  data: z.union([ DocumentCreateManyInputSchema,DocumentCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const DocumentCreateManyAndReturnArgsSchema: z.ZodType<Prisma.DocumentCreateManyAndReturnArgs> = z.object({
  data: z.union([ DocumentCreateManyInputSchema,DocumentCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const DocumentDeleteArgsSchema: z.ZodType<Prisma.DocumentDeleteArgs> = z.object({
  select: DocumentSelectSchema.optional(),
  include: DocumentIncludeSchema.optional(),
  where: DocumentWhereUniqueInputSchema,
}).strict() ;

export const DocumentUpdateArgsSchema: z.ZodType<Prisma.DocumentUpdateArgs> = z.object({
  select: DocumentSelectSchema.optional(),
  include: DocumentIncludeSchema.optional(),
  data: z.union([ DocumentUpdateInputSchema,DocumentUncheckedUpdateInputSchema ]),
  where: DocumentWhereUniqueInputSchema,
}).strict() ;

export const DocumentUpdateManyArgsSchema: z.ZodType<Prisma.DocumentUpdateManyArgs> = z.object({
  data: z.union([ DocumentUpdateManyMutationInputSchema,DocumentUncheckedUpdateManyInputSchema ]),
  where: DocumentWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const DocumentUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.DocumentUpdateManyAndReturnArgs> = z.object({
  data: z.union([ DocumentUpdateManyMutationInputSchema,DocumentUncheckedUpdateManyInputSchema ]),
  where: DocumentWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const DocumentDeleteManyArgsSchema: z.ZodType<Prisma.DocumentDeleteManyArgs> = z.object({
  where: DocumentWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const VestingScheduleCreateArgsSchema: z.ZodType<Prisma.VestingScheduleCreateArgs> = z.object({
  select: VestingScheduleSelectSchema.optional(),
  include: VestingScheduleIncludeSchema.optional(),
  data: z.union([ VestingScheduleCreateInputSchema,VestingScheduleUncheckedCreateInputSchema ]),
}).strict() ;

export const VestingScheduleUpsertArgsSchema: z.ZodType<Prisma.VestingScheduleUpsertArgs> = z.object({
  select: VestingScheduleSelectSchema.optional(),
  include: VestingScheduleIncludeSchema.optional(),
  where: VestingScheduleWhereUniqueInputSchema,
  create: z.union([ VestingScheduleCreateInputSchema,VestingScheduleUncheckedCreateInputSchema ]),
  update: z.union([ VestingScheduleUpdateInputSchema,VestingScheduleUncheckedUpdateInputSchema ]),
}).strict() ;

export const VestingScheduleCreateManyArgsSchema: z.ZodType<Prisma.VestingScheduleCreateManyArgs> = z.object({
  data: z.union([ VestingScheduleCreateManyInputSchema,VestingScheduleCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const VestingScheduleCreateManyAndReturnArgsSchema: z.ZodType<Prisma.VestingScheduleCreateManyAndReturnArgs> = z.object({
  data: z.union([ VestingScheduleCreateManyInputSchema,VestingScheduleCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const VestingScheduleDeleteArgsSchema: z.ZodType<Prisma.VestingScheduleDeleteArgs> = z.object({
  select: VestingScheduleSelectSchema.optional(),
  include: VestingScheduleIncludeSchema.optional(),
  where: VestingScheduleWhereUniqueInputSchema,
}).strict() ;

export const VestingScheduleUpdateArgsSchema: z.ZodType<Prisma.VestingScheduleUpdateArgs> = z.object({
  select: VestingScheduleSelectSchema.optional(),
  include: VestingScheduleIncludeSchema.optional(),
  data: z.union([ VestingScheduleUpdateInputSchema,VestingScheduleUncheckedUpdateInputSchema ]),
  where: VestingScheduleWhereUniqueInputSchema,
}).strict() ;

export const VestingScheduleUpdateManyArgsSchema: z.ZodType<Prisma.VestingScheduleUpdateManyArgs> = z.object({
  data: z.union([ VestingScheduleUpdateManyMutationInputSchema,VestingScheduleUncheckedUpdateManyInputSchema ]),
  where: VestingScheduleWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const VestingScheduleUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.VestingScheduleUpdateManyAndReturnArgs> = z.object({
  data: z.union([ VestingScheduleUpdateManyMutationInputSchema,VestingScheduleUncheckedUpdateManyInputSchema ]),
  where: VestingScheduleWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const VestingScheduleDeleteManyArgsSchema: z.ZodType<Prisma.VestingScheduleDeleteManyArgs> = z.object({
  where: VestingScheduleWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const TokenDistributionCreateArgsSchema: z.ZodType<Prisma.TokenDistributionCreateArgs> = z.object({
  select: TokenDistributionSelectSchema.optional(),
  include: TokenDistributionIncludeSchema.optional(),
  data: z.union([ TokenDistributionCreateInputSchema,TokenDistributionUncheckedCreateInputSchema ]),
}).strict() ;

export const TokenDistributionUpsertArgsSchema: z.ZodType<Prisma.TokenDistributionUpsertArgs> = z.object({
  select: TokenDistributionSelectSchema.optional(),
  include: TokenDistributionIncludeSchema.optional(),
  where: TokenDistributionWhereUniqueInputSchema,
  create: z.union([ TokenDistributionCreateInputSchema,TokenDistributionUncheckedCreateInputSchema ]),
  update: z.union([ TokenDistributionUpdateInputSchema,TokenDistributionUncheckedUpdateInputSchema ]),
}).strict() ;

export const TokenDistributionCreateManyArgsSchema: z.ZodType<Prisma.TokenDistributionCreateManyArgs> = z.object({
  data: z.union([ TokenDistributionCreateManyInputSchema,TokenDistributionCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const TokenDistributionCreateManyAndReturnArgsSchema: z.ZodType<Prisma.TokenDistributionCreateManyAndReturnArgs> = z.object({
  data: z.union([ TokenDistributionCreateManyInputSchema,TokenDistributionCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const TokenDistributionDeleteArgsSchema: z.ZodType<Prisma.TokenDistributionDeleteArgs> = z.object({
  select: TokenDistributionSelectSchema.optional(),
  include: TokenDistributionIncludeSchema.optional(),
  where: TokenDistributionWhereUniqueInputSchema,
}).strict() ;

export const TokenDistributionUpdateArgsSchema: z.ZodType<Prisma.TokenDistributionUpdateArgs> = z.object({
  select: TokenDistributionSelectSchema.optional(),
  include: TokenDistributionIncludeSchema.optional(),
  data: z.union([ TokenDistributionUpdateInputSchema,TokenDistributionUncheckedUpdateInputSchema ]),
  where: TokenDistributionWhereUniqueInputSchema,
}).strict() ;

export const TokenDistributionUpdateManyArgsSchema: z.ZodType<Prisma.TokenDistributionUpdateManyArgs> = z.object({
  data: z.union([ TokenDistributionUpdateManyMutationInputSchema,TokenDistributionUncheckedUpdateManyInputSchema ]),
  where: TokenDistributionWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const TokenDistributionUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.TokenDistributionUpdateManyAndReturnArgs> = z.object({
  data: z.union([ TokenDistributionUpdateManyMutationInputSchema,TokenDistributionUncheckedUpdateManyInputSchema ]),
  where: TokenDistributionWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const TokenDistributionDeleteManyArgsSchema: z.ZodType<Prisma.TokenDistributionDeleteManyArgs> = z.object({
  where: TokenDistributionWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const SaleInformationCreateArgsSchema: z.ZodType<Prisma.SaleInformationCreateArgs> = z.object({
  select: SaleInformationSelectSchema.optional(),
  include: SaleInformationIncludeSchema.optional(),
  data: z.union([ SaleInformationCreateInputSchema,SaleInformationUncheckedCreateInputSchema ]),
}).strict() ;

export const SaleInformationUpsertArgsSchema: z.ZodType<Prisma.SaleInformationUpsertArgs> = z.object({
  select: SaleInformationSelectSchema.optional(),
  include: SaleInformationIncludeSchema.optional(),
  where: SaleInformationWhereUniqueInputSchema,
  create: z.union([ SaleInformationCreateInputSchema,SaleInformationUncheckedCreateInputSchema ]),
  update: z.union([ SaleInformationUpdateInputSchema,SaleInformationUncheckedUpdateInputSchema ]),
}).strict() ;

export const SaleInformationCreateManyArgsSchema: z.ZodType<Prisma.SaleInformationCreateManyArgs> = z.object({
  data: z.union([ SaleInformationCreateManyInputSchema,SaleInformationCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const SaleInformationCreateManyAndReturnArgsSchema: z.ZodType<Prisma.SaleInformationCreateManyAndReturnArgs> = z.object({
  data: z.union([ SaleInformationCreateManyInputSchema,SaleInformationCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const SaleInformationDeleteArgsSchema: z.ZodType<Prisma.SaleInformationDeleteArgs> = z.object({
  select: SaleInformationSelectSchema.optional(),
  include: SaleInformationIncludeSchema.optional(),
  where: SaleInformationWhereUniqueInputSchema,
}).strict() ;

export const SaleInformationUpdateArgsSchema: z.ZodType<Prisma.SaleInformationUpdateArgs> = z.object({
  select: SaleInformationSelectSchema.optional(),
  include: SaleInformationIncludeSchema.optional(),
  data: z.union([ SaleInformationUpdateInputSchema,SaleInformationUncheckedUpdateInputSchema ]),
  where: SaleInformationWhereUniqueInputSchema,
}).strict() ;

export const SaleInformationUpdateManyArgsSchema: z.ZodType<Prisma.SaleInformationUpdateManyArgs> = z.object({
  data: z.union([ SaleInformationUpdateManyMutationInputSchema,SaleInformationUncheckedUpdateManyInputSchema ]),
  where: SaleInformationWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const SaleInformationUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.SaleInformationUpdateManyAndReturnArgs> = z.object({
  data: z.union([ SaleInformationUpdateManyMutationInputSchema,SaleInformationUncheckedUpdateManyInputSchema ]),
  where: SaleInformationWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const SaleInformationDeleteManyArgsSchema: z.ZodType<Prisma.SaleInformationDeleteManyArgs> = z.object({
  where: SaleInformationWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const SaleTransactionsCreateArgsSchema: z.ZodType<Prisma.SaleTransactionsCreateArgs> = z.object({
  select: SaleTransactionsSelectSchema.optional(),
  include: SaleTransactionsIncludeSchema.optional(),
  data: z.union([ SaleTransactionsCreateInputSchema,SaleTransactionsUncheckedCreateInputSchema ]),
}).strict() ;

export const SaleTransactionsUpsertArgsSchema: z.ZodType<Prisma.SaleTransactionsUpsertArgs> = z.object({
  select: SaleTransactionsSelectSchema.optional(),
  include: SaleTransactionsIncludeSchema.optional(),
  where: SaleTransactionsWhereUniqueInputSchema,
  create: z.union([ SaleTransactionsCreateInputSchema,SaleTransactionsUncheckedCreateInputSchema ]),
  update: z.union([ SaleTransactionsUpdateInputSchema,SaleTransactionsUncheckedUpdateInputSchema ]),
}).strict() ;

export const SaleTransactionsCreateManyArgsSchema: z.ZodType<Prisma.SaleTransactionsCreateManyArgs> = z.object({
  data: z.union([ SaleTransactionsCreateManyInputSchema,SaleTransactionsCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const SaleTransactionsCreateManyAndReturnArgsSchema: z.ZodType<Prisma.SaleTransactionsCreateManyAndReturnArgs> = z.object({
  data: z.union([ SaleTransactionsCreateManyInputSchema,SaleTransactionsCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const SaleTransactionsDeleteArgsSchema: z.ZodType<Prisma.SaleTransactionsDeleteArgs> = z.object({
  select: SaleTransactionsSelectSchema.optional(),
  include: SaleTransactionsIncludeSchema.optional(),
  where: SaleTransactionsWhereUniqueInputSchema,
}).strict() ;

export const SaleTransactionsUpdateArgsSchema: z.ZodType<Prisma.SaleTransactionsUpdateArgs> = z.object({
  select: SaleTransactionsSelectSchema.optional(),
  include: SaleTransactionsIncludeSchema.optional(),
  data: z.union([ SaleTransactionsUpdateInputSchema,SaleTransactionsUncheckedUpdateInputSchema ]),
  where: SaleTransactionsWhereUniqueInputSchema,
}).strict() ;

export const SaleTransactionsUpdateManyArgsSchema: z.ZodType<Prisma.SaleTransactionsUpdateManyArgs> = z.object({
  data: z.union([ SaleTransactionsUpdateManyMutationInputSchema,SaleTransactionsUncheckedUpdateManyInputSchema ]),
  where: SaleTransactionsWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const SaleTransactionsUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.SaleTransactionsUpdateManyAndReturnArgs> = z.object({
  data: z.union([ SaleTransactionsUpdateManyMutationInputSchema,SaleTransactionsUncheckedUpdateManyInputSchema ]),
  where: SaleTransactionsWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const SaleTransactionsDeleteManyArgsSchema: z.ZodType<Prisma.SaleTransactionsDeleteManyArgs> = z.object({
  where: SaleTransactionsWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const BlockchainCreateArgsSchema: z.ZodType<Prisma.BlockchainCreateArgs> = z.object({
  select: BlockchainSelectSchema.optional(),
  include: BlockchainIncludeSchema.optional(),
  data: z.union([ BlockchainCreateInputSchema,BlockchainUncheckedCreateInputSchema ]),
}).strict() ;

export const BlockchainUpsertArgsSchema: z.ZodType<Prisma.BlockchainUpsertArgs> = z.object({
  select: BlockchainSelectSchema.optional(),
  include: BlockchainIncludeSchema.optional(),
  where: BlockchainWhereUniqueInputSchema,
  create: z.union([ BlockchainCreateInputSchema,BlockchainUncheckedCreateInputSchema ]),
  update: z.union([ BlockchainUpdateInputSchema,BlockchainUncheckedUpdateInputSchema ]),
}).strict() ;

export const BlockchainCreateManyArgsSchema: z.ZodType<Prisma.BlockchainCreateManyArgs> = z.object({
  data: z.union([ BlockchainCreateManyInputSchema,BlockchainCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const BlockchainCreateManyAndReturnArgsSchema: z.ZodType<Prisma.BlockchainCreateManyAndReturnArgs> = z.object({
  data: z.union([ BlockchainCreateManyInputSchema,BlockchainCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const BlockchainDeleteArgsSchema: z.ZodType<Prisma.BlockchainDeleteArgs> = z.object({
  select: BlockchainSelectSchema.optional(),
  include: BlockchainIncludeSchema.optional(),
  where: BlockchainWhereUniqueInputSchema,
}).strict() ;

export const BlockchainUpdateArgsSchema: z.ZodType<Prisma.BlockchainUpdateArgs> = z.object({
  select: BlockchainSelectSchema.optional(),
  include: BlockchainIncludeSchema.optional(),
  data: z.union([ BlockchainUpdateInputSchema,BlockchainUncheckedUpdateInputSchema ]),
  where: BlockchainWhereUniqueInputSchema,
}).strict() ;

export const BlockchainUpdateManyArgsSchema: z.ZodType<Prisma.BlockchainUpdateManyArgs> = z.object({
  data: z.union([ BlockchainUpdateManyMutationInputSchema,BlockchainUncheckedUpdateManyInputSchema ]),
  where: BlockchainWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const BlockchainUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.BlockchainUpdateManyAndReturnArgs> = z.object({
  data: z.union([ BlockchainUpdateManyMutationInputSchema,BlockchainUncheckedUpdateManyInputSchema ]),
  where: BlockchainWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const BlockchainDeleteManyArgsSchema: z.ZodType<Prisma.BlockchainDeleteManyArgs> = z.object({
  where: BlockchainWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const ContractStatusCreateArgsSchema: z.ZodType<Prisma.ContractStatusCreateArgs> = z.object({
  select: ContractStatusSelectSchema.optional(),
  data: z.union([ ContractStatusCreateInputSchema,ContractStatusUncheckedCreateInputSchema ]),
}).strict() ;

export const ContractStatusUpsertArgsSchema: z.ZodType<Prisma.ContractStatusUpsertArgs> = z.object({
  select: ContractStatusSelectSchema.optional(),
  where: ContractStatusWhereUniqueInputSchema,
  create: z.union([ ContractStatusCreateInputSchema,ContractStatusUncheckedCreateInputSchema ]),
  update: z.union([ ContractStatusUpdateInputSchema,ContractStatusUncheckedUpdateInputSchema ]),
}).strict() ;

export const ContractStatusCreateManyArgsSchema: z.ZodType<Prisma.ContractStatusCreateManyArgs> = z.object({
  data: z.union([ ContractStatusCreateManyInputSchema,ContractStatusCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const ContractStatusCreateManyAndReturnArgsSchema: z.ZodType<Prisma.ContractStatusCreateManyAndReturnArgs> = z.object({
  data: z.union([ ContractStatusCreateManyInputSchema,ContractStatusCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const ContractStatusDeleteArgsSchema: z.ZodType<Prisma.ContractStatusDeleteArgs> = z.object({
  select: ContractStatusSelectSchema.optional(),
  where: ContractStatusWhereUniqueInputSchema,
}).strict() ;

export const ContractStatusUpdateArgsSchema: z.ZodType<Prisma.ContractStatusUpdateArgs> = z.object({
  select: ContractStatusSelectSchema.optional(),
  data: z.union([ ContractStatusUpdateInputSchema,ContractStatusUncheckedUpdateInputSchema ]),
  where: ContractStatusWhereUniqueInputSchema,
}).strict() ;

export const ContractStatusUpdateManyArgsSchema: z.ZodType<Prisma.ContractStatusUpdateManyArgs> = z.object({
  data: z.union([ ContractStatusUpdateManyMutationInputSchema,ContractStatusUncheckedUpdateManyInputSchema ]),
  where: ContractStatusWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const ContractStatusUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.ContractStatusUpdateManyAndReturnArgs> = z.object({
  data: z.union([ ContractStatusUpdateManyMutationInputSchema,ContractStatusUncheckedUpdateManyInputSchema ]),
  where: ContractStatusWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const ContractStatusDeleteManyArgsSchema: z.ZodType<Prisma.ContractStatusDeleteManyArgs> = z.object({
  where: ContractStatusWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const TransactionAuditCreateArgsSchema: z.ZodType<Prisma.TransactionAuditCreateArgs> = z.object({
  select: TransactionAuditSelectSchema.optional(),
  include: TransactionAuditIncludeSchema.optional(),
  data: z.union([ TransactionAuditCreateInputSchema,TransactionAuditUncheckedCreateInputSchema ]),
}).strict() ;

export const TransactionAuditUpsertArgsSchema: z.ZodType<Prisma.TransactionAuditUpsertArgs> = z.object({
  select: TransactionAuditSelectSchema.optional(),
  include: TransactionAuditIncludeSchema.optional(),
  where: TransactionAuditWhereUniqueInputSchema,
  create: z.union([ TransactionAuditCreateInputSchema,TransactionAuditUncheckedCreateInputSchema ]),
  update: z.union([ TransactionAuditUpdateInputSchema,TransactionAuditUncheckedUpdateInputSchema ]),
}).strict() ;

export const TransactionAuditCreateManyArgsSchema: z.ZodType<Prisma.TransactionAuditCreateManyArgs> = z.object({
  data: z.union([ TransactionAuditCreateManyInputSchema,TransactionAuditCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const TransactionAuditCreateManyAndReturnArgsSchema: z.ZodType<Prisma.TransactionAuditCreateManyAndReturnArgs> = z.object({
  data: z.union([ TransactionAuditCreateManyInputSchema,TransactionAuditCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const TransactionAuditDeleteArgsSchema: z.ZodType<Prisma.TransactionAuditDeleteArgs> = z.object({
  select: TransactionAuditSelectSchema.optional(),
  include: TransactionAuditIncludeSchema.optional(),
  where: TransactionAuditWhereUniqueInputSchema,
}).strict() ;

export const TransactionAuditUpdateArgsSchema: z.ZodType<Prisma.TransactionAuditUpdateArgs> = z.object({
  select: TransactionAuditSelectSchema.optional(),
  include: TransactionAuditIncludeSchema.optional(),
  data: z.union([ TransactionAuditUpdateInputSchema,TransactionAuditUncheckedUpdateInputSchema ]),
  where: TransactionAuditWhereUniqueInputSchema,
}).strict() ;

export const TransactionAuditUpdateManyArgsSchema: z.ZodType<Prisma.TransactionAuditUpdateManyArgs> = z.object({
  data: z.union([ TransactionAuditUpdateManyMutationInputSchema,TransactionAuditUncheckedUpdateManyInputSchema ]),
  where: TransactionAuditWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const TransactionAuditUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.TransactionAuditUpdateManyAndReturnArgs> = z.object({
  data: z.union([ TransactionAuditUpdateManyMutationInputSchema,TransactionAuditUncheckedUpdateManyInputSchema ]),
  where: TransactionAuditWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const TransactionAuditDeleteManyArgsSchema: z.ZodType<Prisma.TransactionAuditDeleteManyArgs> = z.object({
  where: TransactionAuditWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const KycVerificationCreateArgsSchema: z.ZodType<Prisma.KycVerificationCreateArgs> = z.object({
  select: KycVerificationSelectSchema.optional(),
  include: KycVerificationIncludeSchema.optional(),
  data: z.union([ KycVerificationCreateInputSchema,KycVerificationUncheckedCreateInputSchema ]),
}).strict() ;

export const KycVerificationUpsertArgsSchema: z.ZodType<Prisma.KycVerificationUpsertArgs> = z.object({
  select: KycVerificationSelectSchema.optional(),
  include: KycVerificationIncludeSchema.optional(),
  where: KycVerificationWhereUniqueInputSchema,
  create: z.union([ KycVerificationCreateInputSchema,KycVerificationUncheckedCreateInputSchema ]),
  update: z.union([ KycVerificationUpdateInputSchema,KycVerificationUncheckedUpdateInputSchema ]),
}).strict() ;

export const KycVerificationCreateManyArgsSchema: z.ZodType<Prisma.KycVerificationCreateManyArgs> = z.object({
  data: z.union([ KycVerificationCreateManyInputSchema,KycVerificationCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const KycVerificationCreateManyAndReturnArgsSchema: z.ZodType<Prisma.KycVerificationCreateManyAndReturnArgs> = z.object({
  data: z.union([ KycVerificationCreateManyInputSchema,KycVerificationCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const KycVerificationDeleteArgsSchema: z.ZodType<Prisma.KycVerificationDeleteArgs> = z.object({
  select: KycVerificationSelectSchema.optional(),
  include: KycVerificationIncludeSchema.optional(),
  where: KycVerificationWhereUniqueInputSchema,
}).strict() ;

export const KycVerificationUpdateArgsSchema: z.ZodType<Prisma.KycVerificationUpdateArgs> = z.object({
  select: KycVerificationSelectSchema.optional(),
  include: KycVerificationIncludeSchema.optional(),
  data: z.union([ KycVerificationUpdateInputSchema,KycVerificationUncheckedUpdateInputSchema ]),
  where: KycVerificationWhereUniqueInputSchema,
}).strict() ;

export const KycVerificationUpdateManyArgsSchema: z.ZodType<Prisma.KycVerificationUpdateManyArgs> = z.object({
  data: z.union([ KycVerificationUpdateManyMutationInputSchema,KycVerificationUncheckedUpdateManyInputSchema ]),
  where: KycVerificationWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const KycVerificationUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.KycVerificationUpdateManyAndReturnArgs> = z.object({
  data: z.union([ KycVerificationUpdateManyMutationInputSchema,KycVerificationUncheckedUpdateManyInputSchema ]),
  where: KycVerificationWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const KycVerificationDeleteManyArgsSchema: z.ZodType<Prisma.KycVerificationDeleteManyArgs> = z.object({
  where: KycVerificationWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const RoleCreateArgsSchema: z.ZodType<Prisma.RoleCreateArgs> = z.object({
  select: RoleSelectSchema.optional(),
  include: RoleIncludeSchema.optional(),
  data: z.union([ RoleCreateInputSchema,RoleUncheckedCreateInputSchema ]),
}).strict() ;

export const RoleUpsertArgsSchema: z.ZodType<Prisma.RoleUpsertArgs> = z.object({
  select: RoleSelectSchema.optional(),
  include: RoleIncludeSchema.optional(),
  where: RoleWhereUniqueInputSchema,
  create: z.union([ RoleCreateInputSchema,RoleUncheckedCreateInputSchema ]),
  update: z.union([ RoleUpdateInputSchema,RoleUncheckedUpdateInputSchema ]),
}).strict() ;

export const RoleCreateManyArgsSchema: z.ZodType<Prisma.RoleCreateManyArgs> = z.object({
  data: z.union([ RoleCreateManyInputSchema,RoleCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const RoleCreateManyAndReturnArgsSchema: z.ZodType<Prisma.RoleCreateManyAndReturnArgs> = z.object({
  data: z.union([ RoleCreateManyInputSchema,RoleCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const RoleDeleteArgsSchema: z.ZodType<Prisma.RoleDeleteArgs> = z.object({
  select: RoleSelectSchema.optional(),
  include: RoleIncludeSchema.optional(),
  where: RoleWhereUniqueInputSchema,
}).strict() ;

export const RoleUpdateArgsSchema: z.ZodType<Prisma.RoleUpdateArgs> = z.object({
  select: RoleSelectSchema.optional(),
  include: RoleIncludeSchema.optional(),
  data: z.union([ RoleUpdateInputSchema,RoleUncheckedUpdateInputSchema ]),
  where: RoleWhereUniqueInputSchema,
}).strict() ;

export const RoleUpdateManyArgsSchema: z.ZodType<Prisma.RoleUpdateManyArgs> = z.object({
  data: z.union([ RoleUpdateManyMutationInputSchema,RoleUncheckedUpdateManyInputSchema ]),
  where: RoleWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const RoleUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.RoleUpdateManyAndReturnArgs> = z.object({
  data: z.union([ RoleUpdateManyMutationInputSchema,RoleUncheckedUpdateManyInputSchema ]),
  where: RoleWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const RoleDeleteManyArgsSchema: z.ZodType<Prisma.RoleDeleteManyArgs> = z.object({
  where: RoleWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const UserRoleCreateArgsSchema: z.ZodType<Prisma.UserRoleCreateArgs> = z.object({
  select: UserRoleSelectSchema.optional(),
  include: UserRoleIncludeSchema.optional(),
  data: z.union([ UserRoleCreateInputSchema,UserRoleUncheckedCreateInputSchema ]),
}).strict() ;

export const UserRoleUpsertArgsSchema: z.ZodType<Prisma.UserRoleUpsertArgs> = z.object({
  select: UserRoleSelectSchema.optional(),
  include: UserRoleIncludeSchema.optional(),
  where: UserRoleWhereUniqueInputSchema,
  create: z.union([ UserRoleCreateInputSchema,UserRoleUncheckedCreateInputSchema ]),
  update: z.union([ UserRoleUpdateInputSchema,UserRoleUncheckedUpdateInputSchema ]),
}).strict() ;

export const UserRoleCreateManyArgsSchema: z.ZodType<Prisma.UserRoleCreateManyArgs> = z.object({
  data: z.union([ UserRoleCreateManyInputSchema,UserRoleCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const UserRoleCreateManyAndReturnArgsSchema: z.ZodType<Prisma.UserRoleCreateManyAndReturnArgs> = z.object({
  data: z.union([ UserRoleCreateManyInputSchema,UserRoleCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const UserRoleDeleteArgsSchema: z.ZodType<Prisma.UserRoleDeleteArgs> = z.object({
  select: UserRoleSelectSchema.optional(),
  include: UserRoleIncludeSchema.optional(),
  where: UserRoleWhereUniqueInputSchema,
}).strict() ;

export const UserRoleUpdateArgsSchema: z.ZodType<Prisma.UserRoleUpdateArgs> = z.object({
  select: UserRoleSelectSchema.optional(),
  include: UserRoleIncludeSchema.optional(),
  data: z.union([ UserRoleUpdateInputSchema,UserRoleUncheckedUpdateInputSchema ]),
  where: UserRoleWhereUniqueInputSchema,
}).strict() ;

export const UserRoleUpdateManyArgsSchema: z.ZodType<Prisma.UserRoleUpdateManyArgs> = z.object({
  data: z.union([ UserRoleUpdateManyMutationInputSchema,UserRoleUncheckedUpdateManyInputSchema ]),
  where: UserRoleWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const UserRoleUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.UserRoleUpdateManyAndReturnArgs> = z.object({
  data: z.union([ UserRoleUpdateManyMutationInputSchema,UserRoleUncheckedUpdateManyInputSchema ]),
  where: UserRoleWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const UserRoleDeleteManyArgsSchema: z.ZodType<Prisma.UserRoleDeleteManyArgs> = z.object({
  where: UserRoleWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const TokenCreateArgsSchema: z.ZodType<Prisma.TokenCreateArgs> = z.object({
  select: TokenSelectSchema.optional(),
  include: TokenIncludeSchema.optional(),
  data: z.union([ TokenCreateInputSchema,TokenUncheckedCreateInputSchema ]),
}).strict() ;

export const TokenUpsertArgsSchema: z.ZodType<Prisma.TokenUpsertArgs> = z.object({
  select: TokenSelectSchema.optional(),
  include: TokenIncludeSchema.optional(),
  where: TokenWhereUniqueInputSchema,
  create: z.union([ TokenCreateInputSchema,TokenUncheckedCreateInputSchema ]),
  update: z.union([ TokenUpdateInputSchema,TokenUncheckedUpdateInputSchema ]),
}).strict() ;

export const TokenCreateManyArgsSchema: z.ZodType<Prisma.TokenCreateManyArgs> = z.object({
  data: z.union([ TokenCreateManyInputSchema,TokenCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const TokenCreateManyAndReturnArgsSchema: z.ZodType<Prisma.TokenCreateManyAndReturnArgs> = z.object({
  data: z.union([ TokenCreateManyInputSchema,TokenCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const TokenDeleteArgsSchema: z.ZodType<Prisma.TokenDeleteArgs> = z.object({
  select: TokenSelectSchema.optional(),
  include: TokenIncludeSchema.optional(),
  where: TokenWhereUniqueInputSchema,
}).strict() ;

export const TokenUpdateArgsSchema: z.ZodType<Prisma.TokenUpdateArgs> = z.object({
  select: TokenSelectSchema.optional(),
  include: TokenIncludeSchema.optional(),
  data: z.union([ TokenUpdateInputSchema,TokenUncheckedUpdateInputSchema ]),
  where: TokenWhereUniqueInputSchema,
}).strict() ;

export const TokenUpdateManyArgsSchema: z.ZodType<Prisma.TokenUpdateManyArgs> = z.object({
  data: z.union([ TokenUpdateManyMutationInputSchema,TokenUncheckedUpdateManyInputSchema ]),
  where: TokenWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const TokenUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.TokenUpdateManyAndReturnArgs> = z.object({
  data: z.union([ TokenUpdateManyMutationInputSchema,TokenUncheckedUpdateManyInputSchema ]),
  where: TokenWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const TokenDeleteManyArgsSchema: z.ZodType<Prisma.TokenDeleteManyArgs> = z.object({
  where: TokenWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const TokensOnBlockchainsCreateArgsSchema: z.ZodType<Prisma.TokensOnBlockchainsCreateArgs> = z.object({
  select: TokensOnBlockchainsSelectSchema.optional(),
  include: TokensOnBlockchainsIncludeSchema.optional(),
  data: z.union([ TokensOnBlockchainsCreateInputSchema,TokensOnBlockchainsUncheckedCreateInputSchema ]),
}).strict() ;

export const TokensOnBlockchainsUpsertArgsSchema: z.ZodType<Prisma.TokensOnBlockchainsUpsertArgs> = z.object({
  select: TokensOnBlockchainsSelectSchema.optional(),
  include: TokensOnBlockchainsIncludeSchema.optional(),
  where: TokensOnBlockchainsWhereUniqueInputSchema,
  create: z.union([ TokensOnBlockchainsCreateInputSchema,TokensOnBlockchainsUncheckedCreateInputSchema ]),
  update: z.union([ TokensOnBlockchainsUpdateInputSchema,TokensOnBlockchainsUncheckedUpdateInputSchema ]),
}).strict() ;

export const TokensOnBlockchainsCreateManyArgsSchema: z.ZodType<Prisma.TokensOnBlockchainsCreateManyArgs> = z.object({
  data: z.union([ TokensOnBlockchainsCreateManyInputSchema,TokensOnBlockchainsCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const TokensOnBlockchainsCreateManyAndReturnArgsSchema: z.ZodType<Prisma.TokensOnBlockchainsCreateManyAndReturnArgs> = z.object({
  data: z.union([ TokensOnBlockchainsCreateManyInputSchema,TokensOnBlockchainsCreateManyInputSchema.array() ]),
  skipDuplicates: z.boolean().optional(),
}).strict() ;

export const TokensOnBlockchainsDeleteArgsSchema: z.ZodType<Prisma.TokensOnBlockchainsDeleteArgs> = z.object({
  select: TokensOnBlockchainsSelectSchema.optional(),
  include: TokensOnBlockchainsIncludeSchema.optional(),
  where: TokensOnBlockchainsWhereUniqueInputSchema,
}).strict() ;

export const TokensOnBlockchainsUpdateArgsSchema: z.ZodType<Prisma.TokensOnBlockchainsUpdateArgs> = z.object({
  select: TokensOnBlockchainsSelectSchema.optional(),
  include: TokensOnBlockchainsIncludeSchema.optional(),
  data: z.union([ TokensOnBlockchainsUpdateInputSchema,TokensOnBlockchainsUncheckedUpdateInputSchema ]),
  where: TokensOnBlockchainsWhereUniqueInputSchema,
}).strict() ;

export const TokensOnBlockchainsUpdateManyArgsSchema: z.ZodType<Prisma.TokensOnBlockchainsUpdateManyArgs> = z.object({
  data: z.union([ TokensOnBlockchainsUpdateManyMutationInputSchema,TokensOnBlockchainsUncheckedUpdateManyInputSchema ]),
  where: TokensOnBlockchainsWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const TokensOnBlockchainsUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.TokensOnBlockchainsUpdateManyAndReturnArgs> = z.object({
  data: z.union([ TokensOnBlockchainsUpdateManyMutationInputSchema,TokensOnBlockchainsUncheckedUpdateManyInputSchema ]),
  where: TokensOnBlockchainsWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;

export const TokensOnBlockchainsDeleteManyArgsSchema: z.ZodType<Prisma.TokensOnBlockchainsDeleteManyArgs> = z.object({
  where: TokensOnBlockchainsWhereInputSchema.optional(),
  limit: z.number().optional(),
}).strict() ;